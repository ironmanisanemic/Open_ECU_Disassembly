╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                      ║
║                                                  8061β Disassembly                                                   ║
║                                                                                                                      ║
║                   Binary File :                                   S6x file :                                         ║
║                                                                                           aa.s6x                     ║
║                                8192 (2000) bytes                                                                     ║
║                                                                                                                      ║
║                   Options :                                                                                          ║
║                                  Default options                                                                     ║
║                                                                                                                      ║
║                   CheckSum :                                      SMP Base Address :        6000                     ║
║                                             8441                  CC Exe Time :             005d                     ║
║                                            Valid                                                                     ║
║                   Banks :                                                                                            ║
║                                8   00000   01fff                                                                     ║
║                                                                                                                      ║
║                   RBases :                                                                                           ║
║                               si    2400    2b1b                                                                     ║
║                                                                                                                      ║
╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                               ║
║                                                                                                                               ║
║   CATCH CODE    AA  (VM100 circuit board)   1985 UK Ford Granada Scorpio 2.8, 5 speed manual.                                 ║
║   2.8 Litre V6 'Cologne' engine 1985.  UK LEADED 4 Star (~98 octane).                                                         ║
║   Open loop - no EGO.  Basic 2 digit error codes.  Twin VAFS - one per bank with split inlet manifold.                        ║
║   Bank Fired Injection, NOT SYNCED. Simply injects every 3 sparks, twice per cycle.                                           ║
║   TFI distributor - no cyl 1 narrow slot in dizzy.                                                                            ║
║   Seems to have NDS, ACC, but no coded ACC cutoff ?   Optional BAP, EGR. Fixed Octane adjustments 0, 3, 6 degree retard       ║
║   One idle speed adjust, by 75 rpm                                                                                            ║
║   Static Timing in this code appears to be 10 BTDC, but UK Haynes workshop manual states 12.                                  ║
║   Injectors are Bosch 0 280 150 219  (-> 168cc/min, 121 gms/min, 16 lbs/hr ?)                                                 ║
║   Calibration of sensors, tables etc. appears to be metric.                                                                   ║
║   Auto versions used 'BA'.   This code has some NDS handling in code, but workshop manual says to ground NDS for manuals.     ║
║   No switches on manual gearbox.  No KAM and small RAM.  CPU marked 'T6126' (= 8061 with no KAM ?)                            ║
║   From inspection of board 7.5 Mhz crystal clock = 4.8uS IOTIMER in hardware.                                                 ║
║      1                                                                                                                        ║
║                                                                                                                               ║
║                                                                                                                               ║
║                                                                                                                               ║
║   ~#                                                                                                                          ║
║   AD Channels:                                                                                                                ║
║   0 VAF1  1 VCAL  2 ACC  3 x   4 x  5 x  6 OCT  7 TP  8 ECT  9 ACT  A NDS  B x   C VAF2                                       ║
║   #                                                                                                                           ║
║   I/0 mappings:    0    1     2     3     4     5       6       7      8     9     10                                         ║
║   HSI: (bit)      PIP    x    BAP   STI    x    Idle     x       x                                                            ║
║   HSO: (chno)     EGR    x     x     x     x    SPOUT  INJ1    INJ2    ISC   STO   S/W                                        ║
║   LSO: (bit)       x     x     x     x     x     x     CPUOK   Pump                                                           ║
║   BIDI:(bit)       - - - Not used - - -                                                                                       ║
║                                                                                                                               ║
║   A/D Inputs 0-12 mapped to R7e - R96.    AD 3 4 5 11 not used, but occupy space                                              ║
║   #                                                                                                                           ║
║   Internal Voltages measured by DVM from actual circuit board.                                                                ║
║   Pin Action  AD and Result       Code trigger points     Description/Notes                                                   ║
║   24  ground  AD6  5v => 2.536v   1.92 < V <= 3.845,      3 degrees ign delay                                                 ║
║   23  ground  AD6  5v => 1.245v   0    < V <= 1.92V       6 degrees ign delay                                                 ║
║   30  ground? AD10 5v => 3.453v   4.165V, 2.76V, 1.885V   P,D,N by resistor network ?                                         ║
║   10  12V in? AD2      >=2.56v    EEC schematic has 3.3K/2.7K divider = 5.4V)                                                 ║
║                                   Raw A/D input > 5.69V ?                                                                     ║
║   30? ground  HSI 5  High->Low    add 75rpm to Idle speed (in ISC routine)                                                    ║
║   ?  ground  HSI 3  High->Low    STI    Self test                                                                             ║
║                                                                                                                               ║
║      Registers -                                                                                                              ║
║   Base Regs 0-0x10                                                                                                            ║
║   0   (Zero)    always zero                                                                                                   ║
║   2    @2                                                                                                                     ║
║   2  7   @2:7 Fuel Pump Drive                                                                                                 ║
║   2  6   @2:6 Hardware Watchdog - keep alive signal  [4mS tick]                                                               ║
║   3    @3                                                                                                                     ║
║   4    @4                                                                                                                     ║
║   5    @5                                                                                                                     ║
║   6    @6                                                                                                                     ║
║   8    @8                                                                                                                     ║
║   9    @9                                                                                                                     ║
║   a    @a                                                                                                                     ║
║      0 @a:0                                                                                                                   ║
║      1 @a:1                                                                                                                   ║
║      2 @a:2                                                                                                                   ║
║      3 @a:3                                                                                                                   ║
║      4 @a:4                                                                                                                   ║
║   b   @b                                                                                                                      ║
║   c   @c                                                                                                                      ║
║   d   @d                                                                                                                      ║
║   e   @e                                                                                                                      ║
║   10  @10                                                                                                                     ║
║   (bit 7 (15) Most significant, bit 0 Least)                                                                                  ║
║   Add Bit    Name             Description                                                                                     ║
║                                                                                                                               ║
║   12     @12 Timer Overflow counter  (~0.3 secs) not accessed anywhere                                                        ║
║   14     @14 general - used in error code/sensor check                                                                        ║
║   15     @15 TEST MODE FLAGS word                                                                                             ║
║      1   @15:1 Shutdown/end of Self test ? not sure                                                                           ║
║      2   @15:2 Engine Off Self test                                                                                           ║
║      3   @15:3 Engine On self Test                                                                                            ║
║   16     @16 Failure flags - Used for STI testing and output codes                                                            ║
║      1   @16:1 First 6 match 'master' copy (R18)                                                                              ║
║      2   @16:2                                                                                                                ║
║      3   @16:3                                                                                                                ║
║      4   @16:4                                                                                                                ║
║      5   @16:5                                                                                                                ║
║      6   @16:6                                                                                                                ║
║      7   @16:7 Vaf 1 or 2 out of range in KOEO static test ?                                                                  ║
║      8   @16:8                                                                                                                ║
║      9   @16:9                                                                                                                ║
║   18     @18 Sensor failed flags - from std regular checks.                                                                   ║
║      1   @18:1                                                                                                                ║
║      2   @18:2                                                                                                                ║
║      3   @18:3                                                                                                                ║
║      4   @18:4                                                                                                                ║
║      5   @18:5                                                                                                                ║
║      6   @18:6 This code is masked out in code - BAP is optional.                                                             ║
║   1a     @1a Ignition status flags                                                                                            ║
║      0   @1a:0 missed 'off' event                                                                                             ║
║      1   @1a:1 missed 'on' event                                                                                              ║
║      2   @1a:2 current state                                                                                                  ║
║      3   @1a:3 stops PIP being locked for 1 event (for calc or sync to take place ?)                                          ║
║      4   @1a:4 Spark locked to PIP signal, below specified rpm (1000)                                                         ║
║      5   @1a:5 Mark transition (for spark syncing ?)                                                                          ║
║      6   @1a:6 < 600 rpm. Use Underspeed Strategy. (rich mixture etc) Clear >650 rpm                                          ║
║      7   @1a:7 < 450 rpm  Use Cranking Strategy.   Clear > 500 rpm                                                            ║
║   1b     @1b                                                                                                                  ║
║      7   @1b:7 New base calc required                                                                                         ║
║   1c     @1c Calculated Ignition advance                                                                                      ║
║   1d     @1d Last calc Ignition Advance                                                                                       ║
║   1e     @1e PIP High Time - Length of PIP 'ON' waveform (in IOTIMER ticks)                                                   ║
║   20     @20                                                                                                                  ║
║      0   @20:0 Zero or negative change (delta). No Accel pump reqd (part throttle or closed ?)                                ║
║      1   @20:1 used only in STI test sequence, with VAFs?                                                                     ║
║      2   @20:2 Large throttle pedal change (WOT ?)                                                                            ║
║      6   @20:6 VAF out of range flags ( > 1V with engine off ?) Used in STI test                                              ║
║      7   @20:7                                                                                                                ║
║   21     @21 Elapsed Millisecs count. Cycles 0-125 mS to drive eights of sec counter (R2a)                                    ║
║   22     @22 Injection scaler. Fixed at 0x4000 here, probably fuel ratio for EGO adjustment.                                  ║
║   24     @24 Set to time in secs for special 'cold start' handling.(sets B0 R2c)                                              ║
║   26     @26 High byte of ACT_START value                                                                                     ║
║   27     @27 smoothed ACT value at startup. F for alternate Ignition advance for defined time (243c)                          ║
║   28     @28 Bank 1 Load value/base fuel by bank, as looked up from Load table (24b8)                                         ║
║   29     @29 Bank 2 Load                                                                                                      ║
║   2a     @2a Eights sec counter. Counts DOWN for some reason 8 -> 1. Set to 8 at 'New second' event                           ║
║   2c     @2c                                                                                                                  ║
║      0   @2c:0 Set if less than 'cold secs' (R24) expired, changes ISC handling (RPM, anti stall)                             ║
║      1   @2c:1 Fuel cutoff, throttle closed ?                                                                                 ║
║      2   @2c:2 Fuel Weaken instead of cutoff below defined rpm, (anti stall/backfire ?)                                       ║
║      3   @2c:3 Set if wide throttle (and rpm threshold) - sets minimum fuel, adds ign delay, etc                              ║
║   2d     @2d Elapsed Seconds counter. (Self Test routine checks more than 2 secs elapsed).                                    ║
║   2e     @2e Last ISC (output) state change time (IOTIMER)                                                                    ║
║   30-3f  @30 General purpose registers - used everywhere                                                                      ║
║   40     @40 Last PIP Low->High event time (IOTIMER)                                                                          ║
║   42     @42 Last ign delay time (120 degrees - ign advance)(from R58)                                                        ║
║   44     @44 Time between PIP High events (i.e Low->High transitions) in IOTIMER ticks                                        ║
║   46     @46 Last PIP High Pulsewidth time (IOTIMER ticks)                                                                    ║
║   48     @48 Cylinder number. Actually only counts 1-3.  For bank injection triggers.                                         ║
║   49     @49                                                                                                                  ║
║      0   @49:0 Bank 2 injection 'on' was delayed/is pending                                                                   ║
║      2   @49:2 Bank 2 injection 'off'was delayed/is pending                                                                   ║
║   4a     @4a R4a and R4c are time holders used in ignition interrupt handler                                                  ║
║   4c     @4c                                                                                                                  ║
║   4e     @4e Fuel Clip Timer for fuel weaken on throttle close (600mS)                                                        ║
║   50     @50 Injector slope. Lookup value via function from VBATT (R52)                                                       ║
║   52     @52 Battery voltage lookup value - used only for injector slope calc.                                                ║
║   54     @54 Last HSI state - track bit changes (= interrupt)                                                                 ║
║   55     @55 Counts IOTIMER overflows. 3 events = ~1 sec,  for fuel pump driver                                               ║
║   56     @56 Last Keep Alive time  (IOTIME for 'CPU OK' keepalive pulses)                                                     ║
║   58     @58 Calculated Ignition Delay time                                                                                   ║
║   5a     @5a                                                                                                                  ║
║      2   @5a:2 Markers for required functions, subroutines                                                                    ║
║      3   @5a:3                                                                                                                ║
║      4   @5a:4                                                                                                                ║
║      5   @5a:5                                                                                                                ║
║      6   @5a:6 Set when New ISC calc (by RPM ?)reqd                                                                           ║
║      7   @5a:7 Set when ISC timer reset -> 2 secs ?                                                                           ║
║   5b     @5b Main Task loop count (1-4)                                                                                       ║
║   5c     @5c Filtered RPM.  Used for PIP Calculation switch                                                                   ║
║   5e     @5e Last SPARK OUT ON and OFF times (IOTIMER) - for ign calcs                                                        ║
║   60     @60                                                                                                                  ║
║   62     @62                                                                                                                  ║
║   64     @64 Cyl charge by bank - grams air? (mass flow/rpm/3 effectively)                                                    ║
║   66     @66 used in sensor check                                                                                             ║
║   67     @67 Timer, Eights sec,  used for STO code output ?                                                                   ║
║   68     @68 used in sensor check                                                                                             ║
║   69     @69                                                                                                                  ║
║       0  @69:0 Overflow markers - for debug only ? Not used anywhere                                                          ║
║       2  @69:2                                                                                                                ║
║       3  @69:3                                                                                                                ║
║       5  @69:5                                                                                                                ║
║   6a     @6a General use                                                                                                      ║
║   6c                                                                                                                          ║
║   6e     @6e temp compensation                                                                                                ║
║   70     @70 RPM times 4, so 0.25 resolution                                                                                  ║
║   72     @72 ECT after conversion, degrees C/2                                                                                ║
║   73     @73 ACT after conversion, Degrees C/2                                                                                ║
║   74     @74 Only ever written - DEBUG ?                                                                                      ║
║   76     @76 Width of trip pulse => STO , always 50% duty cycle                                                               ║
║   78     @78 Last O/P time                                                                                                    ║
║   7a     @7a used only in main loop (main task number ? 1-4)                                                                  ║
║   7b     @7b number of sensor reads for START value (=10)                                                                     ║
║   7c     @7c ignition delay in degrees*4 ( 0, 3, 6 degrees)                                                                   ║
║   7d                           not used ?                                                                                     ║
║          7e to 97 are RAW A/D inputs                                                                                          ║
║   7e     @7e VAF2 - Word, high byte used as coarse value (cranking and accel pump ?)                                          ║
║   7f     @7f VAF2_raw high byte                                                                                               ║
║   80     @80 Vss supply - Battery level                                                                                       ║
║   82     @82 Air Con Clutch                                                                                                   ║
║   84-88  @88 not used                                                                                                         ║
║   8a     @8a Octane adjust (2 wires for 3 voltage levels)                                                                     ║
║   8c     @8c Throttle position                                                                                                ║
║   8e     @8e Engine block temp                                                                                                ║
║   90     @90 Air charge temp                                                                                                  ║
║   92     @92 Neutral Drive SW                                                                                                 ║
║   94     @94 not used                                                                                                         ║
║   96     @96 VAF1                                                                                                             ║
║   97     @97 VAF1_raw high byte                                                                                               ║
║   98     @98 Task number for 2nd task list lookup                                                                             ║
║   9a     @9a Mass flow after calculations (BAP, ACT etc)                                                                      ║
║   9c     @9c                                                                                                                  ║
║   9e     @9e                                                                                                                  ║
║   9f     @9f Initial Start value ECT - choke/enrich ?                                                                         ║
║   a0     @a0                                                                                                                  ║
║   a2     @a2 result of ECT (= block temp) and other calcs for enrich of base fuel 16384 = 1:1                                 ║
║   a4     @a4 used in VAF calc                                                                                                 ║
║   a6     @a6 Top byte of VAF val - used for accel pump and cranking calcs                                                     ║
║   a8     @a8                                                                                                                  ║
║   a9     @a9                                                                                                                  ║
║      1   @a9:1 set if ign delay calc 120 degree (60 degree if clear)                                                          ║
║      2   @a9:2 swopping lead/trail edge ? Skip one PIP signal and clear spout_rqd                                             ║
║      3   @a9:3 PIP Trigger (lead or trail edge) - set/clear hysteresis <=1000 >= 1050.                                        ║
║      5   @a9:5                                                                                                                ║
║   aa     @aa TPS 'angle' (current voltage - min voltage) - for accel pump function                                            ║
║   ac     @ac Ignition delay delta. smoothed and limited, for ign changes                                                      ║
║   ae     @ae                                                                                                                  ║
║      1   @ae:1 Standard 'Run Mode'.  Continue 'Engine Running' timer                                                          ║
║      5   @ae:5 Set at initialise clears after first PIP.  Stops the 'Cranking' timer                                          ║
║      6   @ae:6 set at initialise, clears after first PIP high.                                                                ║
║   af     @af used in accel calc ?                                                                                             ║
║   b0     @b0 not used ?                                                                                                       ║
║   b2     @b2 Output subroutine flags                                                                                          ║
║      0   @b2:0 O/P event was missed as HSO_OVF set (event list full)                                                          ║
║      4   @b2:4 O/P NOW, otherwise at specified time                                                                           ║
║      5   @b2:5 O/P on time or delayed by 200uS                                                                                ║
║      6   @b2:6                                                                                                                ║
║      7   @b2:7                                                                                                                ║
║   b3     @b3                                                                                                                  ║
║      0   @b3:0 Marker to sync two subroutine calcs                                                                            ║
║      2   @b3:2                                                                                                                ║
║      3   @b3:3                                                                                                                ║
║      4   @b3:4                                                                                                                ║
║      5   @b3:5 Status telltales for various outputs                                                                           ║
║      6   @b3:6                                                                                                                ║
║   b4     @b4 Output services required                                                                                         ║
║      0   @b4:0                                                                                                                ║
║      1   @b4:1                                                                                                                ║
║      2   @b4:2                                                                                                                ║
║      6   @b4:6                                                                                                                ║
║      7   @b4:7                                                                                                                ║
║   b5     @b5                                                                                                                  ║
║      0   @b5:0 Timer overflow (every 0.3 secs)                                                                                ║
║      1   @b5:1 'Drive' selected ?     Affects ISC.                                                                            ║
║      2   @b5:2 'Neutral' selected ?                                                                                           ║
║      3   @b5:3 ACC switched on ?                                                                                              ║
║      4   @b5:4 NDS slection change ?                                                                                          ║
║      5   @b5:5 set base 10 BTDC if set, 12 degrees if unset (from ISC calc)                                                   ║
║      6   @b5:6 new PIP (ign calc required)                                                                                    ║
║      7   @b5:7 new RPM (rpm calc required)                                                                                    ║
║   b6     @b6 Missed/pending events                                                                                            ║
║      2   @b6:2                                                                                                                ║
║      4   @b6:4                                                                                                                ║
║      6   @b6:6                                                                                                                ║
║   b7     @b7                                                                                                                  ║
║      5   @b7:5 change idle RPM by 75 rpm (in ISC calc)                                                                        ║
║   b8                                                                                                                          ║
║   ba     @ba gen registers                                                                                                    ║
║   bc     @bc                                                                                                                  ║
║   be     @be Filtered RPM used for ISC calc                                                                                   ║
║   c0     @c0 Cranking Timer - secs - for preset Pulswidth injection calcs                                                     ║
║   c2     @c2 Actual Inject event start time Bank 1 (IOTIMER)                                                                  ║
║   c4     @c4 Actual Inject event stop time Bank 1                                                                             ║
║   c6     @c6 Actual Inject time Bank 1                                                                                        ║
║   c8     @c8 TPS Minimum Raw value - for TPS flags                                                                            ║
║   ca     @ca Enrich Factor value from accel pump calc - per bank                                                              ║
║   cc     @cc                                                                                                                  ║
║   ce     @ce Base injection charge (fuel) calc results (flow/14.64)                                                           ║
║   d0     @d0                                                                                                                  ║
║   d2     @d2 not used ?                                                                                                       ║
║   d4     @d4 Actual on and off, and length inject times Bank 2 (IOTIMER)                                                      ║
║   d6     @d6                                                                                                                  ║
║   d8     @d8                                                                                                                  ║
║   da     @da Bank Injection Scalers for ?  Fixed at 16                                                                        ║
║   db     @db                                                                                                                  ║
║   dc     @dc Accel pump enrich Scalers used in main injection calc. Base 1:1 = 64                                             ║
║   dd     @dd                                                                                                                  ║
║   de     @de Accel pump timers in millisecs - run for ~1 second whilst Accel Pump active                                      ║
║   e0     @e0                                                                                                                  ║
║   e2     @e2 Track TPS position for Accel pump recalc                                                                         ║
║   e4     @e4                                                                                                                  ║
║   e6     @e6 ISC - 20 mSecs ?                                                                                                 ║
║   e8     @e8 copied from cyl flow calc                                                                                        ║
║   ea     @ea ENGINE RUNNING Timer, seconds - Elapsed time since first PIP ?                                                   ║
║   ec     @ec Filtered, Smoothed TPS value/angle                                                                               ║
║   ee     @ee Last PIP high_low transition time (IOTIMER)                                                                      ║
║   f0     @f0 Ignition change (after calc) - limited to 10%                                                                    ║
║   f2     @f2 temp result holder, for DEBUG ?                                                                                  ║
║   f4     @f4 ISC timer 2 secs ?                                                                                               ║
║   f6     @f6                                                                                                                  ║
║      0   @f6:0 Bits for signed and unsigned lookup functions                                                                  ║
║      1   @f6:1                                                                                                                ║
║   f7     @f7 Dummy timer entries, f7->fc also used in sensor check subroutines                                                ║
║   f8                                                                                                                          ║
║   f9                                                                                                                          ║
║   fa                                                                                                                          ║
║   fb                                                                                                                          ║
║   fc                                                                                                                          ║
║   fd                                                                                                                          ║
║   fe     @fe    NDS timer - 1 second ?                                                                                        ║
║                  DATA and other RAM locations                                                                                 ║
║   100-11a    Stack                                                                                                            ║
║      NB> some DEBUG items seem to be written but not read - assumed to be for cal console.                                    ║
║   128 @128 Last PIP pulsewidth, used for ignition delay delta & smoothing                                                     ║
║   12a @12a DEBUG? Base airflow value, VAF2                                                                                    ║
║   130 @130 final calculated value for ISC pulsewidth, after slope compensation                                                ║
║   132 @132 Calculated idle speed (RPM) after corrections etc.                                                                 ║
║   134 @134 DEBUG ? calculated Idle speed delta.                                                                               ║
║   136 @136 used in ISC calc - multiplier from 29fc table ?                                                                    ║
║   138 @138 DEBUG? Value from ECTXRPM lookup table in ISC calc                                                                 ║
║   13a @13a Double length result of calc for ISC - something pulswidth or time ?                                               ║
║   13c @13c  "                                                                                                                 ║
║   140 @140 EGR calculated pulswidth                                                                                           ║
║   142 @142 EGR last output time                                                                                               ║
║   144 @144 IOTimer value when timer list last run - for accurate time delta                                                   ║
║   146 @146 TPS Last time read (IOtimer)                                                                                       ║
║   148 @148 TPS interval between reads (for delta calc)                                                                        ║
║   14a @14a DEBUG ? result of main injection time calc for bank 1 (Timer ticks)                                                ║
║   14c @14c DEBUG ?  " for bank 2                                                                                              ║
║   152 @152 BAP Last read time (for delta calc)                                                                                ║
║   154 @154 BAP Interval between state changes (1/2 of frequency)                                                              ║
║   156 @156 BAP input frequency * 2                                                                                            ║
║   158 @158 BAP value from lookup = inches Hg*8 (atmospheric pressure*8)                                                       ║
║   159 @159 Fuel clip ratio (both Injection banks)                                                                             ║
║   15a @15a DEBUG ?  FLAG BITS. RPM,Ign, Fail flags (R1a, R2c, R18) pump rqd etc                                               ║
║   15c @15c Injection time (double word) without VBATT compensation, not yet output to trip.                                   ║
║   15e @15e "                                                                                                                  ║
║   160 @160 Inject time for Cranking                                                                                           ║
║   162 @162 (double word) Counter for trip. (1 sec trip update ? not sure)                                                     ║
║   164 @164                                                                                                                    ║
║   166 @166 AD7 smoothed voltage - for OCTANE ADJUST 0,3,6 degrees)                                                            ║
║                                     Data,Cal,Params                                                                           ║
║   2400 @2400 Scaler = VAF raw/2                                                                                               ║
║   2402 @2402 VAF Post processing adjustments - not used                                                                       ║
║   2404 @2404                                                                                                                  ║
║   2406 @2406 Same for 2nd VAF.                                                                                                ║
║   2408 @2408                                                                                                                  ║
║   240a @240a                                                                                                                  ║
║   240c @240c (239)     Default BAP value = 29.875*8    1 atmosphere = 29.92                                                   ║
║   2410 @2410 (450rpm)  Cranking set below this speed. Cleared at this + hysteresis (24ae below)                               ║
║   2412 @2412 (600rpm)  Underspeed cleared above this                                                                          ║
║   2414 @2414 (505rpm)  Underspeed set below this                                                                              ║
║   2416 @2416 (1500rpm) Fuel Weakened instead of full cutoff below this RPM (stall risk ?)                                     ║
║   2418 @2418 (1800rpm) Knock risk (if WOT) above here. Used for fuel and ignition                                             ║
║   241a @241a (250C)    Max ECT start value (deg C) This and timer used for ignition                                           ║
║   241b @241b (-40C)    Min ECT start value and fuel weaken/cutoff - for cold starts, but would never be used !                ║
║   241c @241c (0 secs)  Timer Limit for cold start conditions (not used)                                                       ║
║   241e @241e Injector size, possibly to scale for 0.25 grams fuel per 125mS (=32768 in calcs) ?                               ║
║   2420 @2420 (7.97mS)  Max cyl charge BEFORE Corrections. (12:1, or 3380cc max at 14.64:1).                                   ║
║   2422 @2422 (0.19g)   Min charge applied if knock risk flag set => 0.19g air => 35% Cyl fill                                 ║
║   2424 @2424 (0.1v)    Stops accel pump recalc if TPS delta/change below this value (0.025v*4)                                ║
║   2426 @2426 (130%)    Underspeed emergency fuel enrich => 83/64 => 130 %                                                     ║
║   2427 @2427 (0%)      Knock risk fuel enrich, base 128                                                                       ║
║   2428 @2428 (80c)     'Cold Start' condition below here, with timer defined by lookup table (2818)                           ║
║   2429 @2429 RPM flags preset for RPM_flags (R2c)                                                                             ║
║   242a @242a Used in sensor check - not sure what this does                                                                   ║
║   242b @242b Used in sensor check                                                                                             ║
║   242c @242c Multiplier for density table scaler for injection/air flow calcs                                                 ║
║   242e @242e                                                                                                                  ║
║   2430 @2430 above this and if knock risk, ignition knock increment (2468) added (big throttle change)                        ║
║   2432 @2432                                                                                                                  ║
║   2433 @2433 50 degrees max advance => rotor register                                                                         ║
║   2434 @2434                                                                                                                  ║
║   2435 @2435 ACT and ECT Limits for alternate Ignition Advance with ECT/ACT_START Values upon initial startup                 ║
║   2436 @2436                                                                                                                  ║
║   2437 @2437 Default value if ECT fail => 100 deg C                                                                           ║
║   2438 @2438 Default value if ACT fail => 20 Deg C                                                                            ║
║   243a @243a Default value if VAF fail => 400 L/min ?                                                                         ║
║   243b @243b Default value top byte of VAF default, for accel pump and cranking calcs                                         ║
║   243c @243c Used with ign table choice (safety limits ?)                                                                     ║
║   243e @243e Accel pump time, 1 second (16*63 = 1008 mS) If no TPS changes/recalc                                             ║
║   243f @243f Minimum time expired before recalc of accel pump allowed (30mS)                                                  ║
║   2440 @2440 divider for Trip frequency = 1 o/p tick per 0.01 grams ?                                                         ║
║   2442 @2442                                                                                                                  ║
║   2444 @2444 Ign calc swops here from 'locked to PIP' to 'calced advance'                                                     ║
║   2446 @2446 Hysteresis - 'dead band' for swop                                                                                ║
║   2448 @2448 TPS trigger points (0.065v) - No delta set if smaller than this                                                  ║
║   244a @244a TPS 'Big Delta' set if change bigger than this (0.25v) ('goosed' or WOT ?)                                       ║
║   244c @244c Controls injection calcs                                                                                         ║
║   244e @244e                                                                                                                  ║
║   2450 @2450 Underspeed ISC setting - 80% - goes in top byte                                                                  ║
║   2451 @2451 Cranking ISC setting - 100% goes in top byte                                                                     ║
║   2452 @2452 Set fixed ISC if not zero                                                                                        ║
║   2453 @2453 Fixed PW if ISC_Lock set. (50% open)                                                                             ║
║   2454 @2454 Used with ISC                                                                                                    ║
║   2456 @2456 Used with 'cold start' affects ISC                                                                               ║
║   2458 @2458 0 - No EGR, 1 - Fixed pulse width PW1 (245a)                                                                     ║
║   245a @245a                                                                                                                  ║
║   245c @245c                                                                                                                  ║
║   245e @245e                                                                                                                  ║
║   2460 @2460                                                                                                                  ║
║   2462 @2462                                                                                                                  ║
║   2464 @2464 Max RPM - ignition cutoff                                                                                        ║
║   2466 @2466 Base ISC frequency. 160Hz (1302 * 4.8uS = 6.25 mS)                                                               ║
║   2468 @2468 Ign delay to prevent Knocking - wide throttle and 2500 RPM (see 2430)                                            ║
║   246a @246a                                                                                                                  ║
║   246c @246c if failed start or stall, begin crank PW calc from here (12 secs)                                                ║
║   2470 @2470                                                                                                                  ║
║   2472 @2472                                                                                                                  ║
║   2474 @2474 Preset ignition delay, as selected via AD7 (OCTANE)                                                              ║
║   2475 @2475                                                                                                                  ║
║   2476 @2476                                                                                                                  ║
║   2477 @2477 Default - also 6 degrees.                                                                                        ║
║   2478 @2478 EGR is Output channel 1 if set, 0 otherwise                                                                      ║
║   247a @247a                                                                                                                  ║
║   247c @247c Min ISC pulswidth = 10%                                                                                          ║
║   247e @247e ACC additional ISC pulswidth - if ACC_on set (0%)                                                                ║
║   2480 @2480 NDS additional ISC pulswidth - if NDS_drive set (6.5%)                                                           ║
║   2482 @2482                                                                                                                  ║
║   2484 @2484 Min and max raw sensor voltages                                                                                  ║
║   2486 @2486                                                                                                                  ║
║   2488 @2488                                                                                                                  ║
║   248a @248a                                                                                                                  ║
║   248c @248c                                                                                                                  ║
║   248e @248e                                                                                                                  ║
║   2490 @2490                                                                                                                  ║
║   2492 @2492                                                                                                                  ║
║   2494 @2494 12 degrees ign advance (set in ISC calc, when ?)                                                                 ║
║   2496 @2496                                                                                                                  ║
║   2498 @2498                                                                                                                  ║
║   249a @249a EGR behaviour against run time                                                                                   ║
║   249b @249b secs                                                                                                             ║
║   249c @249c                                                                                                                  ║
║   249e @249e                                                                                                                  ║
║   24a0 @24a0                                                                                                                  ║
║   24a2 @24a2                                                                                                                  ║
║   24a4 @24a4 Max Injection (cyl charge) allowed                                                                               ║
║   24a6 @24a6 Idle speed adjust - 75 rpm                                                                                       ║
║   24a8 @24a8 calculated Trip ?                                                                                                ║
║   24aa @24aa NDS scaler if flag set - for ISC base 128 so this is 1.                                                          ║
║   24ac @24ac NDS additional ignition delay                                                                                    ║
║   24ae @24ae Cranking set/clear hysteresis, 50 rpm                                                                            ║
║   24b0 @24b0 Ignition Preset Delay select voltage points                                                                      ║
║   24b2 @24b2                                                                                                                  ║
║   24b4 @24b4                                                                                                                  ║
║   24b6 @24b6 ISC...something to do with calc                                                                                  ║
║                            Tables and function data                                                                           ║
║   24b8 @24b8 LOAD - Adjust fueling [RPM x Flow]                                                                               ║
║   2531 @2531 Enrich if cold [RPM and ECT]                                                                                     ║
║   2579 @2579 Ignition advance cold, used after startup conditions                                                             ║
║   25f2 @25f2 Ign Advance Hot (interpolated with either 2579 or 25f2)                                                          ║
║   266b @266b Extra ign advance if cold, by flow and temp                                                                      ║
║   269b @269b Ign Advance for cold startup.                                                                                    ║
║   2714 @2714                                                                                                                  ║
║   2754 @2754 Cranking_Fuel -> crank time X temp                                                                               ║
║   279c @279c Raw volts to TFR factor -> linear                                                                                ║
║   27b4 @27b4                                                                                                                  ║
║   27cc @27cc                                                                                                                  ║
║   27d8 @27d8 Accel pump by temp ?                                                                                             ║
║   27e4 @27e4 VAF Transfer for Cranking ?                                                                                      ║
║   2802 @2802 Multiplier for accel pump                                                                                        ║
║   2818 @2818 Coldstart strategy time reqd - indexed by ECT startup value                                                      ║
║   2838 @2838 ECT Scale for lookups ans 0-11                                                                                   ║
║   2858 @2858 RPM scale for loopkups ans 0-10 (not linear)                                                                     ║
║   2874 @2874 (Mass) Flow Scale 0-10                                                                                           ║
║   2884 @2884 ECT scale 0-7                                                                                                    ║
║   28a0 @28a0 (Mass) Flow scale 0-5                                                                                            ║
║   28b0 @28b0 Interpolate factors by temp, for ign hot and cold tables                                                         ║
║   28c0 @28c0 Vss raw to factor (for slope)                                                                                    ║
║   28cc @28cc VAF raw to volume flow (scaled Litres/min ?)                                                                     ║
║   2918 @2918 ECT raw to degrees C                                                                                             ║
║   296c @296c ACT raw to degrees C                                                                                             ║
║   29c0 @29c0 Air density from pressure and temp -> mass flow calc                                                             ║
║   29e8 @29e8 Reqd idle speed by block temp ?                                                                                  ║
║   29fc @29fc                                                                                                                  ║
║   2a24 @2a24                                                                                                                  ║
║   2a3c @2a3c Slope for ISC, a large solenoid ? looks suitably geometric                                                       ║
║   2a64 @2a64                                                                                                                  ║
║   2a7c @2a7c                                                                                                                  ║
║   2a94 @2a94                                                                                                                  ║
║   2a9e @2a9e                                                                                                                  ║
║   2aa8 @2aa8                                                                                                                  ║
║   2abc @2abc                                                                                                                  ║
║   2ad0 @2ad0 Timer scale 0-15 secs for cranking                                                                               ║
║   2adc @2adc BAP frequency to pressure (inches Hg * 8)                                                                        ║
║   2af0 @2af0 Crank inject multiplier by RPM ?                                                                                 ║
║   2b04 @2b04                                                                                                                  ║
║   30e5 @3e05 Definition of timers and their registers                                                                         ║
║   #                                                                                                                           ║
║   NB. first entry point does not conform to 'standard' ff,fa,21 of later binaries|#                                           ║
║                                                                                                                               ║
║                                                                                                                               ║
║                                                                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                      ║
║                                                        Bank 8                                                        ║
║                                                                                                                      ║
║                      00000   01fff                                                  2000    3fff                     ║
║                                                                                                                      ║
╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝


Bnk8Start - Bank 8 Start:
8 2000: e7,1d,00             jump  2020               goto Sub0002;        


8 2003: ff                                            Unknown Operation/Structure


8 2004: ff,ff                                         fill

8 2006: ff,ff                ffff  ROMSIZE            Bank Rom Size (ffff is not defined)

8 2008: ff,ff                                         fill

//  checksum adjust ?                                                                 //
8 200a: 41,84                8441  CHECKSUM           Checksum

//  end of Hardware ROM ?                                                             //
8 200c: 00,60                6000  SMPBASEADR         Smp Base Address

8 200e: 5d,00                  5d  CCEXETIME          Cc Exe Time

//  HSO Port Output 2 = cal console (external)                                        //
8 2010: 04,d0                d004  IPT_HSO_2          Interrupt High Speed Output 2
//  I/O Timer Overflow                                                                //
8 2012: a0,2c                2ca0  IPT_Timer_OVF      Interrupt Timer OVF
//  A/D End of Conversion                                                             //
8 2014: b2,2c                2cb2  IPT_HSI_0          Interrupt High Speed Input 0
//  HSI Port Input Data Available                                                     //
8 2016: b3,2c                2cb3  IPT_HSI_Data       Interrupt High Speed Input Data
//  External Interrupt Vector                                                         //
8 2018: b2,2c                2cb2  IPT_HSI_0          Interrupt High Speed Input 0
//  HSO Port Output  1                                                                //
8 201a: b0,2d                2db0  IPT_HSO_1          Interrupt High Speed Output 1
//  HSI 1 Interrupt Vector                                                            //
8 201c: b2,2c                2cb2  IPT_HSI_0          Interrupt High Speed Input 0
//  HSI 0 Interrupt Vector                                                            //
8 201e: b2,2c                2cb2  IPT_HSI_0          Interrupt High Speed Input 0


Sub0002:
//                                                                                    //
//  INITIALISE AND START UP                                                           //
//                                                                                    //
//  "ff,fa" standard start is here !                                                  //
8 2020: fa                   di                       disable ints;        
8 2021: ff                   ff                                            
8 2022: 01,16                clrw  R16                [codeflags] = 0;     
//  Initialise low speed Out                                                          //
8 2024: 11,02                clrb  R02                R02 = 0;             
8 2026: a3,01,50,20,30       ldw   R30,[2050]         R30 = [ROMStart];    
//  ROM checksum loop start and stop (2000-3fff)                                      //
8 202b: a3,01,5e,20,32       ldw   R32,[205e]         R32 = [ROMEnd];      
8 2030: 01,34                clrw  R34                R34 = 0;             

2032 - Sub 8 2032:
8 2032: 95,40,02             xrb   R02,40             R02 ^= 40;           
8 2035: ff                   ff                       2035 => 2036         
//  Watchdog Timer reset                                                              //
8 2037: 11,05                clrb  R05                WD_TIMER = 0;        
8 2039: 95,40,02             xrb   R02,40             R02 ^= 40;           
//  add each word                                                                     //
8 203c: 66,31,34             ad2w  R34,[R30++]        R34 += [R30++];      
8 203f: 88,32,30             cmpw  R30,R32                                 
8 2042: da,ee                jle   2032               if ((sig) R30 <= R32) goto 2032;
8 2044: 89,00,00,34          cmpw  R34,0                                   
//  if result not zero, then                                                          //
8 2048: df,04                je    204e               if (R34 == 0) goto 204e;
//  ROM Checksum fail                                                                 //
8 204a: 81,00,02,16          orrw  R16,200            [codeflags] |= 200;  
8 204e: 20,12                sjmp  2062               goto 2062;           



ROMStart:
8 2050: 20,00             ROMStart          oword      2000                8192      //  Checksum segments  //


//  but only [2050] and [205e] used                                                   //
8 2052: ff,27,00,28,ff,2f,00,30                       Unknown Operation/Structure
8 205a: ff,37,00,38                                   Unknown Operation/Structure



ROMEnd:
8 205e: 3f,ff             ROMEnd            oword      3fff               16383


8 2060: 00,00                                         Unknown Operation/Structure

8 2062: b1,ff,08             ldb   R08,ff             INT_MASK = ff;       
8 2065: b1,55,0c             ldb   R0c,55             HSI_MASK = 55;       

2068 - Sub 8 2068:
8 2068: a1,67,01,18          ldw   R18,167            [Fail_flags] = 167;  
//  two passes (55 and aa patterns)                                                   //
8 206c: 3f,08,03             jb    B7,R08,2072        if (B7_INT_MASK) goto 2072;
//  this for 2nd pass                                                                 //
8 206f: b1,aa,0c             ldb   R0c,aa             HSI_MASK = aa;       
8 2072: 05,18                decw  R18                [Fail_flags]--;      
8 2074: df,1a                je    2090               if (R34 == [Fail_flags]) goto 2090;
8 2076: 95,40,02             xrb   R02,40             R02 ^= 40;           
8 2079: ff                   ff                       2079 => 207a         
//  Watchdog Timer reset                                                              //
8 207b: 11,05                clrb  R05                WD_TIMER = 0;        
//  Flip CPU OK                                                                       //
8 207d: 95,40,02             xrb   R02,40             R02 ^= 40;           
8 2080: c7,18,19,0c          stb   [R18+19],R0c       [[Fail_flags]+19] = HSI_MASK;
8 2084: 9b,18,19,0c          cmpb  R0c,[R18+19]                            
8 2088: df,e8                je    2072               if (HSI_MASK == [[Fail_flags]+19]) goto 2072;
//  RAM test fail                                                                     //
8 208a: 81,00,01,16          orrw  R16,100            [codeflags] |= 100;  
8 208e: 20,08                sjmp  2098               goto 2098;           

8 2090: 17,08                incb  R08                INT_MASK++;          
//  reset for 2nd pass                                                                //
8 2092: df,d4                je    2068               if (R34 == INT_MASK) goto 2068;
8 2094: 61,ff,fe,16          an2w  R16,feff           [codeflags] &= feff; 

2098 - Sub 8 2098:
8 2098: 01,30                clrw  R30                R30 = 0;             
8 209a: c2,31,00             stw   [R30++],0          [R30++] = 0;         
8 209d: 89,16,00,30          cmpw  R30,16                                  
8 20a1: df,06                je    20a9               if (R30 == 16) goto 20a9;
8 20a3: 89,30,00,30          cmpw  R30,30                                  
8 20a7: d7,04                jne   20ad               if (R30 != 30) goto 20ad;
8 20a9: 65,02,00,30          ad2w  R30,2              R30 += 2;            
8 20ad: 89,00,02,30          cmpw  R30,200                                 
8 20b1: d7,e7                jne   209a               if (R30 != 200) goto 209a;
//  Intrs 1,3 5 only allowed                                                          //
8 20b3: b1,2a,08             ldb   R08,2a             INT_MASK = 2a;       
//  Set HSO interrupt #2  (cal console)                                               //
8 20b6: b1,0f,0d             ldb   R0d,f              HSO_CMD = f;         
//  in 4.8 * 178 = 0.854 mSecs                                                        //
8 20b9: a1,b2,00,0e          ldw   R0e,b2             HSO_TIME = b2;       
//  stack has 28 entries                                                              //
8 20bd: a1,1a,01,10          ldw   R10,11a            STACK = 11a;         
8 20c1: a1,32,00,98          ldw   R98,32             [SubTaskNum] = 32;   
//  set B2?, $ae:5, $ae:6                                                             //
8 20c5: b1,64,ae             ldb   Rae,64             [flags1] = 64;       
//  set max                                                                           //
8 20c8: a1,ff,ff,4e          ldw   R4e,ffff           [FuelClip_timer] = ffff;
8 20cc: a1,00,80,c8          ldw   Rc8,8000           [TPS_Min] = 8000;    
//  Max TPS vals                                                                      //
8 20d0: a1,00,80,ec          ldw   Rec,8000           [TPS_val] = 8000;    
//  Set $b4:6                                                                         //
8 20d4: b1,40,b4             ldb   Rb4,40             [OP_Reqd_flags] = 40;
8 20d7: b1,05,0c             ldb   R0c,5              HSI_MASK = 5;        
//  New second for timer (at next 1/8 sec)                                            //
8 20da: b1,08,2a             ldb   R2a,8              [8ths_sec] = 8;      
//  Set $1a:6, $1a:7                                                                  //
8 20dd: b1,c0,1a             ldb   R1a,c0             [IgnFlags] = c0;     
//  last keep_alive was NOW                                                           //
8 20e0: a0,06,56             ldw   R56,R06            [Last_KA_Time] = IO_TIMER;
8 20e3: 11,05                clrb  R05                WD_TIMER = 0;        
//  watchdog reset                                                                    //
8 20e5: 11,05                clrb  R05                WD_TIMER = 0;        
8 20e7: b1,0b,30             ldb   R30,b              R30 = b;             

20ea - Sub 8 20ea:
8 20ea: b0,0d,32             ldb   R32,R0d            R32 = HSI_DATA;      
8 20ed: ff                   ff                       20ed => 20ee         
8 20ef: 15,30                decb  R30                R30--;               
8 20f1: d7,f7                jne   20ea               if (R30 != R30) goto 20ea;
8 20f3: fb                   ei                       enable ints;         

main_loop:
//                                                                                    //
//     MAIN (BASE) CODE STARTS HERE                                                   //
//                                                                                    //
//  ALL tasks return here                                                             //
8 20f4: c9,f4,20             push  20f4               push(main_loop);     
8 20f7: 28,9e                scall 2197               Do_outputs();        
8 20f9: 99,01,5b             cmpb  R5b,1                                   
//  Do subtask list                                                                   //
8 20fc: d7,02                jne   2100               if ([MainTaskNum] != 1) goto 2100;
8 20fe: 20,69                sjmp  2169               goto Run_SubTasks;   

8 2100: 99,04,5b             cmpb  R5b,4                                   
8 2103: d1,03                jleu  2108               if ((uns) [MainTaskNum] <= 4) goto 2108;
8 2105: 91,02,b7             orrb  Rb7,2              [Rb7].Task_Fail = 1; 
8 2108: b1,02,5b             ldb   R5b,2              [MainTaskNum] = 2;   
8 210b: 39,b7,08             jb    B1,Rb7,2116        if ([Rb7].Task_Fail == 1) goto 2116;
8 210e: 89,00,00,98          cmpw  R98,0                                   
8 2112: d7,04                jne   2118               if ([SubTaskNum] != 0) goto Check_KA;
8 2114: 20,1c                sjmp  2132               goto Read_AD;        

2116 - Sub 8 2116:
8 2116: 27,08                sjmp  2020               goto Sub0002;        

Check_KA:
8 2118: 45,42,03,56,30       ad3w  R30,R56,342        R30 = [Last_KA_Time] + 342;
8 211d: 88,30,06             cmpw  R06,R30                                 
8 2120: de,04                jlt   2126               if ((sig) IO_TIMER < R30) goto 2126;
8 2122: d5,32                jnv   2156               if (!OV) goto Keep_Alive;
8 2124: 20,02                sjmp  2128               goto 2128;           

8 2126: dd,2e                jv    2156               if (OV) goto Keep_Alive;
8 2128: 3a,b7,46             jb    B2,Rb7,2171        if (B2_Rb7) goto Pump_Sto;
8 212b: 99,02,7a             cmpb  R7a,2                                   
8 212e: d1,39                jleu  2169               if ((uns) [TaskListCnt] <= 2) goto Run_SubTasks;
8 2130: 20,3f                sjmp  2171               goto Pump_Sto;       

Read_AD:
8 2132: b1,01,5b             ldb   R5b,1              [MainTaskNum] = 1;   
//  Read A/D Inputs 0-12                                                              //
8 2135: 11,bb                clrb  Rbb                Rbb = 0;             
//  Store in R7e - R96                                                                //
8 2137: a1,7e,00,30          ldw   R30,7e             R30 = 7e;            

213b - Sub 8 213b:
8 213b: b0,bb,04             ldb   R04,Rbb            AD_CMD = Rbb;        
8 213e: 33,0a,fd             jnb   B3,R0a,213e        if (!B3_HSO_OVF) goto 213e;
8 2141: c4,32,04             stb   R32,R04            R32 = AD_CMD;        
8 2144: c4,33,05             stb   R33,R05            R33 = WD_TIMER;      
//  clear channel etc, 10 bits A/D (5mV resolution)                                   //
8 2147: 61,c0,ff,32          an2w  R32,ffc0           R32 &= ffc0;         
//  A/D value stored                                                                  //
8 214b: c2,31,32             stw   [R30++],R32        [R30++] = R32;       
8 214e: 17,bb                incb  Rbb                Rbb++;               
8 2150: 99,0d,bb             cmpb  Rbb,d                                   
8 2153: de,e6                jlt   213b               if ((sig) Rbb < d) goto 213b;
8 2155: f0                   ret                      return;              

Keep_Alive:
//            Keep Alive                                                              //
//  Entered every 4 mS                                                                //
//  flip bit 6 of LS_PORT (CPU_OK) twice for a short pulse                            //
//  Reset watchdog                                                                    //
//                                                                                    //

Keep_Alive:
//  reset watchdog                                                                    //
8 2156: 17,05                incb  R05                WD_TIMER++;          
8 2158: fa                   di                       disable ints;        
8 2159: ff                   ff                                            
8 215a: 95,40,02             xrb   R02,40             R02 ^= 40;           
8 215d: ff                   ff                       215d => 215e         
//  reset watchdog (again)                                                            //
8 215f: 17,05                incb  R05                WD_TIMER++;          
//  flip CPU_OK (= LOS logic reset)                                                   //
8 2161: 95,40,02             xrb   R02,40             R02 ^= 40;           
8 2164: fb                   ei                       enable ints;         
8 2165: a0,06,56             ldw   R56,R06            [Last_KA_Time] = IO_TIMER;
8 2168: f0                   ret                      return;              

Run_SubTasks:
//              Do next task in (secondary) tasklist                                  //

Run_SubTasks:
8 2169: 11,5b                clrb  R5b                [MainTaskNum] = 0;   
8 216b: 17,7a                incb  R7a                [TaskListCnt]++;     
8 216d: e7,37,0a             jump  2ba7               goto Do_subTaskList; 

Sub0014:
8 2170: f0                   ret                      return;              

Pump_Sto:
//              Do PUMP, STO, etc                                                     //

Pump_Sto:
8 2171: b1,03,5b             ldb   R5b,3              [MainTaskNum] = 3;   
8 2174: 3a,5a,05             jb    B2,R5a,217c        if ([Svc_flags].PUMP_Reqd == 1) goto 217c;
8 2177: 71,7f,02             an2b  R02,7f             [R02].FPUMP_DRV = 0; 
8 217a: 20,03                sjmp  217f               goto 217f;           

8 217c: 91,80,02             orrb  R02,80             [R02].FPUMP_DRV = 1; 
8 217f: 71,ef,5a             an2b  R5a,ef             [Svc_flags].STI_Reqd = 0;
8 2182: 3b,0b,03             jb    B3,R0b,2188        if (B3_HSI_SAMP) goto 2188;
8 2185: 91,10,5a             orrb  R5a,10             [Svc_flags].STI_Reqd = 1;
8 2188: 71,df,b7             an2b  Rb7,df             [Rb7].Idle_Adjust = 0;
8 218b: 3d,0b,03             jb    B5,R0b,2191        if (B5_HSI_SAMP) goto 2191;
8 218e: 91,20,b7             orrb  Rb7,20             [Rb7].Idle_Adjust = 1;
8 2191: ef,f6,09             call  2b8a               STO_OUT();           
8 2194: 11,7a                clrb  R7a                [TaskListCnt] = 0;   
8 2196: f0                   ret                      return;              

Do_outputs:
//                                                                                    //
//     END of MAIN TASK LOOP                                                          //
//                                                                                    //
//                                                                                    //
//                                                                                    //
//              Do outputs                                                            //
8 2197: 32,b4,02             jnb   B2,Rb4,219c        if ([OP_Reqd_flags].SPARK_rqd == 0) goto 219c;
8 219a: 28,19                scall 21b5               Do_SPARK();          
8 219c: 30,b4,02             jnb   B0,Rb4,21a1        if ([OP_Reqd_flags].Inj_rqd_BK1 == 0) goto 21a1;
8 219f: 29,0e                scall 22af               Do_InjBank1();       
8 21a1: 31,b4,02             jnb   B1,Rb4,21a6        if ([OP_Reqd_flags].Inj_rqd_BK2 == 0) goto 21a6;
8 21a4: 29,61                scall 2307               Do_InjBank2();       
8 21a6: 36,b4,02             jnb   B6,Rb4,21ab        if ([OP_Reqd_flags].DOL_rqd == 0) goto 21ab;
8 21a9: 29,b4                scall 235f               Do_Trip_Dbl();       
8 21ab: 37,b4,03             jnb   B7,Rb4,21b1        if ([OP_Reqd_flags].ISC_rqd == 0) goto 21b1;
8 21ae: ef,0a,0a             call  2bbb               Do_ISC_OUT();        
8 21b1: ef,74,0a             call  2c28               Do_EGR_OUT();        
8 21b4: f0                   ret                      return;              

Do_SPARK:
//              Spark Out Routine                                                     //
//  Rev limit at 6600 rpm                                                             //
//  Spark cutoff at max RPM (so will not be smooth...)                                //
//  Ign_delta is +/- 5% max (elsewhere) to soothe change rate                         //
//  120 degrees appears scaled to 32768                                               //
//                                                                                    //
8 21b5: 8b,01,64,24,70       cmpw  R70,[2464]                              
8 21ba: d1,0a                jleu  21c6               if ((uns) [RPM] <= [Max_RPM]) goto 21c6;
8 21bc: a0,06,5e             ldw   R5e,R06            [Last_SPK_On] = IO_TIMER;
8 21bf: a0,06,60             ldw   R60,R06            [Last_SPK_Off] = IO_TIMER;
8 21c2: 11,1a                clrb  R1a                [IgnFlags] = 0;      
8 21c4: 20,e8                sjmp  22ae               goto 22ae;           

8 21c6: 3d,1a,05             jb    B5,R1a,21ce        if ([IgnFlags].Prev_underspd == 1) goto 21ce;
//  Both bits clear - ign advance in play                                             //
8 21c9: 3c,1a,02             jb    B4,R1a,21ce        if ([IgnFlags].Lock_Ign == 1) goto 21ce;
8 21cc: 20,3c                sjmp  220a               goto 220a;           

21ce - Sub 8 21ce:
8 21ce: 3b,1a,34             jb    B3,R1a,2205        if ([IgnFlags].Ign_Adv == 1) goto 2205;
//  set immediate 0/P                                                                 //
8 21d1: 11,b2                clrb  Rb2                [HSO_Flags] = 0;     
//  On or Off Reqd                                                                    //
8 21d3: 30,54,12             jnb   B0,R54,21e8        if (!B0_[Last_HSI]) goto 21e8;
8 21d6: b1,15,ba             ldb   Rba,15             Rba = 15;            
//  SPARK on - Now                                                                    //
8 21d9: 29,ba                scall 2395               Do_OUTPUT();         
8 21db: 30,b2,02             jnb   B0,Rb2,21e0        if ([HSO_Flags].HSO_BUSY == 0) goto 21e0;
8 21de: 20,10                sjmp  21f0               goto 21f0;           

8 21e0: 91,04,1a             orrb  R1a,4              [IgnFlags].SPK_state = 1;
8 21e3: a0,30,5e             ldw   R5e,R30            [Last_SPK_On] = R30; 
8 21e6: 20,13                sjmp  21fb               goto 21fb;           

8 21e8: b1,05,ba             ldb   Rba,5              Rba = 5;             
//  SPARK off - Now                                                                   //
8 21eb: 29,a8                scall 2395               Do_OUTPUT();         
8 21ed: 30,b2,05             jnb   B0,Rb2,21f5        if ([HSO_Flags].HSO_BUSY == 0) goto 21f5;

21f0 - Sub 8 21f0:
8 21f0: 91,10,b6             orrb  Rb6,10             [Rb6].Spark_Missed = 1;
8 21f3: 20,b9                sjmp  22ae               goto 22ae;           

8 21f5: 71,fb,1a             an2b  R1a,fb             [IgnFlags].SPK_state = 0;
8 21f8: a0,30,60             ldw   R60,R30            [Last_SPK_Off] = R30;
8 21fb: 35,1a,02             jnb   B5,R1a,2200        if ([IgnFlags].Prev_underspd == 0) goto 2200;
8 21fe: 20,ab                sjmp  22ab               goto ClearReqd;      

8 2200: 3c,1a,07             jb    B4,R1a,220a        if ([IgnFlags].Lock_Ign == 1) goto 220a;
8 2203: 20,a6                sjmp  22ab               goto ClearReqd;      

8 2205: 71,f7,1a             an2b  R1a,f7             [IgnFlags].Ign_Adv = 0;
8 2208: 20,a1                sjmp  22ab               goto ClearReqd;      

220a - Sub 8 220a:
8 220a: 91,08,1a             orrb  R1a,8              [IgnFlags].Ign_Adv = 1;
8 220d: 30,1a,02             jnb   B0,R1a,2212        if ([IgnFlags].SPK_off_pend == 0) goto 2212;
8 2210: 20,6c                sjmp  227e               goto 227e;           

8 2212: 39,1a,05             jb    B1,R1a,221a        if ([IgnFlags].SPK_on_pend == 1) goto 221a;
8 2215: 32,1a,02             jnb   B2,R1a,221a        if ([IgnFlags].SPK_state == 0) goto 221a;
//  do any pending (missed) events                                                    //
8 2218: 20,64                sjmp  227e               goto 227e;           

8 221a: a0,42,58             ldw   R58,R42            [Ign_Delay] = [Last_Ign_delay];
//  Set 'calc required'                                                               //
8 221d: 91,80,1b             orrb  R1b,80             [flagsw5].Base_ign_rqd = 1;
//                                                                                    //
//  Delay calc - scaled at 32768 = 120 degrees, and then +/- adjust                   //
//  flag indicates leading or trailing PIP edge (60 or 120 deg).                      //
//  Calc is -                                                                         //
//  from PIP LOW - delta(delay+120 deg) * 60 degrees (in timer ticks)                 //
//  from PIP HIGH - delay * 120 degrees (in timer ticks). For < 1000 rpm              //
//  Spark is ALWAYS calculated for NEXT spark                                         //
//                                                                                    //
//                                                                                    //
8 2220: 3d,a9,2a             jb    B5,Ra9,224d        if ([IgnFlags2].PIP_State == 1) goto 224d;
//        PIP Low (trailing edge) processing                                          //
//                                                                                    //
8 2223: 31,a9,03             jnb   B1,Ra9,2229        if ([IgnFlags2].PIP_Lead_Calc == 0) goto 2229;
//  recalc for 60 degree multiplier(delay*2)                                          //
8 2226: ef,1c,0d             call  2f45               Ign_Delay_Calc();    
8 2229: 91,04,a9             orrb  Ra9,4              [IgnFlags2].PIP_Trail_Calc = 1;
8 222c: 4c,58,f0,30          ml3w  R30,Rf0,R58        R30 = [Ign_Delta] * [Ign_Delay];
//  R32 = delay*delta/32768, = delta(delay)                                           //
8 2230: 0d,01,30             shldw R30,1              R30L = R30L * 2;     
8 2233: 49,00,80,f0,30       sb3w  R30,Rf0,8000       R30 = [Ign_Delta] - 8000;
//  R30 = -32768-delta (sign preserved ?)                                             //
8 2238: 03,30                negw  R30                R30 = -R30;          
//  R34 = delta(delay)+delta(120)                                                     //
8 223a: 48,30,32,34          sb3w  R34,R32,R30        R34 = R32 - R30;     
8 223e: 6c,1e,34             ml2w  R34,R1e            R34 *= [PIP_High_PW];
//  times 60 degrees in ticks ?                                                       //
8 2241: 0d,01,34             shldw R34,1              R34L = R34L * 2;     
//  = delta(delay+120)* $1e; (scaled)                                                 //
8 2244: a0,36,34             ldw   R34,R36            R34 = R36;           
//  SPOUT On at LAST_PIP_Low + delta(delay+120)*PIP_Hi_PW                             //
8 2247: a1,ee,00,3c          ldw   R3c,ee             R3c = ee;            
8 224b: 20,17                sjmp  2264               goto 2264;           

224d - Sub 8 224d:
8 224d: 39,a9,03             jb    B1,Ra9,2253        if ([IgnFlags2].PIP_Lead_Calc == 1) goto 2253;
//  recalc for 120 degree multiplier                                                  //
8 2250: ef,f2,0c             call  2f45               Ign_Delay_Calc();    
8 2253: 71,fb,a9             an2b  Ra9,fb             [IgnFlags2].PIP_Trail_Calc = 0;
//  delay * 120 degrees in ticks ?                                                    //
8 2256: 4c,44,58,30          ml3w  R30,R58,R44        R30 = [Ign_Delay] * [PIP_Intrvl];
8 225a: 0d,01,30             shldw R30,1              R30L = R30L * 2;     
//  R34 = delay*pip_Hi_intvl (scaled)                                                 //
8 225d: a0,32,34             ldw   R34,R32            R34 = R32;           
//  SPOUT On at LAST_PIP_HIGH + delay*PIP_Hi_Intvl                                    //
8 2260: a1,40,00,3c          ldw   R3c,40             R3c = 40;            

2264 - Sub 8 2264:
8 2264: b1,15,ba             ldb   Rba,15             Rba = 15;            
//  single event at R34+[R3c]                                                         //
8 2267: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
//  do output as set above                                                            //
8 226a: ef,28,01             call  2395               Do_OUTPUT();         
8 226d: 30,b2,05             jnb   B0,Rb2,2275        if ([HSO_Flags].HSO_BUSY == 0) goto 2275;
8 2270: 91,02,1a             orrb  R1a,2              [IgnFlags].SPK_on_pend = 1;
8 2273: 20,39                sjmp  22ae               goto 22ae;           

8 2275: a0,30,5e             ldw   R5e,R30            [Last_SPK_On] = R30; 
8 2278: 71,fd,1a             an2b  R1a,fd             [IgnFlags].SPK_on_pend = 0;
8 227b: 91,04,1a             orrb  R1a,4              [IgnFlags].SPK_state = 1;
8 227e: a0,1e,34             ldw   R34,R1e            R34 = [PIP_High_PW]; 
8 2281: 89,30,01,34          cmpw  R34,130                                 
8 2285: d3,06                jnc   228d               if ((uns) R34 < 130) goto 228d;
8 2287: 89,b1,28,34          cmpw  R34,28b1                                
//  Fit 1.4mS <= PIP_High_PW <= 50mS                                                  //
8 228b: d1,04                jleu  2291               if ((uns) R34 <= 28b1) goto 2291;

228d - Sub 8 228d:
8 228d: a1,30,01,34          ldw   R34,130            R34 = 130;           

2291 - Sub 8 2291:
8 2291: a1,5e,00,3c          ldw   R3c,5e             R3c = 5e;            
8 2295: b1,05,ba             ldb   Rba,5              Rba = 5;             
//  SPOUT Off at $1e + $5e                                                            //
8 2298: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
//  with checked pulsewidth.                                                          //
8 229b: 28,f8                scall 2395               Do_OUTPUT();         
8 229d: 30,b2,05             jnb   B0,Rb2,22a5        if ([HSO_Flags].HSO_BUSY == 0) goto 22a5;
8 22a0: 91,01,1a             orrb  R1a,1              [IgnFlags].SPK_off_pend = 1;
8 22a3: 20,09                sjmp  22ae               goto 22ae;           

8 22a5: 71,fa,1a             an2b  R1a,fa             [IgnFlags] &= fa;    
8 22a8: a0,30,60             ldw   R60,R30            [Last_SPK_Off] = R30;

ClearReqd:
8 22ab: 71,fb,b4             an2b  Rb4,fb             [OP_Reqd_flags].SPARK_rqd = 0;
8 22ae: f0                   ret                      return;              

Do_InjBank1:
//                                                                                    //
//  Injection Bank 1 Output.                                                          //
//  schedules on and off events for Injectors                                         //
//                                                                                    //
//  delayed On - do now                                                               //
8 22af: 3e,b6,19             jb    B6,Rb6,22cb        if ([Rb6].On_pend_BK1 == 1) goto B1_on;
//  delayed Off - retry                                                               //
8 22b2: 3a,b6,2b             jb    B2,Rb6,22e0        if ([Rb6].Off_pend_BK1 == 1) goto B1_off;
8 22b5: 31,2c,05             jnb   B1,R2c,22bd        if ([RPM_flags].No_Fuel == 0) goto 22bd;
//  Nothing to do                                                                     //
8 22b8: a0,06,c4             ldw   Rc4,R06            [TimeOff_BK1] = IO_TIMER;
8 22bb: 20,43                sjmp  2300               goto 2300;           

8 22bd: 48,c4,06,30          sb3w  R30,R06,Rc4        R30 = IO_TIMER - [TimeOff_BK1];
8 22c1: d5,04                jnv   22c7               if (!OV) goto 22c7;  
8 22c3: de,06                jlt   22cb               if ((sig) R30 < 0) goto B1_on;
8 22c5: 20,3f                sjmp  2306               goto 2306;           

8 22c7: d6,02                jge   22cb               if ((sig) R30 >= 0) goto B1_on;
8 22c9: 20,3b                sjmp  2306               goto 2306;           

B1_on:
8 22cb: 11,b2                clrb  Rb2                [HSO_Flags] = 0;     
//  Inj On - Now                                                                      //
8 22cd: b1,16,ba             ldb   Rba,16             Rba = 16;            
8 22d0: 28,c3                scall 2395               Do_OUTPUT();         
8 22d2: 30,b2,05             jnb   B0,Rb2,22da        if ([HSO_Flags].HSO_BUSY == 0) goto 22da;
8 22d5: 91,40,b6             orrb  Rb6,40             [Rb6].On_pend_BK1 = 1;
8 22d8: 20,2c                sjmp  2306               goto 2306;           

22da - Sub 8 22da:
8 22da: a0,30,c2             ldw   Rc2,R30            [TimeOn_BK1] = R30;  
8 22dd: 71,bf,b6             an2b  Rb6,bf             [Rb6].On_pend_BK1 = 0;

B1_off:
8 22e0: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
8 22e3: b1,06,ba             ldb   Rba,6              Rba = 6;             
//  -> $c2                                                                            //
8 22e6: a1,c2,00,3c          ldw   R3c,c2             R3c = c2;            
8 22ea: a0,c6,34             ldw   R34,Rc6            R34 = [Length_BK1];  
//  Inj Bank 1 Off at $c2 + $c6                                                       //
8 22ed: 28,a6                scall 2395               Do_OUTPUT();         
8 22ef: 30,b2,05             jnb   B0,Rb2,22f7        if ([HSO_Flags].HSO_BUSY == 0) goto 22f7;
8 22f2: 91,04,b6             orrb  Rb6,4              [Rb6].Off_pend_BK1 = 1;
8 22f5: 20,0f                sjmp  2306               goto 2306;           

8 22f7: a0,30,c4             ldw   Rc4,R30            [TimeOff_BK1] = R30; 
8 22fa: a0,c6,32             ldw   R32,Rc6            R32 = [Length_BK1];  
8 22fd: ef,47,08             call  2b47               Inc_Injtime();       
8 2300: 71,fe,b4             an2b  Rb4,fe             [OP_Reqd_flags].Inj_rqd_BK1 = 0;
8 2303: 71,bb,b6             an2b  Rb6,bb             Rb6 &= bb;           
8 2306: f0                   ret                      return;              

Do_InjBank2:
//                                                                                    //
//  Injection Bank 2 Output.                                                          //
//  schedules on and off events for Injectors                                         //
//                                                                                    //
//  delayed On - do now                                                               //
8 2307: 38,49,19             jb    B0,R49,2323        if ([R49].On_pend_BK2 == 1) goto 2323;
//  delayed Off - retry                                                               //
8 230a: 3a,49,2b             jb    B2,R49,2338        if ([R49].Off_pend_BK2 == 1) goto 2338;
8 230d: 31,2c,05             jnb   B1,R2c,2315        if ([RPM_flags].No_Fuel == 0) goto 2315;
//  Nothing to do                                                                     //
8 2310: a0,06,d6             ldw   Rd6,R06            [TimeOff_BK2] = IO_TIMER;
8 2313: 20,43                sjmp  2358               goto Clearfexit;     

8 2315: 48,d6,06,30          sb3w  R30,R06,Rd6        R30 = IO_TIMER - [TimeOff_BK2];
8 2319: d5,04                jnv   231f               if (!OV) goto 231f;  
8 231b: de,06                jlt   2323               if ((sig) R30 < 0) goto 2323;
8 231d: 20,3f                sjmp  235e               goto 235e;           

8 231f: d6,02                jge   2323               if ((sig) R30 >= 0) goto 2323;
8 2321: 20,3b                sjmp  235e               goto 235e;           

8 2323: 11,b2                clrb  Rb2                [HSO_Flags] = 0;     
8 2325: b1,17,ba             ldb   Rba,17             Rba = 17;            
//  Inj On - Now                                                                      //
8 2328: 28,6b                scall 2395               Do_OUTPUT();         
8 232a: 30,b2,05             jnb   B0,Rb2,2332        if ([HSO_Flags].HSO_BUSY == 0) goto 2332;
8 232d: 91,01,49             orrb  R49,1              [R49].On_pend_BK2 = 1;
8 2330: 20,2c                sjmp  235e               goto 235e;           

2332 - Sub 8 2332:
8 2332: a0,30,d4             ldw   Rd4,R30            [TimeOn_BK2] = R30;  
8 2335: 71,fe,49             an2b  R49,fe             [R49].On_pend_BK2 = 0;
8 2338: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
8 233b: b1,07,ba             ldb   Rba,7              Rba = 7;             
//  -> $d4                                                                            //
8 233e: a1,d4,00,3c          ldw   R3c,d4             R3c = d4;            
8 2342: a0,d8,34             ldw   R34,Rd8            R34 = [Length_BK2];  
//  Inj Bank 2 Off at $d4 + $d8                                                       //
8 2345: 28,4e                scall 2395               Do_OUTPUT();         
8 2347: 30,b2,05             jnb   B0,Rb2,234f        if ([HSO_Flags].HSO_BUSY == 0) goto 234f;
8 234a: 91,04,49             orrb  R49,4              [R49].Off_pend_BK2 = 1;
8 234d: 20,0f                sjmp  235e               goto 235e;           

8 234f: a0,30,d6             ldw   Rd6,R30            [TimeOff_BK2] = R30; 
8 2352: a0,d8,32             ldw   R32,Rd8            R32 = [Length_BK2];  
8 2355: ef,ef,07             call  2b47               Inc_Injtime();       

Clearfexit:
8 2358: 71,fd,b4             an2b  Rb4,fd             [OP_Reqd_flags].Inj_rqd_BK2 = 0;
8 235b: 71,fa,49             an2b  R49,fa             R49 &= fa;           
8 235e: f0                   ret                      return;              

Do_Trip_Dbl:
//                                                                                       //
//  DOL - Output for trip computer - STO has separate routine (below)                    //
//  50% duty cycle at variable freq as ON and OFF are the same value                     //
//  for slow frequencies use version with single event (to save O/P slots ?)             //
//  otherwise use this func for double event. Swops over at approx. half scale (0x4000)  //
//                                                                                       //
8 235f: 3d,5a,05             jb    B5,R5a,2367        if ([Svc_flags].TRIP_Reqd == 1) goto 2367;
8 2362: a0,06,78             ldw   R78,R06            [TRIP_Time] = IO_TIMER;
8 2365: 20,2d                sjmp  2394               goto 2394;           

8 2367: 3a,b3,06             jb    B2,Rb3,2370        if ([State_flags].Trip_state == 1) goto 2370;
8 236a: 89,00,40,76          cmpw  R76,4000                                
8 236e: d3,03                jnc   2373               if ((uns) [TRIP_PW_Time] < 4000) goto 2373;

2370 - Sub 8 2370:
8 2370: e7,f4,07             jump  2b67               goto Do_Trip_Single; 

2373 - Sub 8 2373:
8 2373: a0,76,34             ldw   R34,R76            R34 = [TRIP_PW_Time];
8 2376: a0,76,36             ldw   R36,R76            R36 = [TRIP_PW_Time];
//  -> $78 (2nd event)                                                                //
8 2379: a1,78,00,3c          ldw   R3c,78             R3c = 78;            
8 237d: b1,80,b2             ldb   Rb2,80             [HSO_Flags] = 80;    
8 2380: b1,19,ba             ldb   Rba,19             Rba = 19;            
8 2383: b1,29,bb             ldb   Rbb,29             Rbb = 29;            
//  2 events.On, Off with interrupt                                                   //
8 2386: 28,0d                scall 2395               Do_OUTPUT();         
8 2388: 38,b2,09             jb    B0,Rb2,2394        if ([HSO_Flags].HSO_BUSY == 1) goto 2394;
8 238b: 71,bf,b4             an2b  Rb4,bf             [OP_Reqd_flags].DOL_rqd = 0;
8 238e: 71,fb,b3             an2b  Rb3,fb             [State_flags].Trip_state = 0;
//  Off event start time/On event end                                                 //
8 2391: a0,32,78             ldw   R78,R32            [TRIP_Time] = R32;   
8 2394: f0                   ret                      return;              

Do_OUTPUT:
//                                                                                    //
//  main output routine - 1 or 2 events supported.                                    //
//  calls low level output routine for each event reqd.                               //
//  Rb2 = flags (in and out)                                                          //
//  Rba = event 1 definition (channel + state)                                        //
//  Rbb = event 2 definition                                                          //
//  R34 = event 1 start time  (+[R3c] if B7 set)                                      //
//  R36 = event 2 start time  (as increment from actual event 1 time)                 //
//  R3c = pointer to additional delay (word)                                          //
//  Rb2 flags IN                                                                      //
//   B7 SET    Event 1 time = R34 + [R3c],  Event 2 time = R34 + [R3c] + R36          //
//   B6 SET    No event 2 if B7 set (=> extra delay R3c)                              //
//   B7 CLEAR  Event 1 NOW (immediate output)                                         //
//   B4 SET    Event 1 time = NOW, Event 2 time = NOW+R36                             //
//  ANSWERS                                                                           //
//   R30    = actual start time of event 1                                            //
//   R32    = actual start time of event 2                                            //
//   Rb2 B5   output delayed if clear (but not used elsewhere)                        //
//   Rb2 B0   output busy = event(s) missed                                           //
//                                                                                    //
8 2395: 71,fe,b2             an2b  Rb2,fe             [HSO_Flags].HSO_BUSY = 0;
8 2398: 38,0a,4c             jb    B0,R0a,23e7        if (B0_HSO_OVF) goto Busy_exit;
8 239b: 05,34                decw  R34                R34--;               
8 239d: 3f,b2,05             jb    B7,Rb2,23a5        if ([HSO_Flags].Option_1 == 1) goto 23a5;
8 23a0: a0,06,30             ldw   R30,R06            R30 = IO_TIMER;      
8 23a3: 20,07                sjmp  23ac               goto 23ac;           

8 23a5: 46,3c,34,30          ad3w  R30,R34,[R3c]      R30 = R34 + [R3c];   
8 23a9: 91,20,b2             orrb  Rb2,20             [HSO_Flags].HSO_ontime = 1;

23ac - Sub 8 23ac:
8 23ac: b0,ba,3e             ldb   R3e,Rba            R3e = Rba;           
//  Event 1 time reqd                                                                 //
8 23af: a0,30,b8             ldw   Rb8,R30            Rb8 = R30;           
//  Event interval from now (negated)                                                 //
8 23b2: 48,30,06,3a          sb3w  R3a,R06,R30        R3a = IO_TIMER - R30;
8 23b6: ef,63,07             call  2b1c               HSOUT();             
8 23b9: d3,06                jnc   23c1               if (CY == 0) goto 23c1;
8 23bb: 71,df,b2             an2b  Rb2,df             [HSO_Flags].HSO_ontime = 0;
//  output delayed, save true event time                                              //
8 23be: a0,b8,30             ldw   R30,Rb8            R30 = Rb8;           
8 23c1: 3f,b2,05             jb    B7,Rb2,23c9        if ([HSO_Flags].Option_1 == 1) goto 23c9;
8 23c4: 3c,b2,05             jb    B4,Rb2,23cc        if ([HSO_Flags].Option_3 == 1) goto 23cc;
8 23c7: 20,21                sjmp  23ea               goto 23ea;           

8 23c9: 3e,b2,1e             jb    B6,Rb2,23ea        if ([HSO_Flags].Option_2 == 1) goto 23ea;
8 23cc: 38,0a,18             jb    B0,R0a,23e7        if (B0_HSO_OVF) goto Busy_exit;
8 23cf: 44,30,36,32          ad3w  R32,R36,R30        R32 = R36 + R30;     
//  Event 2 state + chl                                                               //
8 23d3: b0,bb,3e             ldb   R3e,Rbb            R3e = Rbb;           
//  Event 2 time reqd                                                                 //
8 23d6: a0,32,b8             ldw   Rb8,R32            Rb8 = R32;           
//  Event interval from now (negated)                                                 //
8 23d9: 48,32,06,3a          sb3w  R3a,R06,R32        R3a = IO_TIMER - R32;
8 23dd: ef,3c,07             call  2b1c               HSOUT();             
8 23e0: d3,08                jnc   23ea               if (R3a < 0) goto 23ea;
//  Save actual event time                                                            //
8 23e2: a0,b8,32             ldw   R32,Rb8            R32 = Rb8;           
8 23e5: 20,03                sjmp  23ea               goto 23ea;           

Busy_exit:
8 23e7: 91,01,b2             orrb  Rb2,1              [HSO_Flags].HSO_BUSY = 1;
8 23ea: f0                   ret                      return;              


8 23eb -> 23ff                     fill               ff



VAF1_Scaler:
8 2400: 00,80             Rsi+0 VAF1_Scaler    word      8000               32768      //  Flow scaler for VAF    (= 1/2)  //

VAF1_Trim:
8 2402: 00,00             Rsi+2 VAF1_Trim     word         0                   0      //  trim scale 1  //

VAF1_Trimx:
8 2404: 00,00             Rsi+4 VAF1_Trimx    word         0                   0      //  trim scale 2  //

VAF2_Scaler:
8 2406: 00,80             Rsi+6 VAF2_Scaler    word      8000               32768      //  and same for second VAF  //

VAF2_Trim:
8 2408: 00,00             Rsi+8 VAF2_Trim     word         0                   0

VAF2_Trimx:
8 240a: 00,00             Rsi+a VAF2_Trimx    word         0                   0


BAP_Dflt:
8 240c: ef                Rsi+c BAP_Dflt      byte        ef                 239      //  239 = 29.875 inches Hg (1 std atmo)  //


8 240d: ff,e5,3d                              Unknown Calibration                            ff, e5, 3d                                 255, 229,  61



CnkSetRPM:
8 2410: 08,07             Rsi+10 CnkSetRPM    word       708                1800      //  450 rpm, cranking set (& underspeed)  //

UspClrRPM:
8 2412: 60,09             Rsi+12 UspClrRPM    word       960                2400      //  600 rpm, underspeed cleared  //

UspSetRPM:
8 2414: e4,07             Rsi+14 UspSetRPM    word       7e4                2020      //  505 rpm, underspeed set  //

RPM_1500:
8 2416: 70,17             Rsi+16 RPM_1500     word      1770                6000      //  1500 rpm, Min RPM for fuel cutoff, weaken fuel instead on TPS close  //

RPM_1800:
8 2418: 20,1c             Rsi+18 RPM_1800     word      1c20                7200      //  1800 rpm, Min RPM for fuel cutoff when cold start, AND knock risk above this.  //


C250deg:
8 241a: 7f                Rsi+1a C250deg      byte        7f                 127      //  ECT Start max  //

C-40deg:
8 241b: ec                Rsi+1b C-40deg      byte        ec                 236      //  ECT start min  //


Tmr_Lim_0:
8 241c: 00,00             Rsi+1c Tmr_Lim_0    word         0                   0      //  mSecs - Timer from engine start to force snip instead of cutoff ?  //

InjSize:
8 241e: 4e,62             Rsi+1e InjSize      word      624e               25166      //  167cc/min    25166 ticks = 0.25 gram fuel ?.  //

CylChMax:
8 2420: f0,16             Rsi+20 CylChMax     word      16f0                5872      //  Max (base) injection charge. (563 cc at 1.2058 g/L)  //

CylChKMin:
8 2422: 31,08             Rsi+22 CylChKMin    word       831                2097      //  Min (base) injection charge whilst knock risk flag set  //

TP_Accel_min:
8 2424: 00,05             Rsi+24 TP_Accel_min    word       500                1280      //  TPS delta to force accel pump recalc  //


EmgyEnrich:
8 2426: 53                Rsi+26 EmgyEnrich    byte        53                  83      //  Enrich 30% if underspeed (and cranking). Scale 64, 83/64 = 1.297.  //
                                                                                       //  Crank scale 32 => 2.594                                            //

KnckEnrich:
8 2427: 80                Rsi+27 KnckEnrich    byte        80                 128      //  Enrich if Knock Risk. scale 128 so this is 1:1 (no additional)  //

C80deg:
8 2428: 28                Rsi+28 C80deg       byte        28                  40      //  max temp to inhibit fuel cut off  //

RPM_CLC_0:
8 2429: 00                Rsi+29 RPM_CLC_0    byte         0                   0

Sensor_1:
8 242a: 01                Rsi+2a Sensor_1     byte         1                   1      //  used in sensor check...  //

sensorx_1:
8 242b: 01                Rsi+2b sensorx_1    byte         1                   1


DenseScaler:
8 242c: 60,3c             Rsi+2c DenseScaler    word      3c60               15456      //  Density scaler for Air Density table. = 1.206 at default values (1g air at STP)  //

IGN_TRIM_0:
8 242e: 00,00             Rsi+2e IGN_TRIM_0    word         0                   0

IGNKnckLow:
8 2430: 10,27             Rsi+30 IGNKnckLow    word      2710               10000      //  2500 rpm - add knock spark delay if above here  //


IGNRegMin:
8 2432: 00                Rsi+32 IGNRegMin    byte         0                   0

IGNRegMax:
8 2433: c8                Rsi+33 IGNRegMax    byte        c8                 200      //  Ignition register, max and min.  //

IgnScaler:
8 2434: 80                Rsi+34 IgnScaler    byte        80                 128      //  Ignition Scaler (128 is x1)  //

C36_deg:
8 2435: 12                Rsi+35 C36_deg      byte        12                  18

C-40_deg:
8 2436: ec                Rsi+36 C-40_deg     byte        ec                 236

C100_deg:
8 2437: 32                Rsi+37 C100_deg     byte        32                  50

C20_deg:
8 2438: 0a                Rsi+38 C20_deg      byte         a                  10      //  various temp triggers for cold start etc.  //


8 2439: ff                                    Unknown Calibration                                    ff                                           255



VAF_dflt:
8 243a: 80,57             Rsi+3a VAF_dflt     word      5780               22400      //  1.75v = 2800 L/min => 1000rpm ?  //
        Inc   VAF_Coarse_dflt:
        Inc   8 243b: 57      Rsi+3b VAF_Coarse_dflt    byte        57                  87

650_Secs:
8 243c: 8a,02             Rsi+3c 650_Secs     word       28a                 650      //  Secs - (~ 11 mins) IGN table swopover from cold start conditions  //


AccelPump_Time:
8 243e: 3f                Rsi+3e AccelPump_Time    byte        3f                  63

AccelP_min_Time:
8 243f: 1e                Rsi+3f AccelP_min_Time    byte        1e                  30


DOL_scaler:
8 2440: 4b,03             Rsi+40 DOL_scaler    word       34b                 843

Ign_flt_sc:
8 2442: 00,20             Rsi+42 Ign_flt_sc    word      2000                8192

1000RPM:
8 2444: a0,0f             Rsi+44 1000RPM      word       fa0                4000

50RPM:
8 2446: c8,00             Rsi+46 50RPM        word        c8                 200      //  Hysteresis for flag at value above (1k rpm)  //

0.065V:
8 2448: 40,03             Rsi+48 0.065V       word       340                 832

3.25V:
8 244a: 80,a2             Rsi+4a 3.25V        word      a280               41600      //                                                           //
                                                                                      //  B3 (Set)   Average the cyl mass calcs unless cranking    //
                                                                                      //  #(otherwise done separately per bank - for filtering ?)  //
                                                                                      //                                                           //
                                                                                      //  B4 (Clear) Allow Tmr9 flag [from NDS, affects idle/ISC]  //
                                                                                      //     (3 NDS flags total)                                   //


FLGS_B3_B0:
8 244c: 09                Rsi+4c FLGS_B3_B0    byte         9                   9      //  Flags (when set)                                            //
                                                                                       //  B0 (set)   but not used anywhere ?                          //
                                                                                       //                                                              //
                                                                                       //  B2 (clear) Force bank 2 = Bank 1 calculated injection time  //


8 244d: ff                                    Unknown Calibration                                    ff                                           255



RPM_VFilter:
8 244e: ff,ff             Rsi+4e RPM_VFilter    word      ffff               65535      //  Digital Filter for ISC rpm (100%, reverse delta ?)  //


UspISC_PW:
8 2450: 66                Rsi+50 UspISC_PW    byte        66                 102      //  Underspeed ISC - Top Byte = 26112 = 4.98mS (79.7%)  //

CrnKISC_PW:
8 2451: 80                Rsi+51 CrnKISC_PW    byte        80                 128      //  Cranking ISC Pulswidth - Top Byte = 32768 = 6.25mS (100%)  //

ISC_FixPW:
8 2452: 00                Rsi+52 ISC_FixPW    byte         0                   0      //  b0 - set fixed ISC pulsewidth of [2453]    //
                                                                                      //  b1 - allow 200rpm increase (STI ? COld ?)  //

ISC_FPW:
8 2453: 40                Rsi+53 ISC_FPW      byte        40                  64      //  Fixed ISC pulsewidth 50% , top byte = 16384 => 3.125mS (50%)  //


20mSec:
8 2454: 14,00             Rsi+54 20mSec       word        14                  20      //  mSecs ISC  //

RPM_1430:
8 2456: 58,16             Rsi+56 RPM_1430     word      1658                5720      //  1430 rpm, ISC something  //


EGR_Present:
8 2458: 00                Rsi+58 EGR_Present    byte         0                   0


8 2459: ff                                    Unknown Calibration                                    ff                                           255



EGR_PW1:
8 245a: 00,20             Rsi+5a EGR_PW1      word      2000                8192

EGR_LIM1:
8 245c: 9a,09             Rsi+5c EGR_LIM1     word       99a                2458

EGR_lim2:
8 245e: 66,36             Rsi+5e EGR_lim2     word      3666               13926

600mSec:
8 2460: 58,02             Rsi+60 600mSec      word       258                 600      //  mSecs. Timer for Fuel clip.  //


Snip_58:
8 2462: 3a                Rsi+62 Snip_58      byte        3a                  58


8 2463: ff                                    Unknown Calibration                                    ff                                           255



Max_RPM:
8 2464: 20,67             Rsi+64 Max_RPM      word      6720               26400      //  6600 rpm = rev limit (spark cutoff)  //

ISC_Freq:
8 2466: 16,05             Rsi+66 ISC_Freq     word       516                1302      //  ISC Base multiplier/freq (=> 6.25mS =>160Hz)  //

IGN_KnckDly:
8 2468: 00,00             Rsi+68 IGN_KnckDly    word         0                   0      //  additional spark delay if knock risk  //


Crank_1:
8 246a: 01                Rsi+6a Crank_1      byte         1                   1      //  Always force averaged cyl mass if set to zero  //


8 246b: ff                                    Unknown Calibration                                    ff                                           255



Stall_Ctime:
8 246c: e0,2e             Rsi+6c Stall_Ctime    word      2ee0               12000      //  Restart cranking lookup here (12 secs) => stall or fail to start  //


8 246e: f0,ff                                 Unknown Calibration                                f0, ff                                      240, 255



BAP_MAX:
8 2470: 00,af             Rsi+70 BAP_MAX      word      af00               44800      //  => 240- 350 ticks/sec => 120-175 Hz  //

BAP_MIN:
8 2472: 00,78             Rsi+72 BAP_MIN      word      7800               30720


0deg:
8 2474: 00                Rsi+74 0deg         byte         0                   0      //  0 degree retard  //

3deg:
8 2475: f4                Rsi+75 3deg         byte        f4                 244      //  3 deg retard  //

6deg:
8 2476: e8                Rsi+76 6deg         byte        e8                 232      //  6 deg retard  //

defdeg:
8 2477: e8                Rsi+77 defdeg       byte        e8                 232      //  safety default retard, but not used  //

EGR_chan:
8 2478: 00                Rsi+78 EGR_chan     byte         0                   0      //  set if EGR connected to chan 1 instead of chan 0  //


8 2479: ff                                    Unknown Calibration                                    ff                                           255



3_secs:
8 247a: 03,00             Rsi+7a 3_secs       word         3                   3      //  = Secs  //

ISC_Min:
8 247c: cd,0c             Rsi+7c ISC_Min      word       ccd                3277      //  10% Minimum opening for ISC  //

ISC_ACC_0:
8 247e: 00,00             Rsi+7e ISC_ACC_0    word         0                   0      //  added to ISC if ACC flag  //

ISC_NDS_4260:
8 2480: a4,10             Rsi+80 ISC_NDS_4260    word      10a4                4260      //  added to ISC if NDS 1 Flag (DRIVE - 6.5% extra ?)  //

ISC_2_secs:
8 2482: d0,07             Rsi+82 ISC_2_secs    word       7d0                2000      //  = mSecs  //

5V:
8 2484: 00,fa             Rsi+84 5V           word      fa00               64000      //  = 5.0 Volts  //

0.125V:
8 2486: 40,06             Rsi+86 0.125V       word       640                1600      //  = 0.125 Volts  //

4.6V:
8 2488: 00,e6             Rsi+88 4.6V         word      e600               58880      //  = 4.6 Volts  //

0.15V:
8 248a: 80,07             Rsi+8a 0.15V        word       780                1920      //  = 0.15 Volts  //

4.6V:
8 248c: 00,e6             Rsi+8c 4.6V         word      e600               58880      //  = 4.6 Volts  //

0.26V:
8 248e: 00,0d             Rsi+8e 0.26V        word       d00                3328      //  = 0.26 Volts  //

5V:
8 2490: 00,fa             Rsi+90 5V           word      fa00               64000      //  = 5.0 Volts  //

0.2V:
8 2492: 00,0a             Rsi+92 0.2V         word       a00                2560      //  = 0.2 Volts  //

IGN_12:
8 2494: 30,00             Rsi+94 IGN_12       word        30                  48      //  Base IGN 12 degrees (via ISC)  //

EGR_PW2:
8 2496: 33,33             Rsi+96 EGR_PW2      word      3333               13107

EGR_PW3:
8 2498: cd,0c             Rsi+98 EGR_PW3      word       ccd                3277


32_secs:
8 249a: 20                Rsi+9a 32_secs      byte        20                  32      //  = Secs  //
8 249b: 20                Rsi+9b Sc0090       byte        20                  32


1_sec_T9:
8 249c: e8,03             Rsi+9c 1_sec_T9     word       3e8                1000      //  = Secs  //

1_sec_T9x:
8 249e: e8,03             Rsi+9e 1_sec_T9x    word       3e8                1000      //  = Secs  //

InjScaler:
8 24a0: 00,40             Rsi+a0 InjScaler    word      4000               16384      //  Injection scaler for calc - is x1  //

InjTrimB2:
8 24a2: 0d,00             Rsi+a2 InjTrimB2    word         d                  13      //  Added Only to bank1 time. For Crankcase breather ?  //

InjMax:
8 24a4: 00,80             Rsi+a4 InjMax       word      8000               32768      //  Max inject value (32768 = 125mS = 0.25 gms fuel)  //

IdleAdjRPM:
8 24a6: 2c,01             Rsi+a6 IdleAdjRPM    word       12c                 300      //  Idle Adject = 75 rpm  //

DOL_Freq:
8 24a8: 90,65             Rsi+a8 DOL_Freq     word      6590               26000      //  Trip computer. Update period 1/8 sec in ticks (x8 in code = 1 sec)  //

NDS_Scaler:
8 24aa: 80,00             Rsi+aa NDS_Scaler    word        80                 128      //  Scale ISC if NDS (128 is x1)  //

IGN_NDS_0:
8 24ac: 00,00             Rsi+ac IGN_NDS_0    word         0                   0      //  Add ign if NDS  //

CrankHystRPM:
8 24ae: c8,00             Rsi+ae CrankHystRPM    word        c8                 200      //  = 50 rpm hysteresis (cranking)  //

3.845V:
8 24b0: 40,c0             Rsi+b0 3.845V       word      c040               49216      //  below 3.845v for 3 degree retard [2475] (0 [2474] if above)  //

1.92V:
8 24b2: 00,60             Rsi+b2 1.92V        word      6000               24576      //  below 1.92v    for 6 degree retard [2476]  //

0.0V:
8 24b4: 00,00             Rsi+b4 0.0V         word         0                   0      //  below 0v for DEFAULT [2477]  //

RPM_1200:
8 24b6: c0,12             Rsi+b6 RPM_1200     word      12c0                4800      //  = 1200 rpm  //



Load:
//                                                                                                      //
//  Load - Base Fuel Adjustment - Flow(down+) x RPM(across+) 11 x 11 (shown scaled, base = 0x80 = 1:1)  //
//                                                                                                      //
//                                                                                                      //
//  Flow & Temp enrichment [i.e. choke] Cyl Flow (down+) x ECT (across+) 12 X 6                         //
//  used as multiplier factor => 32 is base (default 10th col (=hot))                                   //
//                                                                                                      //
8 24b8: 8d,8d,8d,8d,80,80,7a,7a               Unknown Calibration        8d, 8d, 8d, 8d, 80, 80, 7a, 7a        141, 141, 141, 141, 128, 128, 122, 122
8 24c0: 7a,7a,7a,86,86,85,81,7f               Unknown Calibration        7a, 7a, 7a, 86, 86, 85, 81, 7f        122, 122, 122, 134, 134, 133, 129, 127
8 24c8: 84,89,8d,8d,8d,8d,86,86               Unknown Calibration        84, 89, 8d, 8d, 8d, 8d, 86, 86        132, 137, 141, 141, 141, 141, 134, 134
8 24d0: 82,80,7d,84,89,8e,92,93               Unknown Calibration        82, 80, 7d, 84, 89, 8e, 92, 93        130, 128, 125, 132, 137, 142, 146, 147
8 24d8: 93,86,88,84,84,84,86,88               Unknown Calibration        93, 86, 88, 84, 84, 84, 86, 88        147, 134, 136, 132, 132, 132, 134, 136
8 24e0: 8e,8e,8d,98,86,80,86,86               Unknown Calibration        8e, 8e, 8d, 98, 86, 80, 86, 86        142, 142, 141, 152, 134, 128, 134, 134
8 24e8: 86,85,86,8c,88,8e,93,8a               Unknown Calibration        86, 85, 86, 8c, 88, 8e, 93, 8a        134, 133, 134, 140, 136, 142, 147, 138
8 24f0: 8c,85,89,88,85,83,89,8a               Unknown Calibration        8c, 85, 89, 88, 85, 83, 89, 8a        140, 133, 137, 136, 133, 131, 137, 138
8 24f8: 93,92,8a,86,8c,84,7d,83               Unknown Calibration        93, 92, 8a, 86, 8c, 84, 7d, 83        147, 146, 138, 134, 140, 132, 125, 131
8 2500: 85,89,86,89,97,8a,7c,86               Unknown Calibration        85, 89, 86, 89, 97, 8a, 7c, 86        133, 137, 134, 137, 151, 138, 124, 134
8 2508: 84,88,83,88,86,8d,97,96               Unknown Calibration        84, 88, 83, 88, 86, 8d, 97, 96        132, 136, 131, 136, 134, 141, 151, 150
8 2510: 88,77,77,7a,73,7d,7b,8a               Unknown Calibration        88, 77, 77, 7a, 73, 7d, 7b, 8a        136, 119, 119, 122, 115, 125, 123, 138
8 2518: 8f,97,96,88,77,77,74,7d               Unknown Calibration        8f, 97, 96, 88, 77, 77, 74, 7d        143, 151, 150, 136, 119, 119, 116, 125
8 2520: 78,73,88,8f,97,96,88,77               Unknown Calibration        78, 73, 88, 8f, 97, 96, 88, 77        120, 115, 136, 143, 151, 150, 136, 119
8 2528: 77,7b,74,77,7d,88,8f,97               Unknown Calibration        77, 7b, 74, 77, 7d, 88, 8f, 97        119, 123, 116, 119, 125, 136, 143, 151
8 2530: 96                                    Unknown Calibration                                    96                                           150


Cold_Enrich:
8 2531: 43      struct     43


//                                                                                    //
//  Ignition Timing COLD - Flow (down+) x RPM (across+) 11 X 11                       //
//  Used with HOT table and interpolated via ACT                                      //
//  RPM Cols    700 1000 1300 1600 2000 2500 3000 3500 4000 5000 6000                 //
//                                                                                    //
8 2532: 3c,36,33,31,2e,2b,29,27               Unknown Calibration        3c, 36, 33, 31, 2e, 2b, 29, 27         60,  54,  51,  49,  46,  43,  41,  39
8 253a: 25,20,20,43,3b,35,32,2d               Unknown Calibration        25, 20, 20, 43, 3b, 35, 32, 2d         37,  32,  32,  67,  59,  53,  50,  45
8 2542: 2a,26,24,23,20,20,20,43               Unknown Calibration        2a, 26, 24, 23, 20, 20, 20, 43         42,  38,  36,  35,  32,  32,  32,  67
8 254a: 3b,35,32,2d,2a,26,24,23               Unknown Calibration        3b, 35, 32, 2d, 2a, 26, 24, 23         59,  53,  50,  45,  42,  38,  36,  35
8 2552: 20,20,20,43,3b,35,32,2d               Unknown Calibration        20, 20, 20, 43, 3b, 35, 32, 2d         32,  32,  32,  67,  59,  53,  50,  45
8 255a: 2a,26,24,23,20,20,20,43               Unknown Calibration        2a, 26, 24, 23, 20, 20, 20, 43         42,  38,  36,  35,  32,  32,  32,  67
8 2562: 3b,35,32,2d,2a,26,24,23               Unknown Calibration        3b, 35, 32, 2d, 2a, 26, 24, 23         59,  53,  50,  45,  42,  38,  36,  35
8 256a: 20,20,20,43,3b,35,32,2d               Unknown Calibration        20, 20, 20, 43, 3b, 35, 32, 2d         32,  32,  32,  67,  59,  53,  50,  45
8 2572: 2a,26,24,23,20,20,20                  Unknown Calibration            2a, 26, 24, 23, 20, 20, 20              42,  38,  36,  35,  32,  32,  32


Ign_Adv_Cold:
//                                                                                    //
//  Ignition Timing HOT - Flow (down+) x RPM (across+) 11 X 11                        //
//  Used with COLD table and interpolated via ACT lookup table                        //
//                                                                                    //
8 2579: 30,30,30,50,58,54,64,68,70,70,70       table       30, 30, 30, 50, 58, 54, 64, 68, 70, 70, 70         48,  48,  48,  80,  88,  84, 100, 104, 112, 112, 112        
8 2584: 30,42,58,58,80,a0,a8,ac,a0,a8,a8       table       30, 42, 58, 58, 80, a0, a8, ac, a0, a8, a8         48,  66,  88,  88, 128, 160, 168, 172, 160, 168, 168        
8 258f: 30,8a,8c,94,a4,ac,b4,b4,ac,a8,a8       table       30, 8a, 8c, 94, a4, ac, b4, b4, ac, a8, a8         48, 138, 140, 148, 164, 172, 180, 180, 172, 168, 168        
8 259a: 60,80,7c,88,90,98,a8,a4,a4,98,8c       table       60, 80, 7c, 88, 90, 98, a8, a4, a4, 98, 8c         96, 128, 124, 136, 144, 152, 168, 164, 164, 152, 140        
8 25a5: 48,70,74,84,88,90,a4,a4,a4,98,8c       table       48, 70, 74, 84, 88, 90, a4, a4, a4, 98, 8c         72, 112, 116, 132, 136, 144, 164, 164, 164, 152, 140        
8 25b0: 48,6c,68,70,84,8c,90,9c,a4,a0,8c       table       48, 6c, 68, 70, 84, 8c, 90, 9c, a4, a0, 8c         72, 108, 104, 112, 132, 140, 144, 156, 164, 160, 140        
8 25bb: 22,4c,5c,6c,78,8c,8c,94,a4,a0,90       table       22, 4c, 5c, 6c, 78, 8c, 8c, 94, a4, a0, 90         34,  76,  92, 108, 120, 140, 140, 148, 164, 160, 144        
8 25c6: 18,3c,5c,74,78,88,88,8c,98,98,90       table       18, 3c, 5c, 74, 78, 88, 88, 8c, 98, 98, 90         24,  60,  92, 116, 120, 136, 136, 140, 152, 152, 144        
8 25d1: 12,2e,4c,68,74,80,84,90,98,8c,90       table       12, 2e, 4c, 68, 74, 80, 84, 90, 98, 8c, 90         18,  46,  76, 104, 116, 128, 132, 144, 152, 140, 144        
8 25dc: 12,2c,48,54,68,78,7c,88,88,8c,90       table       12, 2c, 48, 54, 68, 78, 7c, 88, 88, 8c, 90         18,  44,  72,  84, 104, 120, 124, 136, 136, 140, 144        
8 25e7: 12,2c,48,54,64,74,78,88,88,8c,90       table       12, 2c, 48, 54, 64, 74, 78, 88, 88, 8c, 90         18,  44,  72,  84, 100, 116, 120, 136, 136, 140, 144        

Ign_Adv_Hot:
//                                                                                    //
//  Additional Ign advance if engine block cold - Flow (down+) x ECT (across+)        //
//                                                                                    //
8 25f2: 30,30,30,50,58,54,64,68,70,70,70       table       30, 30, 30, 50, 58, 54, 64, 68, 70, 70, 70         48,  48,  48,  80,  88,  84, 100, 104, 112, 112, 112        
8 25fd: 30,42,58,58,80,a0,a8,ac,a0,a8,a8       table       30, 42, 58, 58, 80, a0, a8, ac, a0, a8, a8         48,  66,  88,  88, 128, 160, 168, 172, 160, 168, 168        
8 2608: 30,8a,8c,94,a4,ac,b4,b4,ac,a8,a8       table       30, 8a, 8c, 94, a4, ac, b4, b4, ac, a8, a8         48, 138, 140, 148, 164, 172, 180, 180, 172, 168, 168        
8 2613: 60,80,7c,88,90,98,a8,a4,a4,98,8c       table       60, 80, 7c, 88, 90, 98, a8, a4, a4, 98, 8c         96, 128, 124, 136, 144, 152, 168, 164, 164, 152, 140        
8 261e: 48,70,74,84,88,90,a4,a4,a4,98,8c       table       48, 70, 74, 84, 88, 90, a4, a4, a4, 98, 8c         72, 112, 116, 132, 136, 144, 164, 164, 164, 152, 140        
8 2629: 40,64,60,68,7c,84,88,94,9c,98,84       table       40, 64, 60, 68, 7c, 84, 88, 94, 9c, 98, 84         64, 100,  96, 104, 124, 132, 136, 148, 156, 152, 132        
8 2634: 1a,44,54,64,70,84,84,8c,9c,98,88       table       1a, 44, 54, 64, 70, 84, 84, 8c, 9c, 98, 88         26,  68,  84, 100, 112, 132, 132, 140, 156, 152, 136        
8 263f: 0c,30,50,68,6c,7c,7c,80,8c,8c,84       table        c, 30, 50, 68, 6c, 7c, 7c, 80, 8c, 8c, 84         12,  48,  80, 104, 108, 124, 124, 128, 140, 140, 132        
8 264a: 06,22,40,5c,68,74,78,84,8c,80,84       table        6, 22, 40, 5c, 68, 74, 78, 84, 8c, 80, 84          6,  34,  64,  92, 104, 116, 120, 132, 140, 128, 132        
8 2655: 00,1c,38,44,58,68,6c,78,78,7c,80       table        0, 1c, 38, 44, 58, 68, 6c, 78, 78, 7c, 80          0,  28,  56,  68,  88, 104, 108, 120, 120, 124, 128        
8 2660: 00,1c,38,44,54,64,68,78,78,7c,80       table        0, 1c, 38, 44, 54, 64, 68, 78, 78, 7c, 80          0,  28,  56,  68,  84, 100, 104, 120, 120, 124, 128        

Ign_Adv_ECTFlow:
//                                                                                       //
//  Alternate (Safety ?) Cold Ign Timing    Flow (down+) x RPM (across+) 11 X 11         //
//  used for cold start conditions (ECT ACT) and with time limit.                        //
//  Still interpolated with HOT table, not quite same as std COLD table, but close.....  //
//                                                                                       //
8 266b: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
8 2673: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
8 267b: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
8 2683: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
8 268b: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
8 2693: 1c,1c,1c,1c,14,00,00,00       table       1c, 1c, 1c, 1c, 14,  0,  0,  0         28,  28,  28,  28,  20,   0,   0,   0        
        Inc   8 269b: Rsi+29b struct    Ign_Adv_ColdStart
8 269b: 30,30,30,50,58,54,64,68       table       30, 30, 30, 50, 58, 54, 64, 68         48,  48,  48,  80,  88,  84, 100, 104        
8 26a3: 70,70,70,30,30,44,48,70       table       70, 70, 70, 30, 30, 44, 48, 70        112, 112, 112,  48,  48,  68,  72, 112        
8 26ab: a0,a8,ac,a0,a8,a8,30,78       table       a0, a8, ac, a0, a8, a8, 30, 78        160, 168, 172, 160, 168, 168,  48, 120        
8 26b3: 78,84,88,ac,b4,b4,ac,a8       table       78, 84, 88, ac, b4, b4, ac, a8        120, 132, 136, 172, 180, 180, 172, 168        
8 26bb: a8,60,6c,68,78,78,98,a8       table       a8, 60, 6c, 68, 78, 78, 98, a8        168,  96, 108, 104, 120, 120, 152, 168        


//     EGR Dummy (referenced at 3f80 )                                                //
8 26c3: a4,a4,98,8c,48,50,64,74               Unknown Calibration        a4, a4, 98, 8c, 48, 50, 64, 74        164, 164, 152, 140,  72,  80, 100, 116
8 26cb: 78,90,a4,a4,a4,98,8c,48               Unknown Calibration        78, 90, a4, a4, a4, 98, 8c, 48        120, 144, 164, 164, 164, 152, 140,  72
8 26d3: 5c,68,64,70,8c,90,9c,a4               Unknown Calibration        5c, 68, 64, 70, 8c, 90, 9c, a4         92, 104, 100, 112, 140, 144, 156, 164
8 26db: a0,8c,22,32,5c,6c,68,8c               Unknown Calibration        a0, 8c, 22, 32, 5c, 6c, 68, 8c        160, 140,  34,  50,  92, 108, 104, 140
8 26e3: 8c,94,a4,a0,90,18,3c,5c               Unknown Calibration        8c, 94, a4, a0, 90, 18, 3c, 5c        140, 148, 164, 160, 144,  24,  60,  92
8 26eb: 74,78,88,88,8c,98,98,90               Unknown Calibration        74, 78, 88, 88, 8c, 98, 98, 90        116, 120, 136, 136, 140, 152, 152, 144
8 26f3: 12,2e,4c,68,74,80,84,90               Unknown Calibration        12, 2e, 4c, 68, 74, 80, 84, 90         18,  46,  76, 104, 116, 128, 132, 144
8 26fb: 98,8c,90,12,2c,48,54,68               Unknown Calibration        98, 8c, 90, 12, 2c, 48, 54, 68        152, 140, 144,  18,  44,  72,  84, 104
8 2703: 78,7c,88,88,8c,90,12,2c               Unknown Calibration        78, 7c, 88, 88, 8c, 90, 12, 2c        120, 124, 136, 136, 140, 144,  18,  44
8 270b: 48,54,64,74,78,90,88,8c               Unknown Calibration        48, 54, 64, 74, 78, 90, 88, 8c         72,  84, 100, 116, 120, 144, 136, 140
8 2713: 90                                    Unknown Calibration                                    90                                           144


EGR_PW_Tab:
//                                                                                    //
//  Cranking Fuel -> Crank Time (down+) ECT (across+)    used as multiplier ##        //
//  Crank/Timer0 is a 15 sec timer    then multiplied by RPM lookup...                //
//                                                                                    //
8 2714: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 271c: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 2724: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 272c: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 2734: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 273c: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 2744: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        
8 274c: 20,20,20,20,20,20,20,20       table       20, 20, 20, 20, 20, 20, 20, 20         32,  32,  32,  32,  32,  32,  32,  32        

Cranking_Fuel:
//                                                                                              //
//  Injector Slope lookup. lookup via battery Voltage). O/P Value is added to inject time calc  //
//  scaled 0-32768 = 0-125ms.                                                                   //
//                                                                                              //
8 2754: 73,62,46,33,23,1b,14,12,10,0d,09,09       table       73, 62, 46, 33, 23, 1b, 14, 12, 10,  d,  9,  9        115,  98,  70,  51,  35,  27,  20,  18,  16,  13,   9,   9        
//  3 secs                                                                            //
8 2760: 73,62,3b,2b,1b,0f,0e,0c,0b,09,07,07       table       73, 62, 3b, 2b, 1b,  f,  e,  c,  b,  9,  7,  7        115,  98,  59,  43,  27,  15,  14,  12,  11,   9,   7,   7        
//  6 secs                                                                            //
8 276c: 04,62,3b,27,13,0f,0a,08,07,06,06,06       table        4, 62, 3b, 27, 13,  f,  a,  8,  7,  6,  6,  6          4,  98,  59,  39,  19,  15,  10,   8,   7,   6,   6,   6        
//  9 secs                                                                            //
8 2778: 00,5c,35,21,11,0d,09,07,06,06,06,06       table        0, 5c, 35, 21, 11,  d,  9,  7,  6,  6,  6,  6          0,  92,  53,  33,  17,  13,   9,   7,   6,   6,   6,   6        
//  #12 secs                                                                          //
8 2784: 23,48,27,1b,10,0b,08,07,06,06,06,06       table       23, 48, 27, 1b, 10,  b,  8,  7,  6,  6,  6,  6         35,  72,  39,  27,  16,  11,   8,   7,   6,   6,   6,   6        
//  #15 secs or more                                                                  //
8 2790: 5c,33,27,14,0e,0a,08,07,06,06,06,06       table       5c, 33, 27, 14,  e,  a,  8,  7,  6,  6,  6,  6         92,  51,  39,  20,  14,  10,   8,   7,   6,   6,   6,   6        

Inj_slope:
//                                                                                    //
//      next two tables used with Timer2 - Accel Pump ?                               //
//  used if Timer2 < LU8 lookup                                                       //
//  LU7 as multiplier LU8 as divider/time frame (secs) - code ~ 3605                  //
//  could be fading enrich for 'n' secs ....                                          //
//  'Base' scale appears to be 16384 ... (128 x 128 ...)                              //
//                                                                                    //
8 279c: ff,ff,4f,00       func                ffff,       4f               65535,       79
//  0.3   mS                                                                          //
8 27a0: 00,88,4f,00       func                8800,       4f               34816,       79
//  0.858 mS                                                                          //
8 27a4: 00,68,e1,00       func                6800,       e1               26624,      225
//  1.65  mS                                                                          //
8 27a8: 00,50,b1,01       func                5000,      1b1               20480,      433
8 27ac: 00,38,ca,03       func                3800,      3ca               14336,      970
//  3.7   mS                                                                          //
8 27b0: 00,00,ca,03       func                   0,      3ca                   0,      970

ECT_Mult_temp:
//            ECT to timer                                                            //
//  Output Value is SECONDS used against Timer 2                                      //
//  some kind of enrichment applied if less than time below in secs (3605)            //
//                                                                                    //
8 27b4: 7f,0a             func                  7f,        a                 127,       10
//  60C Hot                                                                           //
8 27b6: 1e,0a             func                  1e,        a                  30,       10
8 27b8: 19,0d             func                  19,        d                  25,       13
8 27ba: 0a,10             func                   a,       10                  10,       16
//  0C                                                                                //
8 27bc: 00,1a             func                   0,       1a                   0,       26
8 27be: fb,22             func                  fb,       22                  -5,       34
//  -20C Cold                                                                         //
8 27c0: f6,30             func                  f6,       30                 -10,       48
8 27c2: 80,30             func                  80,       30                -128,       48
8 27c4: 80,30             func                  80,       30                -128,       48
8 27c6: 80,30             func                  80,       30                -128,       48
8 27c8: 80,30             func                  80,       30                -128,       48
8 27ca: 80,30             func                  80,       30                -128,       48

ECT_Time_temp:
//                                                                                    //
//  Accel pump lookup, ECT modifier                                                   //
//  IN ECT Value                                                                      //
//  OUT multiplier factor                                                             //
//  Linked to Accel pump multiplier (2802, below) for Accel Pump Calc                 //
//                                                                                    //
8 27cc: 7f,0a             func                  7f,        a                 127,       10
//  48C Hot                                                                           //
8 27ce: 18,0a             func                  18,        a                  24,       10
8 27d0: 0a,19             func                   a,       19                  10,       25
//  -20C Cold                                                                         //
8 27d2: f6,3c             func                  f6,       3c                 -10,       60
8 27d4: 80,3c             func                  80,       3c                -128,       60
8 27d6: 80,3c             func                  80,       3c                -128,       60

ECT_Accel_LU:
//                                                                                    //
//  Coarse VAF Transfer                                                               //
//  IN - Top byte of VAF Raw (VAF/256).                                               //
//  OUT - multiplier ? used with accel lookup below                                   //
//                                                                                    //
8 27d8: 7f,13             func                  7f,       13                 127,       19
//  76C Hot                                                                           //
8 27da: 26,13             func                  26,       13                  38,       19
8 27dc: 1e,25             func                  1e,       25                  30,       37
8 27de: 12,4d             func                  12,       4d                  18,       77
//  26C Cold                                                                          //
8 27e0: 0d,7f             func                   d,       7f                  13,      127
8 27e2: 80,7f             func                  80,       7f                -128,      127

VAF_Coarse_TFR:
//                                                                                    //
//  Accel pump multiplier [Fixed value ?]                                             //
//  IN - VAF coarse (Reversed though = 256 - R3c (code at 3850)                       //
//  OUT - FIXED at 131 ?                                                              //
//  then mulitplied by ECT (block temp) lookup (at 3867)                              //
//                                                                                    //
8 27e4: ff,05             func                  ff,        5                 255,        5
8 27e6: eb,05             func                  eb,        5                 235,        5
8 27e8: da,08             func                  da,        8                 218,        8
8 27ea: ab,15             func                  ab,       15                 171,       21
8 27ec: 9c,1b             func                  9c,       1b                 156,       27
8 27ee: 89,26             func                  89,       26                 137,       38
8 27f0: 74,34             func                  74,       34                 116,       52
8 27f2: 62,44             func                  62,       44                  98,       68
8 27f4: 50,59             func                  50,       59                  80,       89
8 27f6: 46,66             func                  46,       66                  70,      102
8 27f8: 3a,7a             func                  3a,       7a                  58,      122
8 27fa: 2b,9a             func                  2b,       9a                  43,      154
8 27fc: 1e,ba             func                  1e,       ba                  30,      186
8 27fe: 0d,ff             func                   d,       ff                  13,      255
8 2800: 00,ff             func                   0,       ff                   0,      255

Accel_LU:
8 2802: ff,83             func                  ff,       83                 255,      131
8 2804: 00,83             func                   0,       83                   0,      131
8 2806: 00,83             func                   0,       83                   0,      131
8 2808: 00,83             func                   0,       83                   0,      131
8 280a: 00,83             func                   0,       83                   0,      131


//  Separate Table ? Not used anywhere                                                //
8 280c: ff,20                                 Unknown Calibration                                ff, 20                                      255,  32

8 280e -> 2817                     fill               00


ECT_Coldstart_Time:
//       ECT (block temp) Scaler                                                      //
8 2818: ff,7f,00,00       func                7fff,        0               32767,        0
//  Hot, 0 mins >= 80C                                                                //
8 281c: 28,00,00,00       func                  28,        0                  40,        0
8 2820: 12,00,f0,00       func                  12,       f0                  18,      240
//  16C, 4 mins                                                                       //
8 2824: 08,00,f0,00       func                   8,       f0                   8,      240
//  <=10C, 8.3 mins                                                                   //
8 2828: 05,00,f4,01       func                   5,      1f4                   5,      500
8 282c: ec,ff,08,02       func                ffec,      208                 -20,      520
8 2830: 00,80,08,02       func                8000,      208              -32768,      520
//  Cold. 8.6 mins                                                                    //
8 2834: 00,80,08,02       func                8000,      208              -32768,      520

ECT_SCALE_11:
//        RPM scaler                                                                  //
8 2838: ff,7f,00,0b       func                7fff,      b00               32767,       11
8 283c: 00,4b,00,0b       func                4b00,      b00               19200,       11
//  default return is 10 (70 - 150C)                                                  //
8 2840: 00,23,00,0a       func                2300,      a00                8960,       10
8 2844: 00,1e,00,09       func                1e00,      900                7680,        9
8 2848: 80,16,00,08       func                1680,      800                5760,        8
8 284c: 80,ee,00,00       func                ee80,        0               -4480,        0
8 2850: 00,80,00,00       func                8000,        0              -32768,        0
//  Cold                                                                              //
8 2854: 00,80,00,00       func                8000,        0              -32768,        0

RPM_SCALE_10:
//        Flow scaler (cylinder)                                                      //
//  Linear scale over small number range.  Is this full range of flow ?.              //
8 2858: ff,ff,00,0a       func                ffff,      a00               65535,       10
//  8=4000, 9=5000, 10=6000 & up                                                      //
8 285c: c0,5d,00,0a       func                5dc0,      a00               24000,       10
//  5=2500, 6=3000, 7=3500                                                            //
8 2860: 80,3e,00,08       func                3e80,      800               16000,        8
//  2=1300, 3=1600, 4=2000                                                            //
8 2864: 40,1f,00,04       func                1f40,      400                8000,        4
//  0=0-700, 1=1000,                                                                  //
8 2868: 00,19,00,03       func                1900,      300                6400,        3
8 286c: f0,0a,00,00       func                 af0,        0                2800,        0
8 2870: 00,00,00,00       func                   0,        0                   0,        0

FLOW_SCALE_10:
//                                                                                    //
8 2874: ff,ff,00,0a       func                ffff,      a00               65535,       10
8 2878: a1,14,00,0a       func                14a1,      a00                5281,       10
8 287c: c5,02,00,00       func                 2c5,        0                 709,        0
8 2880: 00,00,00,00       func                   0,        0                   0,        0

ECT_SCALE_7:
//       Flow Scaler 2                                                                //
//  Enrichment FLOW scaler used with 2531 when ECT cold => choke                      //
//  This is identical calibration to 2874 to half of scale then cuts off              //
8 2884: ff,7f,00,07       func                7fff,      700               32767,        7
//  default return is 7 (in 50)                                                       //
8 2888: 00,28,00,07       func                2800,      700               10240,        7
8 288c: 00,23,00,06       func                2300,      600                8960,        6
8 2890: 00,0a,00,05       func                 a00,      500                2560,        5
8 2894: 00,00,00,04       func                   0,      400                   0,        4
8 2898: 00,ec,00,00       func                ec00,        0               -5120,        0
//  Cold                                                                              //
8 289c: 00,80,00,00       func                8000,        0              -32768,        0

FLOW_SCALE_5:
//     ACT temp interpolate - for IGN HOT and COLD tables. in = ACT , OUT 0(hot) - 128 (cold)  //
8 28a0: ff,ff,00,05       func                ffff,      500               65535,        5
8 28a4: b3,0b,00,05       func                 bb3,      500                2995,        5
8 28a8: c5,02,00,00       func                 2c5,        0                 709,        0
8 28ac: 00,00,00,00       func                   0,        0                   0,        0

Ign_Interp:
8 28b0: ff,7f,00,00       func                7fff,        0               32767,        0
8 28b4: 17,00,00,00       func                  17,        0                  23,        0
//  full swopover between 26C and 46C                                                 //
8 28b8: 0d,00,80,00       func                   d,       80                  13,      128
//  Cold                                                                              //
8 28bc: 00,80,80,00       func                8000,       80              -32768,      128

Vss_TFR:
//                                                                                    //
//  VAF Transfer.  Input scaled to Volts.                                             //
//  Output may be scaled at 32768 = 2800L/min ?                                       //
8 28c0: ff,ff,00,c8       func                ffff,     c800               65535,    51200
8 28c4: 00,ed,00,c8       func                ed00,     c800               60672,    51200
8 28c8: 00,00,00,00       func                   0,        0                   0,        0

VAF_TFR:
//                                                                                    //
//  ECT Transfer - Upper byte used for scale funcs and table lookup                   //
//  input scaled to volts, output to degrees C                                        //
//                                                                                    //
8 28cc: ff,ff,63,5a       func                ffff,     5a63               65535,    23139
8 28d0: 00,eb,63,5a       func                eb00,     5a63               60160,    23139
8 28d4: 00,ea,b1,53       func                ea00,     53b1               59904,    21425
8 28d8: 40,e4,ba,44       func                e440,     44ba               58432,    17594
8 28dc: 80,d9,45,39       func                d980,     3945               55680,    14661
8 28e0: c0,c4,17,28       func                c4c0,     2817               50368,    10263
8 28e4: 00,b1,a3,1c       func                b100,     1ca3               45312,     7331
8 28e8: 40,9c,0c,14       func                9c40,     140c               40000,     5132
8 28ec: 80,88,52,0e       func                8880,      e52               34944,     3666
8 28f0: 80,7b,74,0b       func                7b80,      b74               31616,     2932
8 28f4: c0,6a,97,08       func                6ac0,      897               27328,     2199
8 28f8: c0,58,4d,06       func                58c0,      64d               22720,     1613
8 28fc: 40,46,94,04       func                4640,      494               17984,     1172
8 2900: 00,3a,b8,03       func                3a00,      3b8               14848,      952
8 2904: c0,2a,dd,02       func                2ac0,      2dd               10944,      733
8 2908: c0,1d,4a,02       func                1dc0,      24a                7616,      586
8 290c: c0,0c,b8,01       func                 cc0,      1b8                3264,      440
8 2910: 00,00,00,00       func                   0,        0                   0,        0
8 2914: 00,00,00,00       func                   0,        0                   0,        0

ECT_TFR:
//                                                                                    //
//  ACT (VAT) Transfer - Upper byte used for later scale and table lookup             //
//  Input scaled to volts, output to degrees C                                        //
//                                                                                    //
8 2918: ff,7f,00,ec       func                7fff,     ec00               32767,    -5120
8 291c: e0,73,00,ec       func                73e0,     ec00               29664,    -5120
8 2920: e0,71,00,f1       func                71e0,     f100               29152,    -3840
8 2924: c0,6e,00,f6       func                6ec0,     f600               28352,    -2560
8 2928: e0,69,00,fb       func                69e0,     fb00               27104,    -1280
8 292c: 00,63,00,00       func                6300,        0               25344,        0
8 2930: 00,5a,00,05       func                5a00,      500               23040,     1280
8 2934: 00,4f,00,0a       func                4f00,      a00               20224,     2560
8 2938: 20,43,00,0f       func                4320,      f00               17184,     3840
8 293c: 20,37,00,14       func                3720,     1400               14112,     5120
8 2940: 00,2c,00,19       func                2c00,     1900               11264,     6400
8 2944: 60,22,00,1e       func                2260,     1e00                8800,     7680
8 2948: 80,1a,00,23       func                1a80,     2300                6784,     8960
8 294c: 40,14,00,28       func                1440,     2800                5184,    10240
8 2950: 80,0f,00,2d       func                 f80,     2d00                3968,    11520
//  ECT default value (std normal hot)                                                //
8 2954: e0,0b,00,32       func                 be0,     3200                3040,    12800
8 2958: 20,09,00,37       func                 920,     3700                2336,    14080
8 295c: 00,07,00,3c       func                 700,     3c00                1792,    15360
8 2960: 80,05,00,41       func                 580,     4100                1408,    16640
8 2964: 60,03,00,4b       func                 360,     4b00                 864,    19200
8 2968: 00,80,00,4b       func                8000,     4b00              -32768,    19200

ACT_TFR:
//                                                                                    //
//  Air Density compensation - applied after raw air density calculation              //
//  of Pressure/Temp.  Reduces high pressure multipliers and increases                //
//  low pressure from mid point (1.2).                                                //
//  This is probably a version of the flow/drag equation, i.e.                        //
//  force on flap proportional to velocity squared (=volume)*density                  //
//  May also include other VE scavenging aspects against density                      //
//                                                                                    //
8 296c: ff,7f,00,ec       func                7fff,     ec00               32767,    -5120
8 2970: 30,73,00,ec       func                7330,     ec00               29488,    -5120
8 2974: d3,70,00,f1       func                70d3,     f100               28883,    -3840
8 2978: 3d,6d,00,f6       func                6d3d,     f600               27965,    -2560
8 297c: 1d,68,00,fb       func                681d,     fb00               26653,    -1280
8 2980: 33,61,00,00       func                6133,        0               24883,        0
8 2984: 86,58,00,05       func                5886,      500               22662,     1280
//  ACT default value (std temp 20C)                                                  //
8 2988: 80,4e,00,0a       func                4e80,      a00               20096,     2560
8 298c: c3,43,00,0f       func                43c3,      f00               17347,     3840
8 2990: 0a,39,00,14       func                390a,     1400               14602,     5120
8 2994: ea,2e,00,19       func                2eea,     1900               12010,     6400
8 2998: 03,26,00,1e       func                2603,     1e00                9731,     7680
8 299c: 7d,1e,00,23       func                1e7d,     2300                7805,     8960
8 29a0: 43,18,00,28       func                1843,     2800                6211,    10240
8 29a4: 4d,13,00,2d       func                134d,     2d00                4941,    11520
8 29a8: 46,0f,00,32       func                 f46,     3200                3910,    12800
8 29ac: d6,0b,00,37       func                 bd6,     3700                3030,    14080
8 29b0: c3,09,00,3c       func                 9c3,     3c00                2499,    15360
8 29b4: d6,07,00,41       func                 7d6,     4100                2006,    16640
//  very HOT !!                                                                       //
8 29b8: 00,00,00,7f       func                   0,     7f00                   0,    32512
8 29bc: 00,80,00,7f       func                8000,     7f00              -32768,    32512

Air_Density:
//                                                                                    //
//  idle speed versus ECT - added into calculation                                    //
//                                                                                    //
8 29c0: ff,ff,fd,ff       func                ffff,     fffd               65535,    65533
8 29c4: ad,af,11,d4       func                afad,     d411               44973,    54289
8 29c8: 5c,8f,92,bf       func                8f5c,     bf92               36700,    49042
//  default = 1.2                                                                     //
8 29cc: 66,66,e8,a1       func                6666,     a1e8               26214,    41448
8 29d0: 33,33,7c,72       func                3333,     727c               13107,    29308
8 29d4: 7b,14,69,48       func                147b,     4869                5243,    18537
8 29d8: 3d,0a,32,33       func                 a3d,     3332                2621,    13106
//  low density, increase sensor reading                                              //
8 29dc: 1f,05,6a,24       func                 51f,     246a                1311,     9322
8 29e0: 06,01,3c,12       func                 106,     123c                 262,     4668
8 29e4: 00,00,00,00       func                   0,        0                   0,        0

IDLE_ECT:
//                                                                                    //
//      Pulsewidth adjustment for ISC Valve - used as multiplier in code              //
//  appears to be +/- 25rpm resolution , 50 rpm deadband                              //
//  Scaled /65536 (2621 = 0.04, 1835 = 0.028, 52 = 0.008 )                            //
//                                                                                    //
8 29e8: ff,7f,48,0d       func                7fff,      d48               32767,     3400
8 29ec: 26,00,48,0d       func                  26,      d48                  38,     3400
//  1100 rpm                                                                          //
8 29f0: 00,00,30,11       func                   0,     1130                   0,     4400
8 29f4: ec,ff,50,14       func                ffec,     1450                 -20,     5200
//  1300 rpm - Cold -40C                                                              //
8 29f8: 00,80,50,14       func                8000,     1450              -32768,     5200

ISCxRPM:
//                                                                                                            //
//  with above ISC table - ECT in , multiplied with ISC table ...result scaled in 32 bits and then div 65536  //
//  for 0-65536 and rescaled via ISC_PW_TFR below. (after some adjustments)                                   //
//  effectively governs rate of change by RPMxECT, max 0.25%, min 0.1%                                        //
//  at 1638 multiply gives 52 => 1.3 (0.002%),    1835 => 45.86,    2621 => 65.5 (1%)                         //
//  at 4096 multiply gives 52 => 3.25 (0.005%), 1835 => 114.6875, 2621 => 163.8125 (2.5%)                     //
//                                                                                                            //
8 29fc: ff,7f,c3,f5       func                7fff,     f5c3               32767,    -2621
8 2a00: f0,0a,c3,f5       func                 af0,     f5c3                2800,    -2621
8 2a04: d0,07,d5,f8       func                 7d0,     f8d5                2000,    -1835
8 2a08: c8,00,cc,ff       func                  c8,     ffcc                 200,      -52
8 2a0c: 64,00,00,00       func                  64,        0                 100,        0
8 2a10: 9c,ff,00,00       func                ff9c,        0                -100,        0
8 2a14: 38,ff,34,00       func                ff38,       34                -200,       52
8 2a18: 30,f8,3d,0a       func                f830,      a3d               -2000,     2621
8 2a1c: 00,80,3d,0a       func                8000,      a3d              -32768,     2621
8 2a20: 00,80,3d,0a       func                8000,      a3d              -32768,     2621

ECT_LU2:
//                                                                                    //
//  ISC Pulsewidth Transfer                                                           //
//  may be solenoid lag/slope adjustment ? looks like quadratic curve.                //
//  OUTPUT scaled as 0-32768 = 0 - 6.25mS. Input 0-32767 ? 3277 min...                //
//                                                                                    //
8 2a24: ff,7f,00,10       func                7fff,     1000               32767,     4096
8 2a28: 26,00,00,10       func                  26,     1000                  38,     4096
//  Swops between 64 and 76 C                                                         //
8 2a2c: 20,00,66,06       func                  20,      666                  32,     1638
8 2a30: 00,80,66,06       func                8000,      666              -32768,     1638
8 2a34: 00,80,66,06       func                8000,      666              -32768,     1638
//  Cold                                                                              //
8 2a38: 00,80,66,06       func                8000,      666              -32768,     1638

ISC_Slope:
//                                                                                    //
//  ISC Pulsewidth lookup against Filtered RPM scaled 0-32768 = 6.25mS                //
//                                                                                    //
8 2a3c: ff,ff,00,80       func                ffff,     8000               65535,    32768
//  100% 6.25 mS  90% and up                                                          //
8 2a40: 33,73,00,80       func                7333,     8000               29491,    32768
//  83%  5.1875   80%                                                                 //
8 2a44: 66,66,3d,6a       func                6666,     6a3d               26214,    27197
//  68%  4.25     70%                                                                 //
8 2a48: 9a,59,0a,57       func                599a,     570a               22938,    22282
//  60%  3.875    60%                                                                 //
8 2a4c: cd,4c,5c,4f       func                4ccd,     4f5c               19661,    20316
//  55%  3.4375   50%                                                                 //
8 2a50: 00,40,66,46       func                4000,     4666               16384,    18022
//  49%  3.0625   40%                                                                 //
8 2a54: 33,33,b8,3e       func                3333,     3eb8               13107,    16056
//  42%  2.625    30%                                                                 //
8 2a58: 66,26,c3,35       func                2666,     35c3                9830,    13763
//  38%  2.375    20% (19% for 10% ?)                                                 //
8 2a5c: 9a,19,a4,30       func                199a,     30a4                6554,    12452
8 2a60: 00,00,00,00       func                   0,        0                   0,        0

ISC_RPM_2:
//  ISC Pulsewidth lookup against ECT - used directly if TPS fail                     //
8 2a64: ff,ff,33,33       func                ffff,     3333               65535,    13107
8 2a68: 58,16,33,33       func                1658,     3333                5720,    13107
//  33% = 2.0625mS                                                                    //
8 2a6c: 30,11,3d,2a       func                1130,     2a3d                4400,    10813
8 2a70: 00,00,3d,2a       func                   0,     2a3d                   0,    10813
8 2a74: 00,00,3d,2a       func                   0,     2a3d                   0,    10813
8 2a78: 00,00,3d,2a       func                   0,     2a3d                   0,    10813

ISC_Start_PW:
//  Lookups for EGR (not used here) against ECT and ACT (as multipliers to PW table)  //
//  and scalers below them (flow and RPM, both 0-7)                                   //
8 2a7c: ff,7f,29,1c       func                7fff,     1c29               32767,     7209
8 2a80: 28,00,29,1c       func                  28,     1c29                  40,     7209
//  25% (1.5625mS)                                                                    //
8 2a84: 1e,00,00,20       func                  1e,     2000                  30,     8192
//  60% (3.75mS)                                                                      //
8 2a88: f6,ff,cd,4c       func                fff6,     4ccd                 -10,    19661
8 2a8c: f1,ff,33,73       func                fff1,     7333                 -15,    29491
//  Cold (90% 5.625mS)                                                                //
8 2a90: 00,80,33,73       func                8000,     7333              -32768,    29491

EGR_ECT:
8 2a94: 7f,40             func                  7f,       40                 127,       64
8 2a96: 80,40             func                  80,       40                -128,       64
8 2a98: 80,40             func                  80,       40                -128,       64
8 2a9a: 80,40             func                  80,       40                -128,       64
8 2a9c: 80,40             func                  80,       40                -128,       64

EGR_ACT:
8 2a9e: 7f,40             func                  7f,       40                 127,       64
8 2aa0: 80,40             func                  80,       40                -128,       64
8 2aa2: 80,40             func                  80,       40                -128,       64
8 2aa4: 80,40             func                  80,       40                -128,       64
8 2aa6: 80,40             func                  80,       40                -128,       64

RPM_SCALE_7:
8 2aa8: ff,ff,00,07       func                ffff,      700               65535,        7
8 2aac: c0,5d,00,07       func                5dc0,      700               24000,        7
8 2ab0: f0,0a,00,00       func                 af0,        0                2800,        0
8 2ab4: 00,00,00,00       func                   0,        0                   0,        0
8 2ab8: 00,00,00,00       func                   0,        0                   0,        0

FLOW_SCALE_7:
//     Cranking Scaler (Timer 0).    Linear. mSecs IN. Cranking Time    Linear 0-15 secs for 0-5 scale  //
//     against Crank Fuel table (2754)                                                                  //
8 2abc: ff,ff,00,07       func                ffff,      700               65535,        7
8 2ac0: d7,12,00,07       func                12d7,      700                4823,        7
8 2ac4: 00,00,00,00       func                   0,        0                   0,        0
8 2ac8: 00,00,00,00       func                   0,        0                   0,        0
8 2acc: 00,00,00,00       func                   0,        0                   0,        0

SCALE_CrankTime:
//  BAP convertor to air pressure. Input range is 44800 - 30720 (175Hz - 120Hz)       //
//  Book indicates range 80-160 Hz for 0-1 atmo. 159 Hz => default = 239 (1 atmo)     //
//  looks like this is inches Hg * 8 (240 = 30 in Hg => 29.92, 239 = 29.875)          //
8 2ad0: ff,ff,00,05       func                ffff,      500               65535,        5
8 2ad4: 98,3a,00,05       func                3a98,      500               15000,        5
8 2ad8: 00,00,00,00       func                   0,        0                   0,        0

BAP_TFR:
//     RPM lookup for Cranking.    Used as multiplier of Crank fuel table             //
8 2adc: ff,ff,f8,00       func                ffff,       f8               65535,      248
//  162.7 Hz [1.033] (1.037 atmo 31 in Hg)                                            //
8 2ae0: 5a,a2,f8,00       func                a25a,       f8               41562,      248
//  138.3 Hz [0.766] (0.7 atmo = 23 in Hg)                                            //
8 2ae4: 46,8a,b8,00       func                8a46,       b8               35398,      184
//  116.8 Hz [0.5]   (0.5 atmo = 15 in Hg)                                            //
8 2ae8: cc,74,78,00       func                74cc,       78               29900,      120
8 2aec: 00,00,78,00       func                   0,       78                   0,      120

RPM_Crank_LU:
//  lookup against ECT if timer below threshold  RPM value subtracted from ISC calculation  //
//  effective change range -40 through 20C.                                                 //
8 2af0: ff,ff,50,00       func                ffff,       50               65535,       80
8 2af4: d0,07,50,00       func                 7d0,       50                2000,       80
8 2af8: 40,06,60,00       func                 640,       60                1600,       96
8 2afc: b0,04,80,00       func                 4b0,       80                1200,      128
8 2b00: 00,00,80,00       func                   0,       80                   0,      128

NDS_IDLE_CHANGE:
//                                                                                    //
//  Physical output routine - called only from HS_OUT routine                         //
//  Rb8  - time reqd                                                                  //
//  R3e  - Event state and channel                                                    //
//  R3a  - Event time reqd from now, NEGATED if time is left                          //
//  Auto delay to 200uS from now if less than 200uS left.                             //
//  set carry if delayed Output, cleared otherwise                                    //
//  Rb8 as return par, TRUE start time of event.                                      //
//                                                                                    //
8 2b04: ff,7f,20,03       func                7fff,      320               32767,      800
8 2b08: 0a,00,20,03       func                   a,      320                  10,      800
8 2b0c: ec,ff,40,06       func                ffec,      640                 -20,     1600
8 2b10: 00,80,40,06       func                8000,      640              -32768,     1600
8 2b14: 00,80,40,06       func                8000,      640              -32768,     1600
//  Cold                                                                              //
8 2b18: 00,80,40,06       func                8000,      640              -32768,     1600


HSOUT:
//  is really    if (R3a < 0)                                                         //
8 2b1c: de,04                jlt   2b22               if ((sig) R3a < 0) goto 2b22;
8 2b1e: dd,04                jv    2b24               if (OV) goto Out_Now;
8 2b20: 20,15                sjmp  2b37               goto Out_Dly;        

8 2b22: dd,13                jv    2b37               if (OV) goto Out_Dly;

Out_Now:
8 2b24: fa                   di                       disable ints;        
8 2b25: ff                   ff                                            
//  make positive value                                                               //
8 2b26: 03,3a                negw  R3a                R3a = -R3a;          
//  check at least 200uS to go                                                        //
8 2b28: 89,2a,00,3a          cmpw  R3a,2a                                  
//  OK - use orig time                                                                //
8 2b2c: d3,09                jnc   2b37               if ((uns) R3a < 2a) goto Out_Dly;
8 2b2e: a0,b8,0e             ldw   R0e,Rb8            HSO_TIME = Rb8;      
8 2b31: b0,3e,0d             ldb   R0d,R3e            HSO_CMD = R3e;       
8 2b34: f8                   clc                      CY = 0;              
8 2b35: 20,0e                sjmp  2b45               goto Exit;           

Out_Dly:
8 2b37: fa                   di                       disable ints;        
8 2b38: ff                   ff                                            
//  add 200 uS to event time                                                          //
8 2b39: 45,2a,00,06,b8       ad3w  Rb8,R06,2a         Rb8 = IO_TIMER + 2a; 
8 2b3e: a0,b8,0e             ldw   R0e,Rb8            HSO_TIME = Rb8;      
8 2b41: b0,3e,0d             ldb   R0d,R3e            HSO_CMD = R3e;       
8 2b44: f9                   stc                      CY = 1;              

Exit:
8 2b45: fb                   ei                       enable ints;         
8 2b46: f0                   ret                      return;              

Inc_Injtime:
//                                                                                                 //
//  Increment total Injection time for trip computer (shares STO output)                           //
//  input - R32 = ACTUAL Inject time - in 'ticks' (of 4.8 uS)                                      //
//  Called separately for each bank,                                                               //
//  15c (as double word) = Cumulative inject time in ticks for both banks since last trip Output.  //
//  This is recalculated in Trip_calc (3947).                                                      //
//                                                                                                 //
8 2b47: 4d,74,cb,50,38       ml3w  R38,R50,cb74       R38 = [Inj_slope] * cb74;
//  remove Inject Slope compensation                                                  //
8 2b4c: 68,3a,32             sb2w  R32,R3a            R32 -= R3a;          
8 2b4f: 67,01,5c,01,32       ad2w  R32,[15c]          R32 += [Tot_Inj_L];  
8 2b54: a3,01,5e,01,34       ldw   R34,[15e]          R34 = [Tot_Inj_H];   
//  is a 32 bit addition                                                              //
8 2b59: a4,00,34             adcw  R34,0              R34 += 0 + CY;       
8 2b5c: c3,01,5e,01,34       stw   [15e],R34          [Tot_Inj_H] = R34;   
//  save new inject time                                                              //
8 2b61: c3,01,5c,01,32       stw   [15c],R32          [Tot_Inj_L] = R32;   
8 2b66: f0                   ret                      return;              

Do_Trip_Single:
//                                                                                    //
//  TRIP Output - for trip computer - single event.                                   //
//  50% duty cycle as ON and OFF are the same value                                   //
//  for fast frequencies uses double event version at 235f                            //
//  swops over at approx. half scale (0x4000)                                         //
//                                                                                    //
//                                                                                    //
8 2b67: a0,76,34             ldw   R34,R76            R34 = [TRIP_PW_Time];
//  -> = $78                                                                          //
8 2b6a: a1,78,00,3c          ldw   R3c,78             R3c = 78;            
//  O/P time = $76+$78 - single event                                                 //
8 2b6e: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
8 2b71: b1,39,ba             ldb   Rba,39             Rba = 39;            
8 2b74: 32,b3,03             jnb   B2,Rb3,2b7a        if ([State_flags].Trip_state == 0) goto 2b7a;
//  set reqd TRIP state + interrupt                                                   //
8 2b77: b1,29,ba             ldb   Rba,29             Rba = 29;            
8 2b7a: ef,18,f8             call  2395               Do_OUTPUT();         
8 2b7d: 38,b2,09             jb    B0,Rb2,2b89        if ([HSO_Flags].HSO_BUSY == 1) goto 2b89;
8 2b80: a0,30,78             ldw   R78,R30            [TRIP_Time] = R30;   
8 2b83: 71,bf,b4             an2b  Rb4,bf             [OP_Reqd_flags].DOL_rqd = 0;
//  flip (save) TRIP state                                                            //
8 2b86: 95,04,b3             xrb   Rb3,4              [State_flags] ^= 4;  
8 2b89: f0                   ret                      return;              

STO_OUT:
//                                                                                    //
//  STO Output                                                                        //
//  A straight follow of STO_REQD bit to output line.                                 //
//  stops output if STI not active/dropped.                                           //
//                                                                                    //
8 2b8a: 33,5a,08             jnb   B3,R5a,2b95        if ([Svc_flags].STO_Reqd == 0) goto 2b95;
8 2b8d: 3e,b3,16             jb    B6,Rb3,2ba6        if ([State_flags].STO_state == 1) goto 2ba6;
8 2b90: b1,19,ba             ldb   Rba,19             Rba = 19;            
8 2b93: 20,06                sjmp  2b9b               goto 2b9b;           

8 2b95: 36,b3,0e             jnb   B6,Rb3,2ba6        if ([State_flags].STO_state == 0) goto 2ba6;
8 2b98: b1,09,ba             ldb   Rba,9              Rba = 9;             

2b9b - Sub 8 2b9b:
8 2b9b: 11,b2                clrb  Rb2                [HSO_Flags] = 0;     
8 2b9d: ef,f5,f7             call  2395               Do_OUTPUT();         
8 2ba0: 38,b2,03             jb    B0,Rb2,2ba6        if ([HSO_Flags].HSO_BUSY == 1) goto 2ba6;
//  flip (keep) STO state                                                             //
8 2ba3: 95,40,b3             xrb   Rb3,40             [State_flags] ^= 40; 
8 2ba6: f0                   ret                      return;              

Do_subTaskList:
8 2ba7: 65,02,00,98          ad2w  R98,2              [SubTaskNum] += 2;   
8 2bab: 89,32,00,98          cmpw  R98,32                                  
8 2baf: d3,02                jnc   2bb3               if ((uns) [SubTaskNum] < 32) goto 2bb3;
8 2bb1: 01,98                clrw  R98                [SubTaskNum] = 0;    
8 2bb3: cb,99,9a,3f          push  [R98+3f9a]         push([R98+SubTaskList]);
8 2bb7: f0                   ret                      return;              

Main_EXIT:
//                                                                                    //
//  Common return point for many subroutines (2170 = 'ret')                           //
//  probably for cal con monitoring ?                                                 //
//                                                                                    //
8 2bb8: e7,b5,f5             jump  2170               goto Sub0014;        

Do_ISC_OUT:
//                                                                                    //
//  Do_ISC    Idle control valve driver                                               //
//  R30 (PulseWidth length) calibrated as 328-32768 = ~0 - 6.25mS                     //
//  which is then subtracted from 6.25mS                                              //
//  to get 1-100% duty cycle at 160hz                                                 //
//  #                                                                                 //
//  'off' = last event time + scaled R34 (Idle_PW)                                    //
//  'on'  = 6.25ms - scaled R34.                                                      //
//                                                                                    //
//  NEVER set ?, always jumps                                                         //
8 2bbb: 34,b3,16             jnb   B4,Rb3,2bd4        if ([State_flags].ISC_off == 0) goto 2bd4;
8 2bbe: 35,b3,66             jnb   B5,Rb3,2c27        if ([State_flags].ISC_state == 0) goto 2c27;
8 2bc1: 11,b2                clrb  Rb2                [HSO_Flags] = 0;     
//  IDL off - immediate                                                               //
8 2bc3: b1,08,ba             ldb   Rba,8              Rba = 8;             
8 2bc6: ef,cc,f7             call  2395               Do_OUTPUT();         
8 2bc9: 38,b2,5b             jb    B0,Rb2,2c27        if ([HSO_Flags].HSO_BUSY == 1) goto 2c27;
8 2bcc: a0,30,2e             ldw   R2e,R30            [Last_ISC_Time] = R30;
8 2bcf: 71,df,b3             an2b  Rb3,df             [State_flags].ISC_state = 0;
8 2bd2: 20,53                sjmp  2c27               goto 2c27;           

8 2bd4: a3,01,30,01,30       ldw   R30,[130]          R30 = [ISC_PW_Final];
8 2bd9: 89,00,80,30          cmpw  R30,8000                                
8 2bdd: d1,04                jleu  2be3               if ((uns) R30 <= 8000) goto 2be3;
8 2bdf: a1,00,80,30          ldw   R30,8000           R30 = 8000;          
8 2be3: 89,48,01,30          cmpw  R30,148                                 
8 2be7: db,04                jc    2bed               if ((uns) R30 >= 148) goto 2bed;
//  force 328 <= R30 <= 32768                                                         //
8 2be9: a1,48,01,30          ldw   R30,148            R30 = 148;           

2bed - Sub 8 2bed:
8 2bed: a3,01,66,24,ba       ldw   Rba,[2466]         Rba = [ISC_Freq];    
8 2bf2: 09,01,ba             shlw  Rba,1              Rba = Rba * 2;       
8 2bf5: 6c,ba,30             ml2w  R30,Rba            R30 *= Rba;          
//  R34 = ISC_PW*6.25/32768                                                           //
8 2bf8: a0,32,34             ldw   R34,R32            R34 = R32;           
8 2bfb: a3,01,66,24,30       ldw   R30,[2466]         R30 = [ISC_Freq];    
//  this is remainder, 6.25mS - R34                                                   //
8 2c00: 48,32,30,36          sb3w  R36,R30,R32        R36 = R30 - R32;     
8 2c04: db,05                jc    2c0b               if (R36 >= 0) goto 2c0b;
8 2c06: a3,01,66,24,36       ldw   R36,[2466]         R36 = [ISC_Freq];    

2c0b - Sub 8 2c0b:
8 2c0b: a1,2e,00,3c          ldw   R3c,2e             R3c = 2e;            
8 2c0f: b1,80,b2             ldb   Rb2,80             [HSO_Flags] = 80;    
8 2c12: b1,08,ba             ldb   Rba,8              Rba = 8;             
//  2 events: off, then on with interrupt                                             //
8 2c15: b1,38,bb             ldb   Rbb,38             Rbb = 38;            
8 2c18: ef,7a,f7             call  2395               Do_OUTPUT();         
8 2c1b: 38,b2,09             jb    B0,Rb2,2c27        if ([HSO_Flags].HSO_BUSY == 1) goto 2c27;
8 2c1e: a0,32,2e             ldw   R2e,R32            [Last_ISC_Time] = R32;
8 2c21: 71,7f,b4             an2b  Rb4,7f             [OP_Reqd_flags].ISC_rqd = 0;
8 2c24: 71,df,b3             an2b  Rb3,df             [State_flags].ISC_state = 0;
8 2c27: f0                   ret                      return;              

Do_EGR_OUT:
//                                                                                    //
//  Do_EGR    EGR control is not fitted in this vehicle.                              //
//  EGR_Present [2458] is zero.                                                       //
//  Calc below R32 is time in ticks, so R32 = R36*208c/65536                          //
//  seems EGR_PW is scaled as 0-32768 = 0-20mS                                        //
//  limited in calc (3f93) to 16384 max (10 mS) ON,                                   //
//  which defines 30ms OFF, or 25% open ?                                             //
//                                                                                    //
8 2c28: 9b,01,58,24,00       cmpb  0,[2458]                                
8 2c2d: df,70                je    2c9f               if (0 == [EGR_Present]) goto 2c9f;
8 2c2f: 8b,01,42,01,06       cmpw  R06,[142]                               
8 2c34: de,04                jlt   2c3a               if ((sig) IO_TIMER < [EGR_Last_time]) goto 2c3a;
8 2c36: dd,67                jv    2c9f               if (OV) goto 2c9f;   
8 2c38: 20,02                sjmp  2c3c               goto 2c3c;           

8 2c3a: d5,63                jnv   2c9f               if (!OV) goto 2c9f;  
8 2c3c: a3,01,40,01,36       ldw   R36,[140]          R36 = [EGR_PW];      
//  40 mSec 'ticks'                                                                   //
8 2c41: 4d,8c,20,36,30       ml3w  R30,R36,208c       R30 = R36 * 208c;    
8 2c46: 3b,b3,23             jb    B3,Rb3,2c6c        if ([State_flags].EGR_State == 1) goto 2c6c;
8 2c49: 8b,01,5c,24,36       cmpw  R36,[245c]                              
8 2c4e: d9,07                jgtu  2c57               if ((uns) R36 > [EGR_LIM1]) goto 2c57;
8 2c50: c3,01,42,01,06       stw   [142],R06          [EGR_Last_time] = IO_TIMER;
8 2c55: 20,48                sjmp  2c9f               goto 2c9f;           

2c57 - Sub 8 2c57:
8 2c57: 69,23,08,32          sb2w  R32,823            R32 -= 823;          
//  negate to get 65536-x 'inverse'                                                   //
8 2c5b: 03,32                negw  R32                R32 = -R32;          
//  Ch0 (or 1) ON                                                                     //
8 2c5d: b1,10,ba             ldb   Rba,10             Rba = 10;            
8 2c60: 9b,01,78,24,00       cmpb  0,[2478]                                
8 2c65: df,20                je    2c87               if (0 == [EGR_chan]) goto 2c87;
8 2c67: b1,11,ba             ldb   Rba,11             Rba = 11;            
8 2c6a: 20,1b                sjmp  2c87               goto 2c87;           

8 2c6c: 8b,01,5e,24,36       cmpw  R36,[245e]                              
8 2c71: d3,07                jnc   2c7a               if ((uns) R36 < [EGR_lim2]) goto 2c7a;
8 2c73: c3,01,42,01,06       stw   [142],R06          [EGR_Last_time] = IO_TIMER;
8 2c78: 20,25                sjmp  2c9f               goto 2c9f;           

2c7a - Sub 8 2c7a:
8 2c7a: b1,00,ba             ldb   Rba,0              Rba = 0;             
8 2c7d: 9b,01,78,24,00       cmpb  0,[2478]                                
8 2c82: df,03                je    2c87               if (0 == [EGR_chan]) goto 2c87;
8 2c84: b1,01,ba             ldb   Rba,1              Rba = 1;             

2c87 - Sub 8 2c87:
8 2c87: a1,42,01,3c          ldw   R3c,142            R3c = 142;           
8 2c8b: a0,32,34             ldw   R34,R32            R34 = R32;           
//  Single event EGR_last + R34                                                       //
8 2c8e: b1,c0,b2             ldb   Rb2,c0             [HSO_Flags] = c0;    
8 2c91: ef,01,f7             call  2395               Do_OUTPUT();         
8 2c94: 38,b2,08             jb    B0,Rb2,2c9f        if ([HSO_Flags].HSO_BUSY == 1) goto 2c9f;
8 2c97: c3,01,42,01,30       stw   [142],R30          [EGR_Last_time] = R30;
//  flip (save) EGR_state                                                             //
8 2c9c: 95,08,b3             xrb   Rb3,8              [State_flags] ^= 8;  
8 2c9f: f0                   ret                      return;              

IPT_Timer_OVF - Interrupt Timer OVF:
//                                                                                    //
//  Timer overflow interrupt handler                                                  //
//  Occurs every 0.31 secs (4.8 uS * 65536)                                           //
//                                                                                    //
8 2ca0: f2                   pushp                    push(PSW);           
//  R12 not used anywhere else                                                        //
8 2ca1: 07,12                incw  R12                [T_OVF_CNT]++;       
8 2ca3: d7,03                jne   2ca8               if (0 != [T_OVF_CNT]) goto 2ca8;
//  set after 5 hrs 43 mins elapsed, not used                                         //
8 2ca5: 91,01,b5             orrb  Rb5,1              [flags3].TimerOVF = 1;

2ca8 - Sub 8 2ca8:
8 2ca8: 17,55                incb  R55                [FPUMP_Ticks]++;     
8 2caa: d7,02                jne   2cae               if (0 != [FPUMP_Ticks]) goto 2cae;
8 2cac: 15,55                decb  R55                [FPUMP_Ticks]--;     
8 2cae: fa                   di                       disable ints;        
8 2caf: ff                   ff                                            
8 2cb0: f3                   popp                     pop(PSW);            
8 2cb1: f1                   reti                     return;              

IPT_HSI_0 - Interrupt High Speed Input 0:
//          Dummy Interrupt Handler                                                   //
8 2cb2: f1                   reti                     return;              

IPT_HSI_Data - Interrupt High Speed Input Data:
//          High Speed Data IN Handler                                                //
8 2cb3: f2                   pushp                    push(PSW);           
8 2cb4: fa                   di                       disable ints;        
8 2cb5: ff                   ff                                            
8 2cb6: a0,0e,4c             ldw   R4c,R0e            R4c = HSI_TIME;      
8 2cb9: b0,0d,a8             ldb   Ra8,R0d            [New_HSI] = HSI_DATA;
8 2cbc: b0,a8,4b             ldb   R4b,Ra8            [This_HSI] = [New_HSI];
8 2cbf: fb                   ei                       enable ints;         
//  only interested in state changes                                                  //
8 2cc0: 94,54,a8             xrb   Ra8,R54            [New_HSI] ^= [Last_HSI];
//  PREV_HSI = THIS HSI before compare ...                                            //
8 2cc3: b0,4b,54             ldb   R54,R4b            [Last_HSI] = [This_HSI];

Do_Next_HSI:
8 2cc6: 38,a8,3b             jb    B0,Ra8,2d04        if ([New_HSI].New_PIP == 1) goto PIP_INTH;
//  BAP - handler is here, optional fitment.                                          //
8 2cc9: 3a,a8,19             jb    B2,Ra8,2ce5        if ([New_HSI].New_BAP == 1) goto BAP_Int;
//  Ignore (see main loop)                                                            //
8 2ccc: 3b,a8,11             jb    B3,Ra8,2ce0        if ([New_HSI].New_STI == 1) goto Ignore_STI;
//  Ignore                                                                            //
8 2ccf: 3c,a8,28             jb    B4,Ra8,2cfa        if (B4_[New_HSI]) goto Ignore_SB4;
//  Ignore (see main loop)                                                            //
8 2cd2: 3d,a8,2a             jb    B5,Ra8,2cff        if ([New_HSI].New_IDL == 1) goto Ignore_IDL;
8 2cd5: 11,a8                clrb  Ra8                [New_HSI] = 0;       

Check_Next_HSI:
8 2cd7: 99,00,a8             cmpb  Ra8,0                                   
8 2cda: d7,ea                jne   2cc6               if ([New_HSI] != 0) goto Do_Next_HSI;
8 2cdc: fa                   di                       disable ints;        
8 2cdd: ff                   ff                                            
8 2cde: f3                   popp                     pop(PSW);            
8 2cdf: f1                   reti                     return;              

Ignore_STI:
8 2ce0: 71,35,a8             an2b  Ra8,35             [New_HSI] &= 35;     
8 2ce3: 27,f2                sjmp  2cd7               goto Check_Next_HSI; 

BAP_Int:
8 2ce5: 4b,01,52,01,4c,4a    sb3w  R4a,R4c,[152]      R4a = R4c - [Last_BAP];
8 2ceb: c3,01,52,01,4c       stw   [152],R4c          [Last_BAP] = R4c;    
8 2cf0: c3,01,54,01,4a       stw   [154],R4a          [BAP_Interval] = R4a;
8 2cf5: 71,39,a8             an2b  Ra8,39             [New_HSI] &= 39;     
8 2cf8: 27,dd                sjmp  2cd7               goto Check_Next_HSI; 

Ignore_SB4:
8 2cfa: 71,2d,a8             an2b  Ra8,2d             [New_HSI] &= 2d;     
8 2cfd: 27,d8                sjmp  2cd7               goto Check_Next_HSI; 

Ignore_IDL:
8 2cff: 71,1d,a8             an2b  Ra8,1d             [New_HSI] &= 1d;     
8 2d02: 27,d3                sjmp  2cd7               goto Check_Next_HSI; 

PIP_INTH:
//     SPARK handling from here                                                       //

PIP_INTH:
8 2d04: 05,4c                decw  R4c                R4c--;               
//  Subtract propogation delay                                                        //
8 2d06: 05,4c                decw  R4c                R4c--;               
//  is PIP HIGH or LOW ?                                                              //
8 2d08: 38,4b,23             jb    B0,R4b,2d2e        if (B0_[This_HSI]) goto 2d2e;
//        LOW event processing from here                                              //
8 2d0b: 71,df,a9             an2b  Ra9,df             [IgnFlags2].PIP_State = 0;
8 2d0e: 48,40,4c,4a          sb3w  R4a,R4c,R40        R4a = R4c - [Last_PIP_High];
8 2d12: 89,a0,00,4a          cmpw  R4a,a0                                  
//  <= less than 768uS - ignore low event                                             //
8 2d16: db,05                jc    2d1d               if ((uns) R4a >= a0) goto 2d1d;
//  set PIP high, wait for true Low event                                             //
8 2d18: 91,01,54             orrb  R54,1              [Last_HSI] |= 1;     
8 2d1b: 20,89                sjmp  2da6               goto HSI_Next;       

8 2d1d: a0,4c,ee             ldw   Ree,R4c            [Last_PIP_Low] = R4c;
8 2d20: 3d,ae,06             jb    B5,Rae,2d29        if ([flags1].First_PIP == 1) goto 2d29;
//  Not if first startup (no events yet)                                              //
8 2d23: a0,1e,46             ldw   R46,R1e            [LastPipHiPW] = [PIP_High_PW];
8 2d26: a0,4a,1e             ldw   R1e,R4a            [PIP_High_PW] = R4a; 

2d29 - Sub 8 2d29:
8 2d29: 71,df,ae             an2b  Rae,df             [flags1].First_PIP = 0;
8 2d2c: 20,37                sjmp  2d65               goto 2d65;           

2d2e - Sub 8 2d2e:
8 2d2e: 48,40,4c,4a          sb3w  R4a,R4c,R40        R4a = R4c - [Last_PIP_High];
//  <= 1.536mS (>12K rpm)- Ignore event, reset to Low state                           //
8 2d32: 89,40,01,4a          cmpw  R4a,140                                 
8 2d36: db,05                jc    2d3d               if ((uns) R4a >= 140) goto 2d3d;
8 2d38: 71,3c,54             an2b  R54,3c             [Last_HSI] &= 3c;    
8 2d3b: 20,69                sjmp  2da6               goto HSI_Next;       

8 2d3d: a0,4c,40             ldw   R40,R4c            [Last_PIP_High] = R4c;
8 2d40: 3e,ae,08             jb    B6,Rae,2d4b        if ([flags1].First_PIP_hi == 1) goto 2d4b;
8 2d43: c3,01,28,01,44       stw   [128],R44          [Last_PIP_Intvl] = [PIP_Intrvl];
8 2d48: a0,4a,44             ldw   R44,R4a            [PIP_Intrvl] = R4a;  
8 2d4b: 71,bf,ae             an2b  Rae,bf             [flags1].First_PIP_hi = 0;
8 2d4e: 91,20,a9             orrb  Ra9,20             [IgnFlags2].PIP_State = 1;
8 2d51: 91,c0,b5             orrb  Rb5,c0             [flags3] |= c0;      
//  inc cyl no, spark and RPM calcs reqd.                                             //
8 2d54: 17,48                incb  R48                [Cyl_no]++;          
8 2d56: 99,01,48             cmpb  R48,1                                   
8 2d59: d7,03                jne   2d5e               if ([Cyl_no] != 1) goto 2d5e;
//  BOTH Inject BANKS SYNCed for injection                                            //
8 2d5b: 91,03,b4             orrb  Rb4,3              [OP_Reqd_flags] |= 3;
8 2d5e: 99,03,48             cmpb  R48,3                                   
//  Trigger every 3 sparks = Inject EVERY revolution, TWICE per cycle                 //
8 2d61: d7,02                jne   2d65               if ([Cyl_no] != 3) goto 2d65;
8 2d63: 11,48                clrb  R48                [Cyl_no] = 0;        

2d65 - Sub 8 2d65:
8 2d65: 11,55                clrb  R55                [FPUMP_Ticks] = 0;   
8 2d67: 91,04,b4             orrb  Rb4,4              [OP_Reqd_flags].SPARK_rqd = 1;
8 2d6a: 35,1a,0b             jnb   B5,R1a,2d78        if ([IgnFlags].Prev_underspd == 0) goto 2d78;
8 2d6d: 3e,1a,06             jb    B6,R1a,2d76        if ([IgnFlags].Underspeed == 1) goto 2d76;
8 2d70: 71,df,1a             an2b  R1a,df             [IgnFlags].Prev_underspd = 0;
//  just escaped an 'underspeed' state - no advance                                   //
8 2d73: 91,10,1a             orrb  R1a,10             [IgnFlags].Lock_Ign = 1;
8 2d76: 20,2e                sjmp  2da6               goto HSI_Next;       

8 2d78: 36,1a,05             jnb   B6,R1a,2d80        if ([IgnFlags].Underspeed == 0) goto 2d80;
//  entered or in an 'underspeed' state - no advance                                  //
8 2d7b: 91,30,1a             orrb  R1a,30             [IgnFlags] |= 30;    
8 2d7e: 20,26                sjmp  2da6               goto HSI_Next;       

8 2d80: 3c,1a,20             jb    B4,R1a,2da3        if ([IgnFlags].Lock_Ign == 1) goto Clear_ign_lock;
8 2d83: 3d,a9,10             jb    B5,Ra9,2d96        if ([IgnFlags2].PIP_State == 1) goto 2d96;
//           PIP STATE LOW                                                            //
8 2d86: 3b,a9,05             jb    B3,Ra9,2d8e        if ([IgnFlags2].PIP_Trail == 1) goto 2d8e;
8 2d89: 32,a9,1f             jnb   B2,Ra9,2dab        if ([IgnFlags2].PIP_Trail_Calc == 0) goto Clear_Spark_Reqd;
8 2d8c: 20,18                sjmp  2da6               goto HSI_Next;       

8 2d8e: 3a,a9,15             jb    B2,Ra9,2da6        if ([IgnFlags2].PIP_Trail_Calc == 1) goto HSI_Next;
8 2d91: 91,04,a9             orrb  Ra9,4              [IgnFlags2].PIP_Trail_Calc = 1;
8 2d94: 20,15                sjmp  2dab               goto Clear_Spark_Reqd;

2d96 - Sub 8 2d96:
8 2d96: 3b,a9,02             jb    B3,Ra9,2d9b        if ([IgnFlags2].PIP_Trail == 1) goto 2d9b;
8 2d99: 20,0b                sjmp  2da6               goto HSI_Next;       

8 2d9b: 3a,a9,0d             jb    B2,Ra9,2dab        if ([IgnFlags2].PIP_Trail_Calc == 1) goto Clear_Spark_Reqd;
8 2d9e: 91,04,a9             orrb  Ra9,4              [IgnFlags2].PIP_Trail_Calc = 1;
8 2da1: 20,08                sjmp  2dab               goto Clear_Spark_Reqd;

Clear_ign_lock:
8 2da3: 71,ef,1a             an2b  R1a,ef             [IgnFlags].Lock_Ign = 0;

HSI_Next:
8 2da6: 71,3c,a8             an2b  Ra8,3c             [New_HSI] &= 3c;     
8 2da9: 27,2c                sjmp  2cd7               goto Check_Next_HSI; 

Clear_Spark_Reqd:
8 2dab: 71,fb,b4             an2b  Rb4,fb             [OP_Reqd_flags].SPARK_rqd = 0;
8 2dae: 27,f6                sjmp  2da6               goto HSI_Next;       

IPT_HSO_1 - Interrupt High Speed Output 1:
//                                                                                    //
//  High Speed OUT interrupt handler                                                  //
//  for ISC and TRIP outputs...                                                       //
//                                                                                    //
//                                                                                    //
8 2db0: f2                   pushp                    push(PSW);           
8 2db1: 3e,b4,0e             jb    B6,Rb4,2dc2        if ([OP_Reqd_flags].DOL_rqd == 1) goto 2dc2;
8 2db4: 88,78,06             cmpw  R06,R78                                 
8 2db7: de,04                jlt   2dbd               if ((sig) IO_TIMER < [TRIP_Time]) goto 2dbd;
8 2db9: dd,07                jv    2dc2               if (OV) goto 2dc2;   
8 2dbb: 20,02                sjmp  2dbf               goto 2dbf;           

8 2dbd: d5,03                jnv   2dc2               if (!OV) goto 2dc2;  
8 2dbf: 91,40,b4             orrb  Rb4,40             [OP_Reqd_flags].DOL_rqd = 1;
8 2dc2: 3f,b4,11             jb    B7,Rb4,2dd6        if ([OP_Reqd_flags].ISC_rqd == 1) goto 2dd6;
8 2dc5: 88,2e,06             cmpw  R06,R2e                                 
8 2dc8: de,04                jlt   2dce               if ((sig) IO_TIMER < [Last_ISC_Time]) goto 2dce;
8 2dca: d5,04                jnv   2dd0               if (!OV) goto 2dd0;  
8 2dcc: 20,08                sjmp  2dd6               goto 2dd6;           

8 2dce: d5,06                jnv   2dd6               if (!OV) goto 2dd6;  
8 2dd0: 91,20,b3             orrb  Rb3,20             [State_flags].ISC_state = 1;
8 2dd3: 91,80,b4             orrb  Rb4,80             [OP_Reqd_flags].ISC_rqd = 1;
8 2dd6: fa                   di                       disable ints;        
8 2dd7: ff                   ff                                            
8 2dd8: f3                   popp                     pop(PSW);            
8 2dd9: f1                   reti                     return;              

Spark_calc_1:
//                                                                                    //
8 2dda: a0,62,e8             ldw   Re8,R62            [Ign_Cyl_Mass] = [Cyl_Mass_BK1];
8 2ddd: b0,1d,1c             ldb   R1c,R1d            [Ign_Advance] = [Last_Ign_adv];
8 2de0: a0,42,58             ldw   R58,R42            [Ign_Delay] = [Last_Ign_delay];
8 2de3: 37,1b,02             jnb   B7,R1b,2de8        if ([flagsw5].Base_ign_rqd == 0) goto 2de8;
8 2de6: 28,0e                scall 2df6               Base_Ign_Lookup();   
8 2de8: e7,cd,fd             jump  2bb8               goto Main_EXIT;      

IGN_clc3:
//                                                                                    //
8 2deb: 28,9f                scall 2e8c               IGN_Temp_Calc();     
8 2ded: b0,1c,1d             ldb   R1d,R1c            [Last_Ign_adv] = [Ign_Advance];
8 2df0: a0,58,42             ldw   R42,R58            [Last_Ign_delay] = [Ign_Delay];
8 2df3: e7,c2,fd             jump  2bb8               goto Main_EXIT;      

Base_Ign_Lookup:
//                                                                                    //
//  Base Ignition Calc (RPM, Flow, ACT)                                               //
//                                                                                    //
//  Stage 1. Looks up timing via Scaled RPM and Flow and then                         //
//  interpolates between HOT and COLD Ignition tables                                 //
//  via ACT lookup table to give 3D mapping.                                          //
//  #                                                                                 //
//  Uses alternate Cold table if Cold Start conditions detected                       //
//  #                                                                                 //
//  Interpolate calculation is                                                        //
//  ((ADV_COLD*ACT) + ADV_HOT*(127-ACT))/128;                                         //
//  where ACT lookup maps 0 to 128                                                    //
//                                                                                    //
//  If underspeed, fix Advance at 10 degrees and inhibit next                         //
//  subroutine (no point if fixed timing...)                                          //
//  (0x28 = 40) base 10 BTDC physical assumed                                         //
//                                                                                    //
//                                                                                    //
8 2df6: 36,1a,04             jnb   B6,R1a,2dfd        if ([IgnFlags].Underspeed == 0) goto 2dfd;
8 2df9: b1,28,1c             ldb   R1c,28             [Ign_Advance] = 28;  
8 2dfc: f0                   ret                      return;              

8 2dfd: a1,58,28,32          ldw   R32,2858           R32 = RPM_SCALE_10;  
8 2e01: a0,70,34             ldw   R34,R70            R34 = [RPM];         
8 2e04: ef,b5,04             call  32bc               UUWordLU();          
8 2e07: a0,38,6a             ldw   R6a,R38            R6a = R38;           
8 2e0a: a1,74,28,32          ldw   R32,2874           R32 = FLOW_SCALE_10; 
8 2e0e: a0,e8,34             ldw   R34,Re8            R34 = [Ign_Cyl_Mass];
8 2e11: ef,a8,04             call  32bc               UUWordLU();          
8 2e14: a0,38,6c             ldw   R6c,R38            R6c = R38;           
8 2e17: a0,6a,30             ldw   R30,R6a            R30 = R6a;           
8 2e1a: a0,6c,32             ldw   R32,R6c            R32 = R6c;           
8 2e1d: a1,0b,00,34          ldw   R34,b              R34 = b;             
8 2e21: 9b,01,35,24,27       cmpb  R27,[2435]                              
//  ACT dft = 10                                                                      //
8 2e26: d2,22                jgt   2e4a               if ((sig) [ACT_start] > [C36_deg]) goto 2e4a;
8 2e28: 9b,01,36,24,27       cmpb  R27,[2436]                              
8 2e2d: da,1b                jle   2e4a               if ((sig) [ACT_start] <= [C-40_deg]) goto 2e4a;
8 2e2f: 9b,01,35,24,9f       cmpb  R9f,[2435]                              
//  ECT dft = 50                                                                      //
8 2e34: d2,14                jgt   2e4a               if ((sig) [ECT_start] > [C36_deg]) goto 2e4a;
8 2e36: 9b,01,36,24,9f       cmpb  R9f,[2436]                              
8 2e3b: da,0d                jle   2e4a               if ((sig) [ECT_start] <= [C-40_deg]) goto 2e4a;
8 2e3d: 8b,01,3c,24,ea       cmpw  Rea,[243c]                              
8 2e42: d9,06                jgtu  2e4a               if ((uns) [Run_Time] > [650_Secs]) goto 2e4a;
8 2e44: a1,9b,26,38          ldw   R38,269b           R38 = Ign_Adv_ColdStart;
8 2e48: 20,04                sjmp  2e4e               goto 2e4e;           

8 2e4a: a1,79,25,38          ldw   R38,2579           R38 = Ign_Adv_Cold;  
8 2e4e: ef,26,04             call  3277               UTabLU();            
8 2e51: ac,3b,3c             ldzbw R3c,R3b            R3c = (uns)R3b;      
8 2e54: a1,b0,28,32          ldw   R32,28b0           R32 = Ign_Interp;    
8 2e58: bc,73,34             ldsbw R34,R73            R34 = (sig)[ACT_val];
//  interpolate answer in R38 (0 to 128)                                              //
8 2e5b: ef,61,04             call  32bf               SSWordLU();          
8 2e5e: ad,7f,b8             ldzbw Rb8,7f             Rb8 = (uns)7f;       
//  Rb8 = 127 - R38; ('reverse' of R38 for interpolate)                               //
8 2e61: 68,38,b8             sb2w  Rb8,R38            Rb8 -= R38;          
8 2e64: 28,d7                scall 2f3d               Scale_R3c();         
//  Rba = ADV_COLD * Ans/128;                                                         //
8 2e66: a0,3c,ba             ldw   Rba,R3c            Rba = R3c;           
//  = scaled RPM                                                                      //
8 2e69: a0,6a,30             ldw   R30,R6a            R30 = R6a;           
//  = scaled (mass) Flow                                                              //
8 2e6c: a0,6c,32             ldw   R32,R6c            R32 = R6c;           
8 2e6f: a1,0b,00,34          ldw   R34,b              R34 = b;             
8 2e73: a1,f2,25,38          ldw   R38,25f2           R38 = Ign_Adv_Hot;   
8 2e77: ef,fd,03             call  3277               UTabLU();            
8 2e7a: ac,3b,38             ldzbw R38,R3b            R38 = (uns)R3b;      
8 2e7d: a0,b8,3c             ldw   R3c,Rb8            R3c = Rb8;           
//  R3c = ADV_HOT *(127 - Ans)/128;                                                   //
8 2e80: 28,bb                scall 2f3d               Scale_R3c();         
//  = cold fraction + hot fraction                                                    //
8 2e82: 64,3c,ba             ad2w  Rba,R3c            Rba += R3c;          
//  Result passed to next subroutine                                                  //
8 2e85: a0,ba,f2             ldw   Rf2,Rba            [Base_ign_delay] = Rba;
//  OK for next subroutine                                                            //
8 2e88: 91,01,b3             orrb  Rb3,1              [State_flags].Base_Calc_OK = 1;
8 2e8b: f0                   ret                      return;              

IGN_Temp_Calc:
//                                                                                    //
//  Stage 2 ignition Calc                                                             //
//  Skip if underspeed (base ignition set)                                            //
//  add additional ignition advance from ECT (block temp) and flow,                   //
//  NDS, Knock Delay and selected delay (via outside pins)                            //
//  Can also swop to alternate calc if demanded by Flag from ISC.                     //
//  (throttle closed or anti-stall below defined RPM ?)                               //
//  then apply limit check and smoothing.                                             //
//                                                                                    //
//  Need OK from previous subroutine                                                  //
8 2e8c: 38,b3,02             jb    B0,Rb3,2e91        if ([State_flags].Base_Calc_OK == 1) goto 2e91;
8 2e8f: 20,ab                sjmp  2f3c               goto 2f3c;           

8 2e91: 71,fe,b3             an2b  Rb3,fe             [State_flags].Base_Calc_OK = 0;
//  from previous subroutine, first calc of ign                                       //
8 2e94: a0,f2,ba             ldw   Rba,Rf2            Rba = [Base_ign_delay];
8 2e97: a1,84,28,32          ldw   R32,2884           R32 = ECT_SCALE_7;   
8 2e9b: b0,72,35             ldb   R35,R72            R35 = [ECT_val];     
8 2e9e: 11,34                clrb  R34                R34 = 0;             
8 2ea0: ef,1c,04             call  32bf               SSWordLU();          
//  scaled ECT (block temp)                                                           //
8 2ea3: a0,38,6a             ldw   R6a,R38            R6a = R38;           
8 2ea6: a1,a0,28,32          ldw   R32,28a0           R32 = FLOW_SCALE_5;  
8 2eaa: a0,e8,34             ldw   R34,Re8            R34 = [Ign_Cyl_Mass];
8 2ead: ef,0c,04             call  32bc               UUWordLU();          
//  scaled (mass) Flow                                                                //
8 2eb0: a0,38,6c             ldw   R6c,R38            R6c = R38;           
8 2eb3: a0,6a,30             ldw   R30,R6a            R30 = R6a;           
8 2eb6: a0,6c,32             ldw   R32,R6c            R32 = R6c;           
8 2eb9: a1,08,00,34          ldw   R34,8              R34 = 8;             
8 2ebd: a1,6b,26,38          ldw   R38,266b           R38 = Ign_Adv_ECTFlow;
8 2ec1: ef,b3,03             call  3277               UTabLU();            
8 2ec4: ac,3b,3c             ldzbw R3c,R3b            R3c = (uns)R3b;      
//  Alternate (fixed base) from ISC subroutine                                        //
8 2ec7: 3d,b5,10             jb    B5,Rb5,2eda        if ([flags3].No_Lock_Ign_ISC == 1) goto 2eda;
//  fixed advance + ECT advance                                                       //
8 2eca: 47,01,94,24,3c,ba    ad3w  Rba,R3c,[2494]     Rba = R3c + [IGN_12];
8 2ed0: 31,b5,26             jnb   B1,Rb5,2ef9        if ([flags3].NDS_Drive == 0) goto 2ef9;
//  NDS additional advance?                                                           //
8 2ed3: 67,01,ac,24,ba       ad2w  Rba,[24ac]         Rba += [IGN_NDS_0];  
//  skip knock check                                                                  //
8 2ed8: 20,1f                sjmp  2ef9               goto 2ef9;           

2eda - Sub 8 2eda:
8 2eda: 64,ba,3c             ad2w  R3c,Rba            R3c += Rba;          
8 2edd: af,01,34,24,38       ldzbw R38,[2434]         R38 = (uns)[IgnScaler];
8 2ee2: 28,59                scall 2f3d               Scale_R3c();         
//  scale and trim (redundant)                                                        //
8 2ee4: 47,01,2e,24,3c,ba    ad3w  Rba,R3c,[242e]     Rba = R3c + [IGN_TRIM_0];
8 2eea: 33,2c,0c             jnb   B3,R2c,2ef9        if ([RPM_flags].Knock_Risk == 0) goto 2ef9;
8 2eed: 8b,01,30,24,70       cmpw  R70,[2430]                              
8 2ef2: d1,05                jleu  2ef9               if ((uns) [RPM] <= [IGNKnckLow]) goto 2ef9;
//  add knock delay (-ve advance)                                                     //
8 2ef4: 67,01,68,24,ba       ad2w  Rba,[2468]         Rba += [IGN_KnckDly];
8 2ef9: bc,7c,30             ldsbw R30,R7c            R30 = (sig)[Octane_adj];
//  add Octane Adjust (-ve)                                                           //
//                                                                                    //
//  ### limit and delta (smoothing) from here ###                                     //
//                                                                                    //
8 2efc: 64,30,ba             ad2w  Rba,R30            Rba += R30;          
//  clip to min (zero) if -ve                                                         //
8 2eff: 3f,bb,0c             jb    B7,Rbb,2f0e        if (B7_Rbb) goto 2f0e;
8 2f02: 99,00,bb             cmpb  Rbb,0                                   
//  clip to max (50) if overflow                                                      //
8 2f05: d7,13                jne   2f1a               if (Rbb != 0) goto 2f1a;
8 2f07: 9b,01,32,24,ba       cmpb  Rba,[2432]                              
8 2f0c: d9,05                jgtu  2f13               if ((uns) Rba > [IGNRegMin]) goto 2f13;
8 2f0e: b3,01,32,24,ba       ldb   Rba,[2432]         Rba = [IGNRegMin];   
8 2f13: 9b,01,33,24,ba       cmpb  Rba,[2433]                              
8 2f18: d3,05                jnc   2f1f               if ((uns) Rba < [IGNRegMax]) goto 2f1f;
8 2f1a: b3,01,33,24,ba       ldb   Rba,[2433]         Rba = [IGNRegMax];   

2f1f - Sub 8 2f1f:
8 2f1f: b1,18,30             ldb   R30,18             R30 = 18;            
//  Delta of this and last advance ?                                                  //
8 2f22: 58,1c,ba,38          sb3b  R38,Rba,R1c        R38 = Rba - [Ign_Advance];
8 2f26: 37,38,04             jnb   B7,R38,2f2d        if (!B7_R38) goto 2f2d;
8 2f29: 13,30                negb  R30                R30 = -R30;          
//  => abs(R30), abs(R38)                                                             //
8 2f2b: 13,38                negb  R38                R38 = -R38;          
8 2f2d: 99,18,38             cmpb  R38,18                                  
8 2f30: d1,04                jleu  2f36               if ((uns) R38 <= 18) goto 2f36;
//  limit to 6 deg max change +/-                                                     //
8 2f32: 54,30,1c,ba          ad3b  Rba,R1c,R30        Rba = [Ign_Advance] + R30;
8 2f36: b0,ba,1c             ldb   R1c,Rba            [Ign_Advance] = Rba; 
//  call delay calc (angular delay for spark out)                                     //
8 2f39: ef,09,00             call  2f45               Ign_Delay_Calc();    
8 2f3c: f0                   ret                      return;              

Scale_R3c:
//                                                                                    //
//  Scale R3c                                                                         //
//  R38 defines 128ths fraction of R3c (signed)                                       //
//  ANS  R3c = R3c * (R38/128)                                                        //
//                                                                                    //
8 2f3d: fe,6c,38,3c          sml2w  R3c,R38           R3c *= (sig)R38;     
8 2f41: 0c,07,3c             shrdw R3c,7              R3cL = R3cL / 80;    
8 2f44: f0                   ret                      return;              

Ign_Delay_Calc:
//                                                                                                      //
//  Returns with Ignition angular DELAY.                                                                //
//  Scaled 0-32768 as 0-120 degrees. Sets timing for NEXT CYL.                                          //
//  Degrees actually scaled *4 (0.25 degree).                                                           //
//  This value is then multiplied by ticks to get trigger time value - elsewhere (2200 ish).            //
//  IGN_DELAY = (120 + 10 - Ign_Advance)*32768/120; [works as PIP_Interval = 120 degrees]               //
//  and 10 BTDC (base) = 32768, => 120 degrees 'delay' for next cyl                                     //
//  #                                                                                                   //
//  Ignition advance can legally be less than 10, and so calc checks 32768 boundary to do + or - calc.  //
//  Multipled by PIP_interval [120 degrees] and triggered from PIP leading edge (Lo_Hi transition).     //
//  #                                                                                                   //
//  If flag set, Calc doubles value so that delay works correctly when multiplied by PIP_HIGH_PW        //
//  [60 degrees] and triggered from PIP trailing edge (Hi-Lo transition)                                //
//                                                                                                      //
//  # 3 sparks per revolution                                                         //
8 2f45: a1,03,00,32          ldw   R32,3              R32 = 3;             
8 2f49: 01,36                clrw  R36                R36 = 0;             
//  R34L = 1440 = 360 degrees *4                                                      //
8 2f4b: a1,a0,05,34          ldw   R34,5a0            R34 = 5a0;           
//  R34 = 120 deg *4, spark gap in degrees                                            //
8 2f4f: 8c,32,34             divw  R34,R32            R34 = R34L / R32;    
//  R36 = 130 deg (static timing ?)                                                   //
8 2f52: 45,28,00,34,36       ad3w  R36,R34,28         R36 = R34 + 28;      
8 2f57: ac,1c,38             ldzbw R38,R1c            R38 = (uns)[Ign_Advance];
//  R32 = 130 - Ign_Adv                                                               //
8 2f5a: 48,38,36,32          sb3w  R32,R36,R38        R32 = R36 - R38;     
//  R30 = (130 - Ign_Adv)*65536                                                       //
8 2f5e: 01,30                clrw  R30                R30 = 0;             
8 2f60: 09,01,34             shlw  R34,1              R34 = R34 * 2;       
//  IGN_delay = R30 = (130 - IGN_ADV)*32768/120;                                      //
8 2f63: 8c,34,30             divw  R30,R34            R30 = R30L / R34;    
8 2f66: dd,32                jv    2f9a               if (OV) goto 2f9a;   
8 2f68: a0,30,58             ldw   R58,R30            [Ign_Delay] = R30;   
8 2f6b: 91,02,a9             orrb  Ra9,2              [IgnFlags2].PIP_Lead_Calc = 1;
8 2f6e: 33,a9,2a             jnb   B3,Ra9,2f9b        if ([IgnFlags2].PIP_Trail == 0) goto 2f9b;
8 2f71: 71,fd,a9             an2b  Ra9,fd             [IgnFlags2].PIP_Lead_Calc = 0;
8 2f74: 89,00,80,30          cmpw  R30,8000                                
//  IGN_ADV < 10 [>32768], so Delay > 120 deg.                                        //
8 2f78: d3,0f                jnc   2f89               if ((uns) R30 < 8000) goto 2f89;
//  R32 = IGN_delay - 120 Degrees (in -ve)                                            //
8 2f7a: 49,00,80,30,32       sb3w  R32,R30,8000       R32 = R30 - 8000;    
//  R32 = (IGN_delay - 120 deg) * 2                                                   //
8 2f7f: 09,01,32             shlw  R32,1              R32 = R32 * 2;       
//  = 120 deg + (Ign_delay - 120 deg)*2                                               //
8 2f82: 45,00,80,32,58       ad3w  R58,R32,8000       [Ign_Delay] = R32 + 8000;
8 2f87: 20,12                sjmp  2f9b               goto 2f9b;           

2f89 - Sub 8 2f89:
8 2f89: a1,00,80,32          ldw   R32,8000           R32 = 8000;          
//  R34 = 120 deg - ign_delay                                                         //
8 2f8d: 48,30,32,34          sb3w  R34,R32,R30        R34 = R32 - R30;     
8 2f91: 09,01,34             shlw  R34,1              R34 = R34 * 2;       
//  = 120 deg - (120 deg - Ign_delay)*2                                               //
8 2f94: 48,34,32,58          sb3w  R58,R32,R34        [Ign_Delay] = R32 - R34;
8 2f98: 20,01                sjmp  2f9b               goto 2f9b;           

8 2f9a: ff                   ff                                            
8 2f9b: f0                   ret                      return;              

UUByteLU - Byte Function Reader:
//                                                                                    //
//  BYTE function lookup with linear interpolate                                      //
//  Signed and Unsigned Byte                                                          //
//  R32 = lookup table                                                                //
//  R34 = value in                                                                    //
//  R38 = value out (Byte)                                                            //
//                                                                                    //
8 2f9c: 91,02,f6             orrb  Rf6,2              [Rf6].Unsigned = 1;  

SSByteLU - Byte Function Reader SI SO:
8 2f9f: 9b,32,02,34          cmpb  R34,[R32+2]                             
8 2fa3: 31,f6,04             jnb   B1,Rf6,2faa        if ([Rf6].Unsigned == 0) goto 2faa;
8 2fa6: db,0a                jc    2fb2               if (R32 > ffff) goto 2fb2;
8 2fa8: 20,02                sjmp  2fac               goto 2fac;           

8 2faa: d6,06                jge   2fb2               if ((sig) R34 >= [R32+2]) goto 2fb2;
8 2fac: 65,02,00,32          ad2w  R32,2              R32 += 2;            
8 2fb0: 27,ed                sjmp  2f9f               goto SSByteLU;       

8 2fb2: b2,33,36             ldb   R36,[R32++]        R36 = [R32++];       
8 2fb5: b2,33,38             ldb   R38,[R32++]        R38 = [R32++];       
8 2fb8: 7a,32,36             sb2b  R36,[R32]          R36 -= [R32];        
8 2fbb: 7a,33,34             sb2b  R34,[R32++]        R34 -= [R32++];      
8 2fbe: 7a,32,38             sb2b  R38,[R32]          R38 -= [R32];        
8 2fc1: 31,f6,04             jnb   B1,Rf6,2fc8        if ([Rf6].Unsigned == 0) goto 2fc8;
8 2fc4: db,09                jc    2fcf               if (R38 > ff) goto 2fcf;
8 2fc6: 20,02                sjmp  2fca               goto 2fca;           

8 2fc8: d6,05                jge   2fcf               if ((sig) R38 >= 0) goto 2fcf;
8 2fca: 91,01,f6             orrb  Rf6,1              [Rf6].Neg_flag = 1;  
8 2fcd: 13,38                negb  R38                R38 = -R38;          
8 2fcf: 7c,34,38             ml2b  R38,R34            R38 *= R34;          
8 2fd2: 9c,36,38             divb  R38,R36            R38 = R38W / R36;    
8 2fd5: 30,f6,02             jnb   B0,Rf6,2fda        if ([Rf6].Neg_flag == 0) goto 2fda;
8 2fd8: 13,38                negb  R38                R38 = -R38;          
8 2fda: 76,32,38             ad2b  R38,[R32]          R38 += [R32];        
8 2fdd: 71,fc,f6             an2b  Rf6,fc             Rf6 &= fc;           
8 2fe0: f0                   ret                      return;              

SWfilter:
//                                                                                    //
//  Digital Filter (for rolling averages) - Signed or Unsigned WORD                   //
//  (NB Unsigned Filter not used in this code)                                        //
//  Val_out = orig_val + (val_delta) * Filter_Constant                                //
//  R32 = Original Value                                                              //
//  R34 = New value                                                                   //
//  R36 = Filter Constant (fraction of 65536)                                         //
//  ANSWER                                                                            //
//  R3e = R32 + (( R34 - R32) * R36)/65536                                            //
//                                                                                    //
8 2fe1: b1,02,ba             ldb   Rba,2              Rba = 2;             
8 2fe4: 20,02                sjmp  2fe8               goto 2fe8;           



UWfilter:
8 2fe6: 11,ba                                         Unknown Operation/Structure


2fe8 - Sub 8 2fe8:
8 2fe8: 48,32,34,3c          sb3w  R3c,R34,R32        R3c = R34 - R32;     
8 2fec: 31,ba,04             jnb   B1,Rba,2ff3        if (!B1_Rba) goto 2ff3;
8 2fef: db,09                jc    2ffa               if (R3e >= 0) goto 2ffa;
8 2ff1: 20,02                sjmp  2ff5               goto 2ff5;           

8 2ff3: d6,05                jge   2ffa               if ((sig) R3c >= 0) goto 2ffa;

2ff5 - Sub 8 2ff5:
8 2ff5: 91,01,ba             orrb  Rba,1              Rba |= 1;            
8 2ff8: 03,3c                negw  R3c                R3c = -R3c;          
8 2ffa: 89,01,00,3c          cmpw  R3c,1                                   
8 2ffe: d9,05                jgtu  3005               if ((uns) R3c > 1) goto 3005;
//  No change - return orig value                                                     //
8 3000: a0,32,3e             ldw   R3e,R32            R3e = R32;           
8 3003: 20,11                sjmp  3016               goto 3016;           

3005 - Sub 8 3005:
8 3005: 6c,36,3c             ml2w  R3c,R36            R3c *= R36;          
8 3008: 03,3e                negw  R3e                R3e = -R3e;          
8 300a: d7,02                jne   300e               if (R3c != R3e) goto 300e;
//  if top of Dword zero, make -1                                                     //
8 300c: 05,3e                decw  R3e                R3e--;               
8 300e: 38,ba,02             jb    B0,Rba,3013        if (B0_Rba) goto 3013;
8 3011: 03,3e                negw  R3e                R3e = -R3e;          

3013 - Sub 8 3013:
8 3013: 64,32,3e             ad2w  R3e,R32            R3e += R32;          
8 3016: f0                   ret                      return;              

Process_Sensors:
//                                                                                    //
//  Process other sensors, ACT,ECT,Oct Adjust,ACC,NDS                                 //
//  If startup, average first 10 readings of ACT and ECT                              //
//  and assign to 'start' values, assign initial ISC PW, Octane, etc.                 //
//                                                                                    //
8 3017: a1,6c,29,32          ldw   R32,296c           R32 = ACT_TFR;       
8 301b: a0,90,34             ldw   R34,R90            R34 = [ACT_raw];     
//  10mV resolution                                                                   //
8 301e: 08,01,34             shrw  R34,1              R34 = R34 / 2;       
8 3021: ef,9b,02             call  32bf               SSWordLU();          
//  rounding                                                                          //
8 3024: 45,80,00,38,3a       ad3w  R3a,R38,80         R3a = R38 + 80;      
8 3029: b0,3b,73             ldb   R73,R3b            [ACT_val] = R3b;     
8 302c: 99,0a,7b             cmpb  R7b,a                                   
8 302f: db,08                jc    3039               if ((uns) [AE_readcnt] >= a) goto 3039;
8 3031: fe,6d,9a,19,38       sml2w  R38,199a          R38 *= (sig)199a;    
//  ACT_start = ACT_start + ACT_OrigLU/10;                                            //
8 3036: 64,3a,26             ad2w  R26,R3a            [ACT_start_W] += R3a;
8 3039: a1,18,29,32          ldw   R32,2918           R32 = ECT_TFR;       
8 303d: a0,8e,34             ldw   R34,R8e            R34 = [ECT_raw];     
//  10mV resolution                                                                   //
8 3040: 08,01,34             shrw  R34,1              R34 = R34 / 2;       
8 3043: ef,79,02             call  32bf               SSWordLU();          
//  rounding                                                                          //
8 3046: 45,80,00,38,3a       ad3w  R3a,R38,80         R3a = R38 + 80;      
8 304b: b0,3b,72             ldb   R72,R3b            [ECT_val] = R3b;     
//  loop 10 times for ECT and ACT start values                                        //
8 304e: 99,0a,7b             cmpb  R7b,a                                   
8 3051: db,27                jc    307a               if ((uns) [AE_readcnt] >= a) goto 307a;
8 3053: fe,6d,9a,19,38       sml2w  R38,199a          R38 *= (sig)199a;    
//  ECT_start = ECT_start + ECT_OrigLU/10;                                            //
8 3058: 64,3a,9e             ad2w  R9e,R3a            [ECT_Start_hb] += R3a;
8 305b: a1,7c,2a,32          ldw   R32,2a7c           R32 = ISC_Start_PW;  
8 305f: bc,9f,34             ldsbw R34,R9f            R34 = (sig)[ECT_start];
8 3062: ef,5a,02             call  32bf               SSWordLU();          
8 3065: c3,01,3c,01,38       stw   [13c],R38          [Last_ISC_H] = R38;  
//  ISC pulswidth & 1600 rpm Idle if startup                                          //
8 306a: a1,00,19,38          ldw   R38,1900           R38 = 1900;          
8 306e: c3,01,32,01,38       stw   [132],R38          [Reqd_idle_RPM] = R38;
8 3073: c3,01,66,01,8a       stw   [166],R8a          [OCT_flt] = [OCT_raw];
8 3078: 17,7b                incb  R7b                [AE_readcnt]++;      
8 307a: 34,18,08             jnb   B4,R18,3085        if ([Fail_flags].ACTFail == 0) goto 3085;
8 307d: b3,01,38,24,73       ldb   R73,[2438]         [ACT_val] = [C20_deg];
//  Fail - set defaults                                                               //
8 3082: b0,73,27             ldb   R27,R73            [ACT_start] = [ACT_val];
8 3085: 33,18,08             jnb   B3,R18,3090        if ([Fail_flags].ECTFail == 0) goto 3090;
8 3088: b3,01,37,24,72       ldb   R72,[2437]         [ECT_val] = [C100_deg];
//  Fail - set defaults                                                               //
8 308d: b0,72,9f             ldb   R9f,R72            [ECT_start] = [ECT_val];
8 3090: a3,01,66,01,32       ldw   R32,[166]          R32 = [OCT_flt];     
8 3095: a0,8a,34             ldw   R34,R8a            R34 = [OCT_raw];     
//  => 2% of change for octane select                                                 //
8 3098: a1,05,05,36          ldw   R36,505            R36 = 505;           
8 309c: 2f,43                scall 2fe1               SWfilter();          
8 309e: c3,01,66,01,3e       stw   [166],R3e          [OCT_flt] = R3e;     
8 30a3: 8b,01,b0,24,3e       cmpw  R3e,[24b0]                              
8 30a8: d3,07                jnc   30b1               if ((uns) R3e < [3.845V]) goto 30b1;
//  no Octane Adjust                                                                  //
8 30aa: b3,01,74,24,7c       ldb   R7c,[2474]         [Octane_adj] = [0deg];
8 30af: 20,21                sjmp  30d2               goto 30d2;           

8 30b1: 8b,01,b2,24,3e       cmpw  R3e,[24b2]                              
8 30b6: d3,07                jnc   30bf               if ((uns) R3e < [1.92V]) goto 30bf;
//  3 degrees retard (ground pin 24)                                                  //
8 30b8: b3,01,75,24,7c       ldb   R7c,[2475]         [Octane_adj] = [3deg];
8 30bd: 20,13                sjmp  30d2               goto 30d2;           

8 30bf: 8b,01,b4,24,3e       cmpw  R3e,[24b4]                              
8 30c4: d3,07                jnc   30cd               if ((uns) R3e < [0.0V]) goto 30cd;
//  6 degrees retard (ground pin 23)                                                  //
8 30c6: b3,01,76,24,7c       ldb   R7c,[2476]         [Octane_adj] = [6deg];
8 30cb: 20,05                sjmp  30d2               goto 30d2;           

30cd - Sub 8 30cd:
8 30cd: b3,01,77,24,7c       ldb   R7c,[2477]         [Octane_adj] = [defdeg];
8 30d2: 71,f1,b5             an2b  Rb5,f1             [flags3] &= f1;      
8 30d5: 89,00,80,82          cmpw  R82,8000                                
//  2.56V                                                                             //
8 30d9: d3,03                jnc   30de               if ((uns) [ACC_raw] < 8000) goto 30de;
8 30db: 91,08,b5             orrb  Rb5,8              [flags3].ACC_On = 1; 
8 30de: 89,40,d0,92          cmpw  R92,d040                                
//  4.165v                                                                            //
8 30e2: d3,05                jnc   30e9               if ((uns) [NDS_raw] < d040) goto 30e9;
8 30e4: 91,04,b5             orrb  Rb5,4              [flags3].NDS_Neutral = 1;
8 30e7: 20,14                sjmp  30fd               goto 30fd;           

8 30e9: 89,00,8a,92          cmpw  R92,8a00                                
//  2.76v                                                                             //
8 30ed: db,0e                jc    30fd               if ((uns) [NDS_raw] >= 8a00) goto 30fd;
8 30ef: 89,40,5e,92          cmpw  R92,5e40                                
//  1.885v                                                                            //
8 30f3: d3,05                jnc   30fa               if ((uns) [NDS_raw] < 5e40) goto 30fa;
8 30f5: 91,06,b5             orrb  Rb5,6              [flags3] |= 6;       
8 30f8: 20,03                sjmp  30fd               goto 30fd;           

8 30fa: 91,02,b5             orrb  Rb5,2              [flags3].NDS_Drive = 1;
8 30fd: b3,01,4c,24,32       ldb   R32,[244c]         R32 = [FLGS_B3_B0];  
8 3102: 3c,32,03             jb    B4,R32,3108        if (B4_R32) goto 3108;
//  b4=0, Always cleared                                                              //
8 3105: 71,fb,b5             an2b  Rb5,fb             [flags3].NDS_Neutral = 0;
8 3108: a1,18,28,32          ldw   R32,2818           R32 = ECT_Coldstart_Time;
8 310c: bc,9f,34             ldsbw R34,R9f            R34 = (sig)[ECT_start];
8 310f: ef,ad,01             call  32bf               SSWordLU();          
8 3112: a0,38,24             ldw   R24,R38            [Coldstart_secs] = R38;
8 3115: a1,c0,28,32          ldw   R32,28c0           R32 = Vss_TFR;       
8 3119: a0,80,34             ldw   R34,R80            R34 = [Vss_raw];     
8 311c: ef,9d,01             call  32bc               UUWordLU();          
8 311f: a0,38,52             ldw   R52,R38            [VBATT] = R38;       
8 3122: e7,93,fa             jump  2bb8               goto Main_EXIT;      

Main_airflow_calc:
//             VAF flow calc                                                          //
//  VAF, BAP, ACT to calculate true MASS air flow                                     //
//  Sets VAF1_flow & VAF2_Flow as MASS value.                                         //
//  #                                                                                 //
//  Mass = Volume * Pressure/temp;  (Effectively)                                     //
//  Answer scaled as 8192 = density 1.0                                               //
//  #                                                                                 //
//  Gas law (approx) Density =  (Pressure * 11.796)/Temp K                            //
//  looks like R3e (density multiplier) is scaled as                                  //
//  65536 = 3 atmospheres (3*8192)                                                    //
//  Default BAP and ACT_val = 0 (Std atmo at 0c) this subr sets                       //
//  multipler (density)= 1.2469, but 1.2929 expected, 3.5% low.                       //
//  default BAP and default ACT (20 C) gives 1.206                                    //
//  Density correction table probably carries out a version of the                    //
//  'drag equation' = force on flap proportional to Volume*density                    //
//  Answer is scaled by final scaler (94%) and divided by 4                           //
//                                                                                    //
//  each state change                                                                 //
8 3125: a3,01,54,01,34       ldw   R34,[154]          R34 = [BAP_Interval];
8 312a: a1,96,01,32          ldw   R32,196            R32 = 196;           
//  = 26,666,666 = 128 secs in IO ticks                                               //
8 312e: a1,aa,e6,30          ldw   R30,e6aa           R30 = e6aa;          
8 3132: 8c,34,30             divw  R30,R34            R30 = R30L / R34;    
//  = 2* BAP frequency (Hz)                                                           //
8 3135: c3,01,56,01,30       stw   [156],R30          [BAP_Freq] = R30;    
8 313a: a0,30,34             ldw   R34,R30            R34 = R30;           
8 313d: a1,dc,2a,32          ldw   R32,2adc           R32 = BAP_TFR;       
8 3141: ef,78,01             call  32bc               UUWordLU();          
8 3144: 36,18,05             jnb   B6,R18,314c        if ([Fail_flags].BAPFail == 0) goto 314c;
8 3147: b3,01,0c,24,38       ldb   R38,[240c]         R38 = [BAP_Dflt];    

314c - Sub 8 314c:
8 314c: c7,01,58,01,38       stb   [158],R38          [BAP_Val] = R38;     
8 3151: b0,38,37             ldb   R37,R38            R37 = R38;           
8 3154: 11,36                clrb  R36                R36 = 0;             
//  R36 = InHg*256                                                                    //
8 3156: 08,03,36             shrw  R36,3              R36 = R36 / 8;       
//  R34L = Pressure (scaled)                                                          //
8 3159: 01,34                clrw  R34                R34 = 0;             
8 315b: b0,73,31             ldb   R31,R73            R31 = [ACT_val];     
8 315e: 1a,01,31             asrb  R31,1              R31 = R31 / 2;       
//  add absolute zero (272)                                                           //
8 3161: 75,44,31             ad2b  R31,44             R31 += 44;           
//  R30 = degrees Kelvin (scaled)                                                     //
8 3164: 11,30                clrb  R30                R30 = 0;             
//  R34 = Pressure/temp (scaled)                                                      //
8 3166: 8c,30,34             divw  R34,R30            R34 = R34L / R30;    
//  Correction table                                                                  //
8 3169: a1,c0,29,32          ldw   R32,29c0           R32 = Air_Density;   
8 316d: ef,4c,01             call  32bc               UUWordLU();          
//  Scale by 94% and divide by 4                                                      //
8 3170: 6f,01,2c,24,38       ml2w  R38,[242c]         R38 *= [DenseScaler];
//  R3e is 'Vol->Mass' converter                                                      //
8 3175: a0,3a,3e             ldw   R3e,R3a            R3e = R3a;           
8 3178: 35,18,0f             jnb   B5,R18,318a        if ([Fail_flags].VAF1Fail == 0) goto 318a;
8 317b: 31,18,07             jnb   B1,R18,3185        if ([Fail_flags].VAF2Fail == 0) goto 3185;
8 317e: a3,01,3a,24,34       ldw   R34,[243a]         R34 = [VAF_dflt];    
8 3183: 20,08                sjmp  318d               goto 318d;           

8 3185: a0,7e,34             ldw   R34,R7e            R34 = [VAF2_raw];    
8 3188: 20,03                sjmp  318d               goto 318d;           

8 318a: a0,96,34             ldw   R34,R96            R34 = [VAF1_raw];    
8 318d: 28,20                scall 31af               Mass_Flow();         
8 318f: a0,3a,9a             ldw   R9a,R3a            [VAF1_Mflow] = R3a;  
8 3192: 31,18,0f             jnb   B1,R18,31a4        if ([Fail_flags].VAF2Fail == 0) goto 31a4;
8 3195: 35,18,07             jnb   B5,R18,319f        if ([Fail_flags].VAF1Fail == 0) goto 319f;
8 3198: a3,01,3a,24,34       ldw   R34,[243a]         R34 = [VAF_dflt];    
8 319d: 20,08                sjmp  31a7               goto 31a7;           

8 319f: a0,96,34             ldw   R34,R96            R34 = [VAF1_raw];    
8 31a2: 20,03                sjmp  31a7               goto 31a7;           

8 31a4: a0,7e,34             ldw   R34,R7e            R34 = [VAF2_raw];    
8 31a7: 28,06                scall 31af               Mass_Flow();         
8 31a9: a0,3a,9c             ldw   R9c,R3a            [VAF2_Mflow] = R3a;  
8 31ac: e7,09,fa             jump  2bb8               goto Main_EXIT;      

Mass_Flow:
//                                                                                    //
//  VAF MASS Flow calc - used within above subroutine -                               //
//  IN  R34 = raw VAF (volume flow),                                                  //
//  IN  R3e = density factor                                                          //
//  Returns    R3a = MASS FLOW = volume * density                                     //
//  assumes R32 set to VAF TFR table                                                  //
//  Converts volume to MASS                                                           //
//  final multiply makes this a straight vol*density conversion                       //
//  Limit check at 8192*65536, VAF lookup is unsigned word                            //
8 31af: a1,cc,28,32          ldw   R32,28cc           R32 = VAF_TFR;       
8 31b3: ef,06,01             call  32bc               UUWordLU();          
//  Volume*density/8                                                                  //
8 31b6: 6c,3e,38             ml2w  R38,R3e            R38 *= R3e;          
8 31b9: 99,20,3b             cmpb  R3b,20                                  
//  max = 8192*65536                                                                  //
8 31bc: d3,07                jnc   31c5               if ((uns) R3b < 20) goto 31c5;
8 31be: a1,ff,ff,3a          ldw   R3a,ffff           R3a = ffff;          
8 31c2: 91,01,69             orrb  R69,1              [OVF_flags].VAF_OVF = 1;

31c5 - Sub 8 31c5:
8 31c5: 0d,03,38             shldw R38,3              R38L = R38L * 8;     
8 31c8: f0                   ret                      return;              

Process_TPS:
//                                                                                    //
//  TPS, do filter and set TPS flags.                                                 //
//  Calcs TPS_Difference, flags and TPS_read Interval                                 //
//                                                                                    //
8 31c9: 32,18,09             jnb   B2,R18,31d5        if ([Fail_flags].TPSFail == 0) goto 31d5;
8 31cc: a1,00,80,c8          ldw   Rc8,8000           [TPS_Min] = 8000;    
8 31d0: a0,c8,ec             ldw   Rec,Rc8            [TPS_val] = [TPS_Min];
8 31d3: 20,36                sjmp  320b               goto 320b;           

8 31d5: a0,ec,32             ldw   R32,Rec            R32 = [TPS_val];     
8 31d8: a0,8c,34             ldw   R34,R8c            R34 = [TPS_raw];     
//  => 4.76 % of change                                                               //
8 31db: a1,31,0c,36          ldw   R36,c31            R36 = c31;           
8 31df: ef,ff,fd             call  2fe1               SWfilter();          
//  New smoothed value                                                                //
8 31e2: a0,3e,ec             ldw   Rec,R3e            [TPS_val] = R3e;     
8 31e5: 88,c8,ec             cmpw  Rec,Rc8                                 
8 31e8: db,03                jc    31ed               if ((uns) [TPS_val] >= [TPS_Min]) goto 31ed;
8 31ea: a0,ec,c8             ldw   Rc8,Rec            [TPS_Min] = [TPS_val];
8 31ed: 48,c8,8c,aa          sb3w  Raa,R8c,Rc8        [TPS_Posn] = [TPS_raw] - [TPS_Min];
8 31f1: d9,02                jgtu  31f5               if ((uns) [TPS_Posn] > 0) goto 31f5;
//  Throttle must be closed if equal/lower                                            //
//                                                                                    //
//  ### Throttle closed ###                                                           //
8 31f3: 01,aa                clrw  Raa                [TPS_Posn] = 0;      
8 31f5: 8b,01,48,24,aa       cmpw  Raa,[2448]                              
8 31fa: d9,08                jgtu  3204               if ((uns) [TPS_Posn] > [0.065V]) goto 3204;
//  $20:1 used in test (STI) sequence                                                 //
8 31fc: 91,03,20             orrb  R20,3              [TPS_flags] |= 3;    
8 31ff: 71,fb,20             an2b  R20,fb             [TPS_flags].TPS_Wide = 0;
8 3202: 20,12                sjmp  3216               goto 3216;           

3204 - Sub 8 3204:
8 3204: 8b,01,4a,24,aa       cmpw  Raa,[244a]                              
8 3209: d9,05                jgtu  3210               if ((uns) [TPS_Posn] > [3.25V]) goto 3210;
8 320b: 71,f8,20             an2b  R20,f8             [TPS_flags] &= f8;   
8 320e: 20,06                sjmp  3216               goto 3216;           

3210 - Sub 8 3210:
8 3210: 91,04,20             orrb  R20,4              [TPS_flags].TPS_Wide = 1;
8 3213: 71,fc,20             an2b  R20,fc             [TPS_flags] &= fc;   

3216 - Sub 8 3216:
8 3216: a0,06,30             ldw   R30,R06            R30 = IO_TIMER;      
8 3219: a3,01,46,01,32       ldw   R32,[146]          R32 = [Last_TPS];    
8 321e: 68,32,30             sb2w  R30,R32            R30 -= R32;          
8 3221: c3,01,48,01,30       stw   [148],R30          [TPS_Interval] = R30;
8 3226: c3,01,46,01,06       stw   [146],R06          [Last_TPS] = IO_TIMER;
8 322b: e7,8a,f9             jump  2bb8               goto Main_EXIT;      

RPM_calc:
//                                                                                    //
//  Main RPM Calculation                                                              //
//  do filter and set which PIP calculation to use                                    //
//                                                                                    //
8 322e: 37,b5,1d             jnb   B7,Rb5,324e        if ([flags3].New_RPM == 0) goto 324e;
8 3231: a1,fe,00,36          ldw   R36,fe             R36 = fe;            
//  16666666 / elapsed time is RPM/4 on 6 cyl                                         //
8 3235: a1,2a,50,34          ldw   R34,502a           R34 = 502a;          
8 3239: 8c,44,34             divw  R34,R44            R34 = R34L / [PIP_Intrvl];
8 323c: a0,34,70             ldw   R70,R34            [RPM] = R34;         
8 323f: 71,7f,b5             an2b  Rb5,7f             [flags3].New_RPM = 0;
8 3242: a0,5c,32             ldw   R32,R5c            R32 = [RPM_Smooth];  
//  1.2% of change, heavy filter                                                      //
8 3245: a1,09,03,36          ldw   R36,309            R36 = 309;           
8 3249: 2d,96                scall 2fe1               SWfilter();          
8 324b: a0,3e,5c             ldw   R5c,R3e            [RPM_Smooth] = R3e;  
8 324e: 3a,5a,02             jb    B2,R5a,3253        if ([Svc_flags].PUMP_Reqd == 1) goto 3253;
8 3251: 01,70                clrw  R70                [RPM] = 0;           
8 3253: 33,a9,14             jnb   B3,Ra9,326a        if ([IgnFlags2].PIP_Trail == 0) goto 326a;
8 3256: a3,01,44,24,32       ldw   R32,[2444]         R32 = [1000RPM];     
//     Flip PIP calc at 1050 and greater (50 rpm hysteresis)                          //
8 325b: 67,01,46,24,32       ad2w  R32,[2446]         R32 += [50RPM];      
8 3260: 88,32,5c             cmpw  R5c,R32                                 
8 3263: d3,0f                jnc   3274               if ((uns) [RPM_Smooth] < R32) goto 3274;
8 3265: 71,f7,a9             an2b  Ra9,f7             [IgnFlags2].PIP_Trail = 0;
8 3268: 20,0a                sjmp  3274               goto 3274;           

326a - Sub 8 326a:
8 326a: 8b,01,44,24,5c       cmpw  R5c,[2444]                              
8 326f: db,03                jc    3274               if ((uns) [RPM_Smooth] >= [1000RPM]) goto 3274;
8 3271: 91,08,a9             orrb  Ra9,8              [IgnFlags2].PIP_Trail = 1;
8 3274: e7,41,f9             jump  2bb8               goto Main_EXIT;      

UTabLU - Table Reader:
//                                                                                       //
//  Table lookup subroutine with 2Dimension interpolate - byte                           //
//  Pars In -                                                                            //
//  R38 = Table Address                                                                  //
//  R30 = X value. (column)   'whole' in top byte (R31), fraction in lower (R30)         //
//  R32 = Y value  (row       'whole' in top byte (R33), fraction in lower (R32)         //
//  R34 = table size  (columns + 1)                                                      //
//  Pars out -                                                                           //
//  R3b = returned value (R3a =80 for rounding )                                         //
//  #                                                                                    //
//  R30-R33 trashed in this function                                                     //
//  Neatly interpolates by interpolating this and next columns at row X                  //
//  to make a 'slope', and then interpolating that slope in Y. (uses 4 values in table)  //
//                                                                                       //
//  Y*cols. Get into correct row.                                                     //
8 3277: 5c,33,34,36          ml3b  R36,R34,R33        R36 = R34 * R33;     
//  (Y*cols)+X. = Correct (lower) cell offset.                                        //
8 327b: 74,31,36             ad2b  R36,R31            R36 += R31;          
8 327e: d3,02                jnc   3282               if (R36 <= ff) goto 3282;
//  Add carry if byte o/flow.                                                         //
8 3280: 17,37                incb  R37                R37++;               

3282 - Sub 8 3282:
8 3282: 64,36,38             ad2w  R38,R36            R38 += R36;          
//  R31 = [0,0] BASE cell, below input value.                                         //
8 3285: b2,39,31             ldb   R31,[R38++]        R31 = [R38++];       
//  R33 = [1,0] cell, [ next X value]                                                 //
8 3288: b2,38,33             ldb   R33,[R38]          R33 = [R38];         
//  R3b = Interpolated X,0 (R31, R33) by fract X                                      //
8 328b: 28,1c                scall 32a9               TabInterp();         
8 328d: 64,34,38             ad2w  R38,R34            R38 += R34;          
//  R33 = [1,1] cell (next x, next y)                                                 //
8 3290: b2,38,33             ldb   R33,[R38]          R33 = [R38];         
8 3293: 05,38                decw  R38                R38--;               
//  R31 = [0,1] cell (this x, next y)                                                 //
8 3295: b2,38,31             ldb   R31,[R38]          R31 = [R38];         
//  save interpolated X                                                               //
8 3298: b0,3b,34             ldb   R34,R3b            R34 = R3b;           
//  Interpolated (X,1) value by fract X.                                              //
8 329b: 28,0c                scall 32a9               TabInterp();         
//  intpolated (X,1)                                                                  //
8 329d: b0,3b,33             ldb   R33,R3b            R33 = R3b;           
//  intpolated (X,0)                                                                  //
8 32a0: b0,34,31             ldb   R31,R34            R31 = R34;           
//  set interpolate fraction to Y value                                               //
8 32a3: b0,32,30             ldb   R30,R32            R30 = R32;           
//  Interpolate intpld(x,0), intpld(x,1) in fraction Y                                //
8 32a6: 28,01                scall 32a9               TabInterp();         
8 32a8: f0                   ret                      return;              

TabInterp:
//                                                                                    //
//  UNSIGNED one dimension byte interpolate for tablookup - answer in R3b             //
//  R30 = fraction 0-255                                                              //
//  R31 = lower cell value                                                            //
//  R33 = upper cell value                                                            //
//  R3b = (upper-lower)*fraction/256 + lower                                          //
//  R3b = interpolated answer between R31 and R33 by R30                              //
//  Answer in R3b.                                                                    //
//                                                                                    //
//  R3a = fraction * high val                                                         //
8 32a9: 5c,33,30,3a          ml3b  R3a,R30,R33        R3a = R30 * R33;     
//  R36 = fraction * low val                                                          //
8 32ad: 5c,31,30,36          ml3b  R36,R30,R31        R36 = R30 * R31;     
//  R3a = (fract*high)-(fract*low) [= increment*fract]                                //
8 32b1: 68,36,3a             sb2w  R3a,R36            R3a -= R36;          
//  R3b = increment*fract/256 + low                                                   //
8 32b4: 74,31,3b             ad2b  R3b,R31            R3b += R31;          
//  round up for answer in R3b                                                        //
8 32b7: 65,80,00,3a          ad2w  R3a,80             R3a += 80;           
8 32bb: f0                   ret                      return;              

UUWordLU - Word Function Reader:
//                                                                                    //
//  WORD function lookup with linear interpolate                                      //
//  Signed and Unsigned Word                                                          //
//  R32 = lookup table                                                                //
//  R34 = value in    (Vin)                                                           //
//  R38 = value out (Vout) (Word)                                                     //
//  (LU = lookup)                                                                     //
//                                                                                    //
//  set unsigned compare                                                              //
8 32bc: 91,02,f6             orrb  Rf6,2              [Rf6].Unsigned = 1;  

SSWordLU - Word Function Reader SI SO:
8 32bf: 8b,32,04,34          cmpw  R34,[R32+4]                             
//  jump if signed compare                                                            //
8 32c3: 31,f6,04             jnb   B1,Rf6,32ca        if ([Rf6].Unsigned == 0) goto 32ca;
//  do unsigned compare                                                               //
8 32c6: db,0a                jc    32d2               if (R32 > ffff) goto 32d2;
8 32c8: 20,02                sjmp  32cc               goto 32cc;           

32ca - Sub 8 32ca:
8 32ca: d6,06                jge   32d2               if ((sig) R34 >= [R32+4]) goto 32d2;

32cc - Sub 8 32cc:
8 32cc: 65,04,00,32          ad2w  R32,4              R32 += 4;            
8 32d0: 27,ed                sjmp  32bf               goto SSWordLU;       

32d2 - Sub 8 32d2:
8 32d2: a2,33,36             ldw   R36,[R32++]        R36 = [R32++];       
//  R38 = low  (next)LU value (R34>Vin>R38)                                           //
8 32d5: a2,33,38             ldw   R38,[R32++]        R38 = [R32++];       
//  R36 = LU gap (between rows)                                                       //
8 32d8: 6a,32,36             sb2w  R36,[R32]          R36 -= [R32];        
//  R34 = Vin_Delta (VIN - low LU)                                                    //
8 32db: 6a,33,34             sb2w  R34,[R32++]        R34 -= [R32++];      
//  R38 = Vout gap (between rows)                                                     //
8 32de: 6a,32,38             sb2w  R38,[R32]          R38 -= [R32];        
//  Is this Signed lookup                                                             //
8 32e1: 31,f6,04             jnb   B1,Rf6,32e8        if ([Rf6].Unsigned == 0) goto 32e8;
//  VOUT increment is Y +ve or unsigned lookup                                        //
8 32e4: db,09                jc    32ef               if (R38 > ffff) goto 32ef;
8 32e6: 20,02                sjmp  32ea               goto 32ea;           

8 32e8: d6,05                jge   32ef               if ((sig) R38 >= 0) goto 32ef;

32ea - Sub 8 32ea:
8 32ea: 91,01,f6             orrb  Rf6,1              [Rf6].Neg_flag = 1;  
8 32ed: 03,38                negw  R38                R38 = -R38;          
8 32ef: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
//  R38 = (Vout_gap*VIN_delta)/LU_gap = Vout_Delta                                    //
8 32f2: 8c,36,38             divw  R38,R36            R38 = R38L / R36;    
8 32f5: 30,f6,02             jnb   B0,Rf6,32fa        if ([Rf6].Neg_flag == 0) goto 32fa;
8 32f8: 03,38                negw  R38                R38 = -R38;          

32fa - Sub 8 32fa:
8 32fa: 66,32,38             ad2w  R38,[R32]          R38 += [R32];        
8 32fd: 71,fc,f6             an2b  Rf6,fc             Rf6 &= fc;           
8 3300: f0                   ret                      return;              

Ign_Delta_Calc:
//                                                                                    //
//  This calculates rate of change & averages (?)                                     //
//  for PIP intervals (last and this) to give improved                                //
//  and smoothed response for next SPOUT.                                             //
//                                                                                    //
//  SPOUT = (120 + fixed - Advance)/120 - (ThisPIP + lastPIP)/lastPIP                 //
//  and limited within an envelope - delta set at 10% increments and                  //
//  'nibbled' off at 1% for smoothed ignition response (?)                            //
//  Called only from task list                                                        //
//  limit checked (33aa) to 10% max either way with 32768 'base'                      //
//  #                                                                                 //
//  is R3a passed out of this func ? No next func in list writes to R3a               //
//                                                                                    //
8 3301: 3e,b5,02             jb    B6,Rb5,3306        if ([flags3].New_PIP == 1) goto 3306;
8 3304: 20,eb                sjmp  33f1               goto endfunc;        

8 3306: fa                   di                       disable ints;        
8 3307: ff                   ff                                            
8 3308: a0,44,ba             ldw   Rba,R44            Rba = [PIP_Intrvl];  
8 330b: a3,01,28,01,b8       ldw   Rb8,[128]          Rb8 = [Last_PIP_Intvl];
8 3310: a0,46,3e             ldw   R3e,R46            R3e = [LastPipHiPW]; 
//  is PIP_high_PW = 60 degrees in ticks ?                                            //
8 3313: a0,1e,3c             ldw   R3c,R1e            R3c = [PIP_High_PW]; 
8 3316: fb                   ei                       enable ints;         
8 3317: 71,bf,b5             an2b  Rb5,bf             [flags3].New_PIP = 0;
//  Difference in PIP (High?) intervals                                               //
8 331a: 48,b8,ba,36          sb3w  R36,Rba,Rb8        R36 = Rba - Rb8;     
8 331e: db,02                jc    3322               if (R36 >= 0) goto 3322;
//  abs (difference)                                                                  //
8 3320: 03,36                negw  R36                R36 = -R36;          

3322 - Sub 8 3322:
8 3322: 4c,ac,ba,30          ml3w  R30,Rba,Rac        R30 = Rba * [Ign_DELTA];
8 3326: 88,32,36             cmpw  R36,R32                                 
//  abs(diff) > (PIP_Hi_Intvl * IDelta)/65536                                         //
8 3329: d1,02                jleu  332d               if ((uns) R36 <= R32) goto 332d;
//  always jumps for first change ?                                                   //
8 332b: 20,b4                sjmp  33e1               goto Set_delta;      

8 332d: 01,34                clrw  R34                R34 = 0;             
//  abs (PIP_HI_intvl - Last_PIP_Intvl)*65536 / PIP_Hi_Intvl (Delta)                  //
8 332f: 8c,ba,34             divw  R34,Rba            R34 = R34L / Rba;    
8 3332: d5,02                jnv   3336               if (!OV) goto 3336;  
8 3334: 20,bb                sjmp  33f1               goto endfunc;        

8 3336: a0,34,30             ldw   R30,R34            R30 = R34;           
//  R32 = Delta/65536 * PIP_HI_PW                                                     //
8 3339: 6c,3c,30             ml2w  R30,R3c            R30 *= R3c;          
//  (Delta * PIP_Hi_PW) - LastPipHiPW                                                 //
8 333c: 48,3e,3c,30          sb3w  R30,R3c,R3e        R30 = R3c - R3e;     
8 3340: db,02                jc    3344               if (R30 >= 0) goto 3344;
//  ABS Value (timediff?)                                                             //
8 3342: 03,30                negw  R30                R30 = -R30;          

3344 - Sub 8 3344:
8 3344: 4d,99,19,ac,38       ml3w  R38,Rac,1999       R38 = [Ign_DELTA] * 1999;
//  move in R36                                                                       //
8 3349: a0,3a,36             ldw   R36,R3a            R36 = R3a;           
8 334c: 89,41,00,34          cmpw  R34,41                                  
//  change < 1% (PIP)                                                                 //
8 3350: d3,70                jnc   33c2               if ((uns) R34 < 41) goto 33c2;
8 3352: 08,01,3a             shrw  R3a,1              R3a = R3a / 2;       
8 3355: a1,00,80,38          ldw   R38,8000           R38 = 8000;          
//  R38 = 32768 - (I_Delta * 0.5)                                                     //
8 3359: 68,3a,38             sb2w  R38,R3a            R38 -= R3a;          
8 335c: db,02                jc    3360               if (R38 >= 0) goto 3360;
8 335e: 20,91                sjmp  33f1               goto endfunc;        

3360 - Sub 8 3360:
8 3360: 6c,32,38             ml2w  R38,R32            R38 *= R32;          
8 3363: 0d,01,38             shldw R38,1              R38L = R38L * 2;     
8 3366: 88,3a,30             cmpw  R30,R3a                                 
8 3369: d3,76                jnc   33e1               if ((uns) R30 < R3a) goto Set_delta;
8 336b: 08,01,36             shrw  R36,1              R36 = R36 / 2;       
8 336e: 65,00,80,36          ad2w  R36,8000           R36 += 8000;         
8 3372: db,7d                jc    33f1               if (R36 > ffff) goto endfunc;
8 3374: 4c,32,36,38          ml3w  R38,R36,R32        R38 = R36 * R32;     
8 3378: 0d,01,38             shldw R38,1              R38L = R38L * 2;     
8 337b: 88,3a,30             cmpw  R30,R3a                                 
8 337e: d9,61                jgtu  33e1               if ((uns) R30 > R3a) goto Set_delta;
8 3380: 44,b8,ba,36          ad3w  R36,Rba,Rb8        R36 = Rba + Rb8;     
8 3384: dd,6b                jv    33f1               if (OV) goto endfunc;
8 3386: 01,34                clrw  R34                R34 = 0;             
8 3388: 44,3e,3c,30          ad3w  R30,R3c,R3e        R30 = R3c + R3e;     
8 338c: dd,63                jv    33f1               if (OV) goto endfunc;
8 338e: 0c,02,34             shrdw R34,2              R34L = R34L / 4;     
8 3391: 8c,30,34             divw  R34,R30            R34 = R34L / R30;    
8 3394: dd,5b                jv    33f1               if (OV) goto endfunc;
8 3396: a0,f0,32             ldw   R32,Rf0            R32 = [Ign_Delta];   
//  => 12.5% of change                                                                //
8 3399: a3,01,42,24,36       ldw   R36,[2442]         R36 = [Ign_flt_sc];  
8 339e: ef,40,fc             call  2fe1               SWfilter();          
8 33a1: a0,3e,f0             ldw   Rf0,R3e            [Ign_Delta] = R3e;   
8 33a4: 89,33,73,f0          cmpw  Rf0,7333                                
8 33a8: db,04                jc    33ae               if ((uns) [Ign_Delta] >= 7333) goto 33ae;
//  = 0.45                                                                            //
8 33aa: a1,33,73,f0          ldw   Rf0,7333           [Ign_Delta] = 7333;  
8 33ae: 89,cc,8c,f0          cmpw  Rf0,8ccc                                
8 33b2: d1,04                jleu  33b8               if ((uns) [Ign_Delta] <= 8ccc) goto 33b8;
//  = 0.55                                                                            //
8 33b4: a1,cc,8c,f0          ldw   Rf0,8ccc           [Ign_Delta] = 8ccc;  

33b8 - Sub 8 33b8:
8 33b8: 69,47,01,ac          sb2w  Rac,147            [Ign_DELTA] -= 147;  
8 33bc: d6,02                jge   33c0               if ((sig) [Ign_DELTA] >= 0) goto 33c0;
//  < 1%, ignore                                                                      //
8 33be: 01,ac                clrw  Rac                [Ign_DELTA] = 0;     
8 33c0: 20,2f                sjmp  33f1               goto endfunc;        

8 33c2: a0,30,34             ldw   R34,R30            R34 = R30;           
8 33c5: 08,01,36             shrw  R36,1              R36 = R36 / 2;       
8 33c8: 65,00,80,36          ad2w  R36,8000           R36 += 8000;         
8 33cc: dd,23                jv    33f1               if (OV) goto endfunc;
8 33ce: a0,36,38             ldw   R38,R36            R38 = R36;           
8 33d1: 4d,41,00,3c,30       ml3w  R30,R3c,41         R30 = R3c * 41;      
8 33d6: 6c,32,38             ml2w  R38,R32            R38 *= R32;          
8 33d9: 0d,01,38             shldw R38,1              R38L = R38L * 2;     
8 33dc: 88,3a,34             cmpw  R34,R3a                                 
8 33df: d1,9f                jleu  3380               if ((uns) R34 <= R3a) goto 3380;

Set_delta:
8 33e1: 65,cc,0c,ac          ad2w  Rac,ccc            [Ign_DELTA] += ccc;  
8 33e5: dd,06                jv    33ed               if (OV) goto 33ed;   
8 33e7: 89,00,80,ac          cmpw  Rac,8000                                
8 33eb: d3,04                jnc   33f1               if ((uns) [Ign_DELTA] < 8000) goto endfunc;

33ed - Sub 8 33ed:
8 33ed: a1,00,80,ac          ldw   Rac,8000           [Ign_DELTA] = 8000;  

endfunc:
8 33f1: e7,c4,f7             jump  2bb8               goto Main_EXIT;      

Base_inj_calc:
//                                                                                    //
//  Base Injection calc from mass flow.                                               //
//  Sets base flow after calc cylinder flow per bank from VAFs                        //
//  appears 4000 In to Calc_Cyl_Charge = 1.208g (1 litre) cyl charge                  //
//  at 1000rpm, so vaf_MFlow must be 8000 = 1500L/min or 750L/min?                    //
//                                                                                    //
8 33f4: b3,01,4c,24,30       ldb   R30,[244c]         R30 = [FLGS_B3_B0];  
//  would EGO feedback change this ??                                                 //
8 33f9: a1,00,40,22          ldw   R22,4000           [Inj_Scaler] = 4000; 
8 33fd: a0,9c,38             ldw   R38,R9c            R38 = [VAF2_Mflow];  
//  R3a = (mass) flow/2 ;                                                             //
8 3400: 6f,01,06,24,38       ml2w  R38,[2406]         R38 *= [VAF2_Scaler];
8 3405: 67,01,0a,24,3a       ad2w  R3a,[240a]         R3a += [VAF2_Trimx]; 
8 340a: 47,01,08,24,3a,3e    ad3w  R3e,R3a,[2408]     R3e = R3a + [VAF2_Trim];
8 3410: 37,3f,05             jnb   B7,R3f,3418        if (!B7_R3f) goto 3418;
8 3413: 01,3e                clrw  R3e                R3e = 0;             
8 3415: 91,01,69             orrb  R69,1              [OVF_flags].VAF_OVF = 1;
8 3418: c3,01,2a,01,3e       stw   [12a],R3e          [DBG_BK2_Flow] = R3e;
8 341d: 28,4d                scall 346c               Calc_Cyl_AirMass();  
8 341f: a0,3c,64             ldw   R64,R3c            [Cyl_Mass_BK2] = R3c;
8 3422: 28,7d                scall 34a1               Base_Cyl_Inj_calc(); 
8 3424: a0,3c,d0             ldw   Rd0,R3c            [Inj_Cyl_BK2] = R3c; 
8 3427: a0,9a,38             ldw   R38,R9a            R38 = [VAF1_Mflow];  
8 342a: 6f,01,00,24,38       ml2w  R38,[2400]         R38 *= [VAF1_Scaler];
8 342f: 67,01,04,24,3a       ad2w  R3a,[2404]         R3a += [VAF1_Trimx]; 
8 3434: 47,01,02,24,3a,3e    ad3w  R3e,R3a,[2402]     R3e = R3a + [VAF1_Trim];
8 343a: 37,3f,05             jnb   B7,R3f,3442        if (!B7_R3f) goto 3442;
8 343d: 01,3e                clrw  R3e                R3e = 0;             
8 343f: 91,01,69             orrb  R69,1              [OVF_flags].VAF_OVF = 1;
8 3442: a0,3e,74             ldw   R74,R3e            [DBG_BK1_flow] = R3e;
8 3445: 28,25                scall 346c               Calc_Cyl_AirMass();  
8 3447: a0,3c,62             ldw   R62,R3c            [Cyl_Mass_BK1] = R3c;
8 344a: 33,30,17             jnb   B3,R30,3464        if (!B3_R30) goto 3464;
8 344d: 9b,01,6a,24,00       cmpb  0,[246a]                                
8 3452: df,03                je    3457               if (0 == [Crank_1]) goto 3457;
8 3454: 3f,1a,0d             jb    B7,R1a,3464        if ([IgnFlags].Cranking == 1) goto 3464;
8 3457: 44,62,64,3c          ad3w  R3c,R64,R62        R3c = [Cyl_Mass_BK2] + [Cyl_Mass_BK1];
8 345b: 08,01,3c             shrw  R3c,1              R3c = R3c / 2;       
//  average both cyl flows                                                            //
8 345e: a0,3c,62             ldw   R62,R3c            [Cyl_Mass_BK1] = R3c;
//  R62 used in EGR and Ign calcs.                                                    //
8 3461: a0,3c,64             ldw   R64,R3c            [Cyl_Mass_BK2] = R3c;
8 3464: 28,3b                scall 34a1               Base_Cyl_Inj_calc(); 
//  and then recalc B1 only ? Odd.                                                    //
8 3466: a0,3c,ce             ldw   Rce,R3c            [Inj_Cyl_BK1] = R3c; 
8 3469: e7,4c,f7             jump  2bb8               goto Main_EXIT;      

Calc_Cyl_AirMass:
//                                                                                    //
//  Calc cyl mass charge from bank mass flow and RPM                                  //
//  Input  = R3e Bank Flow (half after scaler [around 3410] ?)                        //
//  Answer = R3c Cyl Charge, limit checked (grams air ?)                              //
//  R3c = (R3c*65536/(RPMx4))/6                                                       //
//  ANS = (Bank Charge*65536/RPMx4)/6.                                                //
//  #                                                                                 //
//  VAF feeds 1 bank, 3 cyls, injects every rev.                                      //
//  so cyl charge = (Mass*16384)/(RPM*6) = Mass*8196/(rpm*3)                          //
//  4000 IN at 1000 rpm in gives 10927 out (= 1 litre cyl charge)                     //
//  implying that 4000 in = 1500 L/min bank flow ?                                    //
//                                                                                    //
//  for double length div of R3e                                                      //
8 346c: 01,3c                clrw  R3c                R3c = 0;             
//  R3e = Bank_Mass_Flow*32768/RPMx4                                                  //
8 346e: 8c,70,3c             divw  R3c,R70            R3c = R3cL / [RPM];  
8 3471: dd,16                jv    3489               if (OV) goto 3489;   
//  safety clamp ?                                                                    //
8 3473: 01,3e                clrw  R3e                R3e = 0;             
//  Not set - do this part                                                            //
8 3475: 3a,30,06             jb    B2,R30,347e        if (B2_R30) goto 347e;
//  R3c = Bnk_Mass*16384/(RPM*6)=> cyl charge                                         //
8 3478: 8d,06,00,3c          divw  R3c,6              R3c = R3cL / 6;      
8 347c: 20,04                sjmp  3482               goto 3482;           

347e - Sub 8 347e:
8 347e: 8d,0c,00,3c          divw  R3c,c              R3c = R3cL / c;      
8 3482: 8b,01,20,24,3c       cmpw  R3c,[2420]                              
8 3487: d1,08                jleu  3491               if ((uns) R3c <= [CylChMax]) goto 3491;
8 3489: a3,01,20,24,3c       ldw   R3c,[2420]         R3c = [CylChMax];    
8 348e: 91,01,69             orrb  R69,1              [OVF_flags].VAF_OVF = 1;
8 3491: 33,2c,0c             jnb   B3,R2c,34a0        if ([RPM_flags].Knock_Risk == 0) goto 34a0;
8 3494: 8b,01,22,24,3c       cmpw  R3c,[2422]                              
8 3499: db,05                jc    34a0               if ((uns) R3c >= [CylChKMin]) goto 34a0;
8 349b: a3,01,22,24,3c       ldw   R3c,[2422]         R3c = [CylChKMin];   
8 34a0: f0                   ret                      return;              

Base_Cyl_Inj_calc:
//                                                                                                 //
//  base injection time calc                                                                       //
//  Input  = R3c, Cyl mass flow (half ?  scaled 65536 = 6 Litres ?)                                //
//  Output = R3c, Base inject time                                                                 //
//  CALC   = (R3c * 2238)/ (INJECT_SIZE * 16384/65536)                                             //
//                                                                                                 //
//  this is AFTER RPM calc included (i.e. = True Cyl charge)                                       //
//  Later inj calc (at 38ba) is effectively 1:1 with no enrichments where 32768 = 125ms injection  //
//  so calc becomes                                                                                //
//  INJECT Time = (cyl_mass*4 /14.64)/INJECT_SIZE                                                  //
//  #                                                                                              //
//  Notes:                                                                                         //
//  92112 in gives 32768 (125mS) out, or 0.3479cc (0.252 grams ?)                                  //
//  5872 (max cyl_charge ?) gives 8mS (0.022 cc or 0.016gms ?)                                     //
//  if 2 injections = 0.044 cc, implies 10.5:1 max fuel mixture                                    //
//  10924 = 1 litre air charge (1.208g) for TWO injection events (ans 3886)                        //
//  10924*6 = 65544 (within 0.001% of 65536) implying that scale (in) is 65536 = 6 litres.         //
//  5083 gives 6.9mS for 100% VE charge at 14.64:1 (ans = 1808)                                    //
//  R22 is fixed, but is probably adjusted ratio if this vehicle had an EGO ?                      //
//                                                                                                 //
8 34a1: 6d,be,08,3c          ml2w  R3c,8be            R3c *= 8be;          
8 34a5: a3,01,1e,24,34       ldw   R34,[241e]         R34 = [InjSize];     
//  R22 = 0x4000 (16384)                                                              //
8 34aa: 6c,22,34             ml2w  R34,R22            R34 *= [Inj_Scaler]; 
//  R34 = Injector size/4                                                             //
8 34ad: a0,36,34             ldw   R34,R36            R34 = R36;           
8 34b0: 8c,34,3c             divw  R3c,R34            R3c = R3cL / R34;    
8 34b3: d5,08                jnv   34bd               if (!OV) goto 34bd;  
8 34b5: a3,01,a4,24,3c       ldw   R3c,[24a4]         R3c = [InjMax];      
8 34ba: 91,01,69             orrb  R69,1              [OVF_flags].VAF_OVF = 1;
8 34bd: f0                   ret                      return;              

Set_RPM_flags:
//                                                                                    //
//  set various flags against RPM, checks for Cranking, underspeed,                   //
//  fuel clip (clsosing throttle) , knock risk etc                                    //
//                                                                                    //
8 34be: b3,01,29,24,34       ldb   R34,[2429]         R34 = [RPM_CLC_0];   
8 34c3: 99,00,34             cmpb  R34,0                                   
//  always JUMPS                                                                      //
8 34c6: df,2f                je    34f7               if (R34 == 0) goto 34f7;
//                     code ignored to 34f5                                           //
8 34c8: 11,2c                clrb  R2c                [RPM_flags] = 0;     
8 34ca: 3f,34,05             jb    B7,R34,34d2        if (B7_R34) goto 34d2;
8 34cd: 71,3f,1a             an2b  R1a,3f             [IgnFlags] &= 3f;    
8 34d0: 20,15                sjmp  34e7               goto 34e7;           

8 34d2: 3f,1a,0c             jb    B7,R1a,34e1        if ([IgnFlags].Cranking == 1) goto 34e1;
8 34d5: 8b,01,6c,24,c0       cmpw  Rc0,[246c]                              
8 34da: d3,05                jnc   34e1               if ((uns) [Cranktime] < [Stall_Ctime]) goto 34e1;
8 34dc: a3,01,6c,24,c0       ldw   Rc0,[246c]         [Cranktime] = [Stall_Ctime];
8 34e1: 91,80,1a             orrb  R1a,80             [IgnFlags].Cranking = 1;
8 34e4: 71,bf,1a             an2b  R1a,bf             [IgnFlags].Underspeed = 0;
8 34e7: 36,34,05             jnb   B6,R34,34ef        if (!B6_R34) goto 34ef;
8 34ea: 91,40,1a             orrb  R1a,40             [IgnFlags].Underspeed = 1;
8 34ed: 20,a8                sjmp  3597               goto main_seq;       

8 34ef: b0,34,2c             ldb   R2c,R34            [RPM_flags] = R34;   
8 34f2: 71,3f,2c             an2b  R2c,3f             [RPM_flags] &= 3f;   
8 34f5: 20,a0                sjmp  3597               goto main_seq;       

34f7 - Sub 8 34f7:
8 34f7: a3,01,10,24,30       ldw   R30,[2410]         R30 = [CnkSetRPM];   
8 34fc: 37,1a,0c             jnb   B7,R1a,350b        if ([IgnFlags].Cranking == 0) goto 350b;
8 34ff: 67,01,ae,24,30       ad2w  R30,[24ae]         R30 += [CrankHystRPM];
8 3504: 88,30,70             cmpw  R70,R30                                 
//  cranking cleared at 500 rpm, underspeed set.                                      //
8 3507: d9,24                jgtu  352d               if ((uns) [RPM] > R30) goto 352d;
8 3509: 20,8c                sjmp  3597               goto main_seq;       

8 350b: 36,1a,29             jnb   B6,R1a,3537        if ([IgnFlags].Underspeed == 0) goto 3537;
8 350e: 88,30,70             cmpw  R70,R30                                 
8 3511: d9,13                jgtu  3526               if ((uns) [RPM] > R30) goto 3526;
//  flags set if below 450 rpm                                                        //
8 3513: 91,c0,1a             orrb  R1a,c0             [IgnFlags] |= c0;    
8 3516: 11,2c                clrb  R2c                [RPM_flags] = 0;     
8 3518: 8b,01,6c,24,c0       cmpw  Rc0,[246c]                              
8 351d: d3,78                jnc   3597               if ((uns) [Cranktime] < [Stall_Ctime]) goto main_seq;
//  fail to start or stall ?                                                          //
8 351f: a3,01,6c,24,c0       ldw   Rc0,[246c]         [Cranktime] = [Stall_Ctime];
8 3524: 20,71                sjmp  3597               goto main_seq;       

8 3526: 8b,01,12,24,70       cmpw  R70,[2412]                              
8 352b: d9,11                jgtu  353e               if ((uns) [RPM] > [UspClrRPM]) goto 353e;

352d - Sub 8 352d:
8 352d: 71,7f,1a             an2b  R1a,7f             [IgnFlags].Cranking = 0;
8 3530: 91,40,1a             orrb  R1a,40             [IgnFlags].Underspeed = 1;
8 3533: 11,2c                clrb  R2c                [RPM_flags] = 0;     
8 3535: 20,60                sjmp  3597               goto main_seq;       

8 3537: 8b,01,14,24,70       cmpw  R70,[2414]                              
8 353c: d3,ef                jnc   352d               if ((uns) [RPM] < [UspSetRPM]) goto 352d;

353e - Sub 8 353e:
8 353e: 71,3f,1a             an2b  R1a,3f             [IgnFlags] &= 3f;    
8 3541: 9b,01,28,24,9f       cmpb  R9f,[2428]                              
8 3546: d6,0a                jge   3552               if ((sig) [ECT_start] >= [C80deg]) goto 3552;
8 3548: 88,24,ea             cmpw  Rea,R24                                 
8 354b: db,05                jc    3552               if ((uns) [Run_Time] >= [Coldstart_secs]) goto 3552;
//  Set $2c:0                                                                         //
8 354d: b1,01,2c             ldb   R2c,1              [RPM_flags] = 1;     
8 3550: 20,45                sjmp  3597               goto main_seq;       

8 3552: 30,20,37             jnb   B0,R20,358c        if ([TPS_flags].TPS_Closed == 0) goto 358c;
8 3555: 3a,2c,07             jb    B2,R2c,355f        if ([RPM_flags].Fuel_Clip == 1) goto 355f;
8 3558: 8b,01,16,24,70       cmpw  R70,[2416]                              
8 355d: db,11                jc    3570               if ((uns) [RPM] >= [RPM_1500]) goto 3570;
8 355f: 8b,01,18,24,70       cmpw  R70,[2418]                              
8 3564: db,26                jc    358c               if ((uns) [RPM] >= [RPM_1800]) goto 358c;
//  RPM < 1800, throttle closed. Clip fuel instead of cutoff.                         //
8 3566: 31,2c,02             jnb   B1,R2c,356b        if ([RPM_flags].No_Fuel == 0) goto 356b;
8 3569: 01,4e                clrw  R4e                [FuelClip_timer] = 0;

356b - Sub 8 356b:
8 356b: b1,04,2c             ldb   R2c,4              [RPM_flags] = 4;     
8 356e: 20,27                sjmp  3597               goto main_seq;       

3570 - Sub 8 3570:
8 3570: 9b,01,1a,24,9f       cmpb  R9f,[241a]                              
8 3575: d2,10                jgt   3587               if ((sig) [ECT_start] > [C250deg]) goto 3587;
8 3577: 9b,01,1b,24,9f       cmpb  R9f,[241b]                              
8 357c: da,09                jle   3587               if ((sig) [ECT_start] <= [C-40deg]) goto 3587;
8 357e: 8b,01,1c,24,ea       cmpw  Rea,[241c]                              
8 3583: d9,02                jgtu  3587               if ((uns) [Run_Time] > [Tmr_Lim_0]) goto 3587;
8 3585: 27,d8                sjmp  355f               goto 355f;           

3587 - Sub 8 3587:
8 3587: b1,02,2c             ldb   R2c,2              [RPM_flags] = 2;     
8 358a: 20,0b                sjmp  3597               goto main_seq;       

358c - Sub 8 358c:
8 358c: 32,20,05             jnb   B2,R20,3594        if ([TPS_flags].TPS_Wide == 0) goto 3594;
//  set $2c:3 if > 1800 RPM.  Others = 0                                              //
8 358f: b1,08,2c             ldb   R2c,8              [RPM_flags] = 8;     
8 3592: 20,03                sjmp  3597               goto main_seq;       

3594 - Sub 8 3594:
8 3594: b1,10,2c             ldb   R2c,10             [RPM_flags] = 10;    

main_seq:
8 3597: 01,30                clrw  R30                R30 = 0;             
//  get $1a:6 and $1a:7                                                               //
8 3599: 51,c0,1a,30          an3b  R30,R1a,c0         R30 = [IgnFlags] & c0;
8 359d: 90,2c,30             orrb  R30,R2c            R30 |= [RPM_flags];  
8 35a0: 32,5a,04             jnb   B2,R5a,35a7        if ([Svc_flags].PUMP_Reqd == 0) goto 35a7;
8 35a3: 81,00,01,30          orrw  R30,100            R30 |= 100;          
8 35a7: 88,00,18             cmpw  R18,0                                   
8 35aa: df,04                je    35b0               if ([Fail_flags] == 0) goto 35b0;
//  now have pump, fail, etc flags in one word                                        //
8 35ac: 81,00,02,30          orrw  R30,200            R30 |= 200;          

35b0 - Sub 8 35b0:
8 35b0: c3,01,5a,01,30       stw   [15a],R30          [DBG_Rpm_Flags] = R30;
8 35b5: e7,00,f6             jump  2bb8               goto Main_EXIT;      

Enrich_Flow_calc:
//                                                                                    //
//  Compensate base flow (from cyl) for ECT and other                                 //
//  Note that Inj_slope is added to inj time so must also be calibrated               //
//  as 0-32768 -> 0-125mS ...                                                         //
//                                                                                    //
//                                                                                    //
8 35b8: a1,9c,27,32          ldw   R32,279c           R32 = Inj_slope;     
//  Vss-Val used only here                                                            //
8 35bc: a0,52,34             ldw   R34,R52            R34 = [VBATT];       
8 35bf: ef,fa,fc             call  32bc               UUWordLU();          
//  Inj_slope set only here                                                           //
8 35c2: a0,38,50             ldw   R50,R38            [Inj_slope] = R38;   
8 35c5: a1,38,28,32          ldw   R32,2838           R32 = ECT_SCALE_11;  
8 35c9: b0,72,35             ldb   R35,R72            R35 = [ECT_val];     
8 35cc: 11,34                clrb  R34                R34 = 0;             
8 35ce: ef,ee,fc             call  32bf               SSWordLU();          
//  R6a scaled ECT 0 - 11                                                             //
8 35d1: a0,38,6a             ldw   R6a,R38            R6a = R38;           
8 35d4: a1,31,25,ba          ldw   Rba,2531           Rba = Cold_Enrich;   
8 35d8: a0,62,34             ldw   R34,R62            R34 = [Cyl_Mass_BK1];
8 35db: ef,a7,01             call  3785               enrich_viaECT_calc();
//  64 is 'base' answer                                                               //
8 35de: a0,3a,6e             ldw   R6e,R3a            [ECT_comp_BK1] = R3a;
8 35e1: a1,31,25,ba          ldw   Rba,2531           Rba = Cold_Enrich;   
8 35e5: a0,64,34             ldw   R34,R64            R34 = [Cyl_Mass_BK2];
8 35e8: ef,9a,01             call  3785               enrich_viaECT_calc();
8 35eb: a0,3a,a0             ldw   Ra0,R3a            [ECT_comp_BK2] = R3a;
//  set 16384 if cranking                                                             //
8 35ee: a1,00,40,a2          ldw   Ra2,4000           [Enrich_factor] = 4000;
8 35f2: 3f,1a,49             jb    B7,R1a,363e        if ([IgnFlags].Cranking == 1) goto endfunc;
8 35f5: a1,cc,27,32          ldw   R32,27cc           R32 = ECT_Time_temp; 
8 35f9: b0,72,34             ldb   R34,R72            R34 = [ECT_val];     
8 35fc: ef,a0,f9             call  2f9f               SSByteLU();          
//  Time lookup from ECT                                                              //
8 35ff: ac,38,a4             ldzbw Ra4,R38            [ECT_PAR_X] = (uns)R38;
8 3602: 88,ea,a4             cmpw  Ra4,Rea                                 
8 3605: d1,37                jleu  363e               if ((uns) [ECT_PAR_X] <= [Run_Time]) goto endfunc;
8 3607: a1,b4,27,32          ldw   R32,27b4           R32 = ECT_Mult_temp; 
8 360b: b0,72,34             ldb   R34,R72            R34 = [ECT_val];     
8 360e: ef,8e,f9             call  2f9f               SSByteLU();          
8 3611: ac,38,3a             ldzbw R3a,R38            R3a = (uns)R38;      
8 3614: 09,01,3a             shlw  R3a,1              R3a = R3a * 2;       
8 3617: 4c,ea,3a,34          ml3w  R34,R3a,Rea        R34 = R3a * [Run_Time];
8 361b: 8c,a4,34             divw  R34,Ra4            R34 = R34L / [ECT_PAR_X];
8 361e: d5,05                jnv   3625               if (!OV) goto 3625;  
8 3620: 91,08,69             orrb  R69,8              [OVF_flags].Flow_OVF = 1;
8 3623: 20,19                sjmp  363e               goto endfunc;        

8 3625: 09,07,3a             shlw  R3a,7              R3a = R3a * 80;      
8 3628: 65,00,40,3a          ad2w  R3a,4000           R3a += 4000;         
8 362c: db,09                jc    3637               if (R3a > ffff) goto 3637;
8 362e: 09,07,34             shlw  R34,7              R34 = R34 * 80;      
//  Ra2 then used in InjCalc    (38ba)                                                //
8 3631: 48,34,3a,a2          sb3w  Ra2,R3a,R34        [Enrich_factor] = R3a - R34;
8 3635: db,07                jc    363e               if ([Enrich_factor] >= 0) goto endfunc;
8 3637: a1,00,40,a2          ldw   Ra2,4000           [Enrich_factor] = 4000;
8 363b: 91,08,69             orrb  R69,8              [OVF_flags].Flow_OVF = 1;

endfunc:
8 363e: e7,77,f5             jump  2bb8               goto Main_EXIT;      

Cranking_Inj_Calc:
//                                                                                    //
//     Cranking calculation ?                                                         //
//                                                                                    //
8 3641: b0,97,34             ldb   R34,R97            R34 = [VAF1_raw/256];
8 3644: 35,18,0b             jnb   B5,R18,3652        if ([Fail_flags].VAF1Fail == 0) goto 3652;
8 3647: b0,7f,34             ldb   R34,R7f            R34 = [VAF2_raw/256];
8 364a: 31,18,05             jnb   B1,R18,3652        if ([Fail_flags].VAF2Fail == 0) goto 3652;
8 364d: b3,01,3b,24,34       ldb   R34,[243b]         R34 = [VAF_Coarse_dflt];
8 3652: 29,7c                scall 37d0               Crank_Inj_calc();    
8 3654: c3,01,60,01,38       stw   [160],R38          [Inj_Crank_Time] = R38;
8 3659: a0,3c,a6             ldw   Ra6,R3c            [VAF1_coarse_Val] = R3c;
8 365c: b0,7f,34             ldb   R34,R7f            R34 = [VAF2_raw/256];
8 365f: 31,18,0b             jnb   B1,R18,366d        if ([Fail_flags].VAF2Fail == 0) goto 366d;
8 3662: b0,97,34             ldb   R34,R97            R34 = [VAF1_raw/256];
8 3665: 35,18,05             jnb   B5,R18,366d        if ([Fail_flags].VAF1Fail == 0) goto 366d;
8 3668: b3,01,3b,24,34       ldb   R34,[243b]         R34 = [VAF_Coarse_dflt];
8 366d: 29,61                scall 37d0               Crank_Inj_calc();    
8 366f: c3,01,60,01,38       stw   [160],R38          [Inj_Crank_Time] = R38;
8 3674: a0,3c,bc             ldw   Rbc,R3c            [VAF2_coarse_Val] = R3c;
8 3677: 3f,1a,06             jb    B7,R1a,3680        if ([IgnFlags].Cranking == 1) goto 3680;
8 367a: b1,10,da             ldb   Rda,10             [Par_16_BK1] = 10;   
8 367d: b1,10,db             ldb   Rdb,10             [Par_16_BK2] = 10;   
8 3680: e7,35,f5             jump  2bb8               goto Main_EXIT;      

Calc_Accelpump:
//                                                                                    //
//  Accel pump (top level) Calculation                                                //
//  includes cranking check                                                           //
//  base is 128 so no enrich whilst cranking                                          //
//                                                                                    //
//                                                                                    //
8 3683: 37,1a,08             jnb   B7,R1a,368e        if ([IgnFlags].Cranking == 0) goto 368e;
8 3686: b1,80,dc             ldb   Rdc,80             [APenr_BK1] = 80;    
//  fix value if cranking 1:1 (128)                                                   //
8 3689: b1,80,dd             ldb   Rdd,80             [APenr_BK2] = 80;    
8 368c: 20,43                sjmp  36d1               goto endfunc;        

8 368e: a0,e2,32             ldw   R32,Re2            R32 = [Last_TPS_Pos_BK1];
8 3691: a0,aa,b8             ldw   Rb8,Raa            Rb8 = [TPS_Posn];    
8 3694: b0,dc,3e             ldb   R3e,Rdc            R3e = [APenr_BK1];   
8 3697: a0,a6,3c             ldw   R3c,Ra6            R3c = [VAF1_coarse_Val];
8 369a: a0,de,30             ldw   R30,Rde            R30 = [Accl_Timer_BK1];
8 369d: a0,ca,ba             ldw   Rba,Rca            Rba = [ACL_Enrich_BK1];
8 36a0: 29,82                scall 3824               Accel_pump();        
8 36a2: 3f,3f,0c             jb    B7,R3f,36b1        if (B7_R3f) goto 36b1;
//  NEW accel pump values to save                                                     //
8 36a5: b0,3e,dc             ldb   Rdc,R3e            [APenr_BK1] = R3e;   
8 36a8: a0,aa,e2             ldw   Re2,Raa            [Last_TPS_Pos_BK1] = [TPS_Posn];
8 36ab: a0,ba,ca             ldw   Rca,Rba            [ACL_Enrich_BK1] = Rba;
8 36ae: a0,30,de             ldw   Rde,R30            [Accl_Timer_BK1] = R30;
8 36b1: a0,e4,32             ldw   R32,Re4            R32 = [Last_TPS_Pos_BK2];
8 36b4: b0,dd,3e             ldb   R3e,Rdd            R3e = [APenr_BK2];   
8 36b7: a0,bc,3c             ldw   R3c,Rbc            R3c = [VAF2_coarse_Val];
8 36ba: a0,e0,30             ldw   R30,Re0            R30 = [Accl_Timer_BK2];
8 36bd: a0,cc,ba             ldw   Rba,Rcc            Rba = [ACL_enrich_BK2];
8 36c0: 29,62                scall 3824               Accel_pump();        
//  NEW accel pump values to save                                                     //
8 36c2: 3f,3f,0c             jb    B7,R3f,36d1        if (B7_R3f) goto endfunc;
8 36c5: b0,3e,dd             ldb   Rdd,R3e            [APenr_BK2] = R3e;   
8 36c8: a0,aa,e4             ldw   Re4,Raa            [Last_TPS_Pos_BK2] = [TPS_Posn];
8 36cb: a0,ba,cc             ldw   Rcc,Rba            [ACL_enrich_BK2] = Rba;
8 36ce: a0,30,e0             ldw   Re0,R30            [Accl_Timer_BK2] = R30;

endfunc:
8 36d1: e7,e4,f4             jump  2bb8               goto Main_EXIT;      

Load_Calc:
//                                                                                    //
//                                                                                    //
8 36d4: a1,b8,24,3c          ldw   R3c,24b8           R3c = 24b8;          
8 36d8: a0,62,30             ldw   R30,R62            R30 = [Cyl_Mass_BK1];
8 36db: ef,c7,00             call  37a5               Load_lookup();       
8 36de: b0,3b,28             ldb   R28,R3b            [Load_BK1] = R3b;    
8 36e1: a1,b8,24,3c          ldw   R3c,24b8           R3c = 24b8;          
8 36e5: a0,64,30             ldw   R30,R64            R30 = [Cyl_Mass_BK2];
8 36e8: ef,ba,00             call  37a5               Load_lookup();       
8 36eb: b0,3b,29             ldb   R29,R3b            [Load_BK2] = R3b;    
8 36ee: e7,c7,f4             jump  2bb8               goto Main_EXIT;      

Clip_Inj_Calc:
//                                                                                    //
//  Fuel Clip calculation                                                             //
//  weaken mixture for timer7 if flag set. (600 mS)                                   //
//  R30 = 64 (dflt) base = 64 (see later)                                             //
//  R30 -= 58, R30 = 6.                                                               //
//  (timer7 * 6)/600 + 58 while timer7 < 600mS                                        //
//  i.e. 58 - 64 in 600mS (1 per 100mS)                                               //
//  This proc weakens mixture by 10% instantly, gradually raising back                //
//  to 100% after time expired (600mS). triggered when throttle closing               //
//  so prevents over rich mix (and surge ?)                                           //
//                                                                                    //
8 36f1: b1,40,30             ldb   R30,40             R30 = 40;            
8 36f4: 32,2c,1b             jnb   B2,R2c,3712        if ([RPM_flags].Fuel_Clip == 0) goto 3712;
8 36f7: 8b,01,60,24,4e       cmpw  R4e,[2460]                              
8 36fc: db,14                jc    3712               if ((uns) [FuelClip_timer] >= [600mSec]) goto 3712;
8 36fe: 7b,01,62,24,30       sb2b  R30,[2462]         R30 -= [Snip_58];    
8 3703: 11,31                clrb  R31                R31 = 0;             
8 3705: 6c,4e,30             ml2w  R30,R4e            R30 *= [FuelClip_timer];
8 3708: 8f,01,60,24,30       divw  R30,[2460]         R30 = R30L / [600mSec];
8 370d: 77,01,62,24,30       ad2b  R30,[2462]         R30 += [Snip_58];    
8 3712: c7,01,59,01,30       stb   [159],R30          [Inject_Clip] = R30; 
8 3717: e7,9e,f4             jump  2bb8               goto Main_EXIT;      

Inject_Time_calc:
//                                                                                    //
//     Master Inject Time Calculation                                                 //
//                                                                                    //
8 371a: a0,ce,32             ldw   R32,Rce            R32 = [Inj_Cyl_BK1]; 
8 371d: b0,28,2b             ldb   R2b,R28            R2b = [Load_BK1];    
//  64 by default                                                                     //
8 3720: a0,6e,ba             ldw   Rba,R6e            Rba = [ECT_comp_BK1];
8 3723: b0,dc,3e             ldb   R3e,Rdc            R3e = [APenr_BK1];   
8 3726: b0,da,b8             ldb   Rb8,Rda            Rb8 = [Par_16_BK1];  
8 3729: a3,01,60,01,38       ldw   R38,[160]          R38 = [Inj_Crank_Time];
8 372e: 29,8a                scall 38ba               Main_Inj_Calc();     
//  used only here (debug)                                                            //
8 3730: c3,01,4a,01,30       stw   [14a],R30          [DBG_BK1_Par] = R30; 
8 3735: a0,3a,c6             ldw   Rc6,R3a            [Length_BK1] = R3a;  
8 3738: a0,d0,32             ldw   R32,Rd0            R32 = [Inj_Cyl_BK2]; 
8 373b: b0,29,2b             ldb   R2b,R29            R2b = [Load_BK2];    
8 373e: a0,a0,ba             ldw   Rba,Ra0            Rba = [ECT_comp_BK2];
8 3741: b0,dd,3e             ldb   R3e,Rdd            R3e = [APenr_BK2];   
8 3744: b0,db,b8             ldb   Rb8,Rdb            Rb8 = [Par_16_BK2];  
8 3747: a3,01,60,01,38       ldw   R38,[160]          R38 = [Inj_Crank_Time];
8 374c: 29,6c                scall 38ba               Main_Inj_Calc();     
//  used only here    (debug)                                                         //
8 374e: c3,01,4c,01,30       stw   [14c],R30          [DBG_BK2_Par] = R30; 
8 3753: a0,3a,d8             ldw   Rd8,R3a            [Length_BK2] = R3a;  
8 3756: b3,01,4c,24,30       ldb   R30,[244c]         R30 = [FLGS_B3_B0];  
8 375b: 3a,30,05             jb    B2,R30,3763        if (B2_R30) goto 3763;
8 375e: 3b,30,07             jb    B3,R30,3768        if (B3_R30) goto 3768;
8 3761: 20,1f                sjmp  3782               goto 3782;           

8 3763: a0,c6,d8             ldw   Rd8,Rc6            [Length_BK2] = [Length_BK1];
8 3766: 20,1a                sjmp  3782               goto 3782;           

3768 - Sub 8 3768:
8 3768: 4d,74,cb,50,34       ml3w  R34,R50,cb74       R34 = [Inj_slope] * cb74;
//  R30 = Bnk1Length - Inj_slope (true ticks)                                         //
8 376d: 48,36,c6,30          sb3w  R30,Rc6,R36        R30 = [Length_BK1] - R36;
8 3771: 6f,01,a0,24,30       ml2w  R30,[24a0]         R30 *= [InjScaler];  
//  R30 *= 65536, R32 = R30;                                                          //
8 3776: 0d,02,30             shldw R30,2              R30L = R30L * 4;     
8 3779: 67,01,a2,24,32       ad2w  R32,[24a2]         R32 += [InjTrimB2];  
//  Bnk2 = Bnk1 + Inj_slope + 13 (Why ? crankcase breather ?)                         //
8 377e: 44,32,36,d8          ad3w  Rd8,R36,R32        [Length_BK2] = R36 + R32;
8 3782: e7,33,f4             jump  2bb8               goto Main_EXIT;      

enrich_viaECT_calc:
//                                                                                    //
//  Calculate Enrich_factor (choke equiv?) from Cyl mass Flow and ECT                 //
//  called separately for each bank (- 35db, 35e8)                                    //
//  Inputs                                                                            //
//  R6a is scaled ECT (0-11)                                                          //
//  R34 is Cyl_Flow                                                                   //
//  Rba is LU table (always 2531) 12 rows...                                          //
//  Tablookup answer in R3b (32 for hot engine) gives R3a                             //
//  Output in R3a - 16384 for hot engine                                              //
//                                                                                    //
8 3785: a1,a0,28,32          ldw   R32,28a0           R32 = FLOW_SCALE_5;  
8 3789: ef,30,fb             call  32bc               UUWordLU();          
8 378c: a0,38,6c             ldw   R6c,R38            R6c = R38;           
8 378f: a0,6a,30             ldw   R30,R6a            R30 = R6a;           
8 3792: a0,6c,32             ldw   R32,R6c            R32 = R6c;           
8 3795: a1,0c,00,34          ldw   R34,c              R34 = c;             
8 3799: a0,ba,38             ldw   R38,Rba            R38 = Rba;           
//   answer in R3b (32 for hot engine)                                                //
8 379c: ef,d8,fa             call  3277               UTabLU();            
8 379f: 11,3a                clrb  R3a                R3a = 0;             
//  WORD answer = table LU*2*256 (16384 hot)                                          //
8 37a1: 09,01,3a             shlw  R3a,1              R3a = R3a * 2;       
8 37a4: f0                   ret                      return;              

Load_lookup:
//                                                                                    //
//  Base injection Lookup                                                             //
//  scales flow, rpm and looks up in LOAD table.                                      //
//  Answer in R3b. called separately for each bank (36d4)                             //
//                                                                                    //
8 37a5: a1,58,28,32          ldw   R32,2858           R32 = RPM_SCALE_10;  
8 37a9: a0,70,34             ldw   R34,R70            R34 = [RPM];         
8 37ac: ef,0d,fb             call  32bc               UUWordLU();          
8 37af: a0,38,6a             ldw   R6a,R38            R6a = R38;           
8 37b2: a1,74,28,32          ldw   R32,2874           R32 = FLOW_SCALE_10; 
8 37b6: a0,30,34             ldw   R34,R30            R34 = R30;           
8 37b9: ef,00,fb             call  32bc               UUWordLU();          
8 37bc: a0,38,6c             ldw   R6c,R38            R6c = R38;           
8 37bf: a0,6a,30             ldw   R30,R6a            R30 = R6a;           
8 37c2: a0,6c,32             ldw   R32,R6c            R32 = R6c;           
8 37c5: a1,0b,00,34          ldw   R34,b              R34 = b;             
8 37c9: a0,3c,38             ldw   R38,R3c            R38 = R3c;           
8 37cc: ef,a8,fa             call  3277               UTabLU();            
8 37cf: f0                   ret                      return;              

Crank_Inj_calc:
//                                                                                    //
//  Cranking PW calculation                                                           //
//  Input is R34 top of VAF Raw (VAF coarse )                                         //
//  ANSWERS                                                                           //
//  R3c plain answer to lookup table from VAF Coarse...                               //
//  ONLY IF FLAG SET - (Cranking )                                                    //
//  R38 is scaled as main Inj Calc where                                              //
//     0-32768 maps to 0-125mS injection time                                         //
//     R38 in 3.8147 uS units (262 ~ 1 mS).                                           //
//                                                                                    //
//     R38 = Crank_LU * Crank_Fuel(ECT,Timer) * 83/32;                                //
//  as Crank_LU appears base 96 ?, then this is Crank_Fuel * 249                      //
//                                                                                    //
8 37d0: a1,e4,27,32          ldw   R32,27e4           R32 = VAF_Coarse_TFR;
8 37d4: ef,c5,f7             call  2f9c               UUByteLU();          
//  R3c used as answer (~3641)                                                        //
8 37d7: ac,38,3c             ldzbw R3c,R38            R3c = (uns)R38;      
8 37da: 37,1a,46             jnb   B7,R1a,3823        if ([IgnFlags].Cranking == 0) goto 3823;
//  Crank PW calc from here                                                           //
8 37dd: a0,70,34             ldw   R34,R70            R34 = [RPM];         
8 37e0: a1,f0,2a,32          ldw   R32,2af0           R32 = RPM_Crank_LU;  
8 37e4: ef,d5,fa             call  32bc               UUWordLU();          
//  base is 128 ?                                                                     //
8 37e7: b0,38,b9             ldb   Rb9,R38            Rb9 = R38;           
8 37ea: a1,38,28,32          ldw   R32,2838           R32 = ECT_SCALE_11;  
8 37ee: b0,72,35             ldb   R35,R72            R35 = [ECT_val];     
8 37f1: 11,34                clrb  R34                R34 = 0;             
8 37f3: ef,c9,fa             call  32bf               SSWordLU();          
8 37f6: a0,38,3e             ldw   R3e,R38            R3e = R38;           
8 37f9: a1,d0,2a,32          ldw   R32,2ad0           R32 = SCALE_CrankTime;
8 37fd: a0,c0,34             ldw   R34,Rc0            R34 = [Cranktime];   
8 3800: ef,b9,fa             call  32bc               UUWordLU();          
8 3803: a0,38,32             ldw   R32,R38            R32 = R38;           
8 3806: a0,3e,30             ldw   R30,R3e            R30 = R3e;           
8 3809: a1,0c,00,34          ldw   R34,c              R34 = c;             
8 380d: a1,54,27,38          ldw   R38,2754           R38 = Cranking_Fuel; 
8 3811: ef,63,fa             call  3277               UTabLU();            
8 3814: 5c,3b,b9,38          ml3b  R38,Rb9,R3b        R38 = Rb9 * R3b;     
8 3818: af,01,26,24,34       ldzbw R34,[2426]         R34 = (uns)[EmgyEnrich];
8 381d: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 3820: 0c,05,38             shrdw R38,5              R38L = R38L / 20;    
8 3823: f0                   ret                      return;              

Accel_pump:
//                                                                                                      //
//  Accel Pump Enrichment - called PER BANK                                                             //
//  Appears base scale (1:1) is 128 with min of 9 (7%), max of 64 (50% enrich)                          //
//  Calc below would define accel pump runtime is 1 sec (1008 mS) if no TPS change,                     //
//  and Rba is a 'Calc Enrich Factor' which is about 5.2 times (512/1008) ? the actual                  //
//  enrich to feed into the linear reduction calcuation, effectively (1 sec - runtime) * Enrich factor  //
//  Params - (apart from TPS_angle, these are PER BANK)                                                 //
//  #                                                                                                   //
//  IN     Rb8 = TPS_angle                                                                              //
//  IN/OUT R32 = (Bx_last_TPS) Last TPS angle                                                           //
//  #                                                                                                   //
//  IN/OUT R3e = (BxAclEnr)   Enrichment factor, used in MAIN injection Calc                            //
//  IN/OUT R3c = (VAFx_coarse) Coarse VAF value (base 256 ?)                                            //
//  IN/OUT R30 = (BxAccel_timer) Timer per bank (mS)                                                    //
//  IN/OUT Rba = (BXAccel_Factor) Original calc, ~5 times enrich                                        //
//  #                                                                                                   //
//  OUT    B7 R3f no change to enrich values if set                                                     //
//                                                                                                      //
8 3824: 11,3f                clrb  R3f                R3f = 0;             
8 3826: af,01,3f,24,38       ldzbw R38,[243f]         R38 = (uns)[AccelP_min_Time];
8 382b: 88,38,30             cmpw  R30,R38                                 
//  remaining bank timer >= 30mS ?                                                    //
8 382e: db,07                jc    3837               if ((uns) R30 >= R38) goto Accel_recalc;
8 3830: 99,80,3e             cmpb  R3e,80                                  
//  If Enriching, jump to snip_calc to fade away the enrich                           //
8 3833: d9,55                jgtu  388a               if ((uns) R3e > 80) goto Reduce_Accel_pump;
8 3835: 20,7f                sjmp  38b6               goto No_Pchange;     

Accel_recalc:
//        here if accel timers > 30mS                                                 //

Accel_recalc:
//  New TPS position (Angle) for this bank                                            //
8 3837: 48,32,b8,38          sb3w  R38,Rb8,R32        R38 = Rb8 - R32;     
8 383b: db,02                jc    383f               if (R38 >= 0) goto 383f;
8 383d: 01,38                clrw  R38                R38 = 0;             
8 383f: a3,01,24,24,34       ldw   R34,[2424]         R34 = [TP_Accel_min];
//  R34 = 320 (0.025V)                                                                //
8 3844: 08,02,34             shrw  R34,2              R34 = R34 / 4;       
8 3847: 88,34,38             cmpw  R38,R34                                 
//  Not enough change...                                                              //
8 384a: d3,3e                jnc   388a               if ((uns) R38 < R34) goto Reduce_Accel_pump;
//  accel pump calc                                                                   //
8 384c: a1,00,01,34          ldw   R34,100            R34 = 100;           
//  R34 = 256 - FLow (VAF_Coarse)                                                     //
8 3850: 68,3c,34             sb2w  R34,R3c            R34 -= R3c;          
8 3853: a1,02,28,32          ldw   R32,2802           R32 = Accel_LU;      
8 3857: ef,42,f7             call  2f9c               UUByteLU();          
//  always returns 131                                                                //
8 385a: b0,38,af             ldb   Raf,R38            Raf = R38;           
8 385d: a1,d8,27,32          ldw   R32,27d8           R32 = ECT_Accel_LU;  
8 3861: b0,72,34             ldb   R34,R72            R34 = [ECT_val];     
//  returns [19 (hot) - 127 (cold)]                                                   //
8 3864: ef,38,f7             call  2f9f               SSByteLU();          
//  R38 = func(ECT)* 131 (2489 <= R38 <= 16637)                                       //
8 3867: 7c,af,38             ml2b  R38,Raf            R38 *= Raf;          
//  ANSWER R3e = R38/256 + 128 (137 <= R3e <= 192)                                    //
8 386a: 55,80,39,3e          ad3b  R3e,R39,80         R3e = R39 + 80;      
8 386e: db,3c                jc    38ac               if (R3e > ff) goto ACl_OVF;
8 3870: 01,30                clrw  R30                R30 = 0;             
8 3872: 11,33                clrb  R33                R33 = 0;             
//  R32 (word) = R39 (9 <= R39 <= 64)                                                 //
8 3874: b0,39,32             ldb   R32,R39            R32 = R39;           
//  = 63                                                                              //
8 3877: b3,01,3e,24,3b       ldb   R3b,[243e]         R3b = [AccelPump_Time];
//  R3a = 16128                                                                       //
8 387c: 11,3a                clrb  R3a                R3a = 0;             
//  R30 = R32*4.06 = 36 <= R30 <= 260                                                 //
8 387e: 8c,3a,30             divw  R30,R3a            R30 = R30L / R3a;    
8 3881: dd,29                jv    38ac               if (OV) goto ACl_OVF;
//  Enrich local factor (5x actual enrichment) is saved outside proc                  //
8 3883: a0,30,ba             ldw   Rba,R30            Rba = R30;           
//  Clear timer => start enrichment (outside proc)                                    //
8 3886: 01,30                clrw  R30                R30 = 0;             
8 3888: 20,2f                sjmp  38b9               goto endfunc;        

Reduce_Accel_pump:
//      gradually reduce enrich factor as time goes on                                //

Reduce_Accel_pump:
8 388a: 99,80,3e             cmpb  R3e,80                                  
8 388d: d1,20                jleu  38af               if ((uns) R3e <= 80) goto Acl_pump_off;
8 388f: a0,30,3a             ldw   R3a,R30            R3a = R30;           
//  current enrich time/16                                                            //
8 3892: 08,04,3a             shrw  R3a,4              R3a = R3a / 10;      
8 3895: af,01,3e,24,34       ldzbw R34,[243e]         R34 = (uns)[AccelPump_Time];
//  = 63 - (timer/16)                                                                 //
8 389a: 68,3a,34             sb2w  R34,R3a            R34 -= R3a;          
8 389d: d1,10                jleu  38af               if ((uns) R34 <= 0) goto Acl_pump_off;
//  Timer < 1008 to get here ?                                                        //
8 389f: 6c,ba,34             ml2w  R34,Rba            R34 *= Rba;          
8 38a2: dd,08                jv    38ac               if (OV) goto ACl_OVF;
//  R3e = 63-(timer/16)*Max_timer/256 + 128. Reduce enrich by time left               //
8 38a4: 55,80,35,3e          ad3b  R3e,R35,80         R3e = R35 + 80;      
8 38a8: db,02                jc    38ac               if (R3e > ff) goto ACl_OVF;
8 38aa: 20,0d                sjmp  38b9               goto endfunc;        

ACl_OVF:
8 38ac: 91,04,69             orrb  R69,4              [OVF_flags].ACCL_OVF = 1;

Acl_pump_off:
8 38af: b1,80,3e             ldb   R3e,80             R3e = 80;            
//  Reset values, Accel pump OFF.                                                     //
8 38b2: 01,ba                clrw  Rba                Rba = 0;             
8 38b4: 20,03                sjmp  38b9               goto endfunc;        

No_Pchange:
8 38b6: 91,80,3f             orrb  R3f,80             R3f |= 80;           

endfunc:
8 38b9: f0                   ret                      return;              

Main_Inj_Calc:
//                                                                                                                  //
//  Bank Injection time returned from here in R3a (in WDTimer ticks)                                                //
//  called separately for each bank.    [- and something put in R30 for monitoring    ]                             //
//                                                                                                                  //
//  Inputs                                                                                                          //
//  R32  = Base cyl injection             Cyl mass flow/14.64                                                       //
//  Ra2  = ECT choke Scaler               16384 by default                                                          //
//  Rba  = Bank ECT compensation (choke)  16384    for 100% (hot engine)                                            //
//  R2b  = Load compensation (VE trim ?)  128 for 100%                                                              //
//  R3e  = InjnAclenr                     128 is 'base'                                                             //
//  Rb8  = InjnPar3                       16 (fixed in code, Always)                                                //
//  R38  = Inj_Crank_PW                   If Cranking () otherwise ignored                                          //
//  [159] = Time_enrich                   64 = 'base', range 58-64                                                  //
//                                                                                                                  //
//  ANSWERS                                                                                                         //
//     R3a  =  Injection Time in CPU Timer ticks (of 4.8uS)                                                         //
//     R30  =  set for debug? = Answer before base and Vss comp applied                                             //
//                                                                                                                  //
//     cb74 (=52084) ticks = 0.25 secs, so R38 (in this routine) is scaled as (unsigned) 0-32768 => 0-125mS,        //
//     multiplied by 52084, giving 'timer ticks' in R3a (R3a = R38 * 52084/65536)                                   //
//     so 32768 = 0.3479cc of fuel (167cc/min /(60*8) for each cyl.                                                 //
//     max charge for 2.792 Litre engine is 1.206 * 465cc = 0.561 grams making max injection requirement 0.3833g    //
//     at 14.64:1    This code does TWO injections per charge, so actual max is 0.1917g, 6.89mS or R38 = 1808 when  //
//     everything else is 1:1                                                                                       //
//     calc operations in order ....                                                                                //
//  #                                                                                                               //
//  R3a = enrich * Temp_Comp/65536 * Load /128*Accel_enrich /128                                                    //
//        * Time_enrich /64 * Base_inj /4096 + Inj_slope * 52084/65536;                                             //
//                                                                                                                  //
//  (where enrich * Temp_Comp/65536 at hot engine = 4096...)                                                        //
//     EQUATES TO                                                                                                   //
//  Inj_Time = Choke * Load * Accel_F * Time_F * Base + Inj Slope ;                                                 //
//  (100% )    4096    128    128    64    256                                                                      //
//  from 16384*16384/65536 and 16/4096                                                                              //
//  #                                                                                                               //
//  If flag set (Cranking ) simply add Inj_slope to R38 and convert -                                               //
//  #                                                                                                               //
//  ANSWER in    R3a    =    Inj_Crank_time + Inj_slope * 52084/65536;                                              //
//                                                                                                                  //
8 38ba: 3f,1a,6b             jb    B7,R1a,3928        if ([IgnFlags].Cranking == 1) goto 3928;
8 38bd: 4c,ba,a2,38          ml3w  R38,Ra2,Rba        R38 = [Enrich_factor] * Rba;
//  Scale *ECT comp (4096 = 1:1 ?)                                                    //
8 38c1: a0,3a,38             ldw   R38,R3a            R38 = R3a;           
8 38c4: ac,2b,34             ldzbw R34,R2b            R34 = (uns)R2b;      
//  * Load comp. (128 = 1:1)                                                          //
8 38c7: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 38ca: 0c,07,38             shrdw R38,7              R38L = R38L / 80;    
//  * accel enrich (128 = 1:1)                                                        //
8 38cd: ac,3e,34             ldzbw R34,R3e            R34 = (uns)R3e;      
8 38d0: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 38d3: 0c,07,38             shrdw R38,7              R38L = R38L / 80;    
8 38d6: af,01,59,01,34       ldzbw R34,[159]          R34 = (uns)[Inject_Clip];
8 38db: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 38de: 0c,06,38             shrdw R38,6              R38L = R38L / 40;    
8 38e1: 88,00,3a             cmpw  R3a,0                                   
8 38e4: d7,4c                jne   3932               if (R3a != 0) goto I_Overf;
//  Rb8 = 16 (could otherwise be EGR ? )                                              //
8 38e6: ac,b8,34             ldzbw R34,Rb8            R34 = (uns)Rb8;      
8 38e9: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 38ec: 0c,04,38             shrdw R38,4              R38L = R38L / 10;    
8 38ef: 88,00,3a             cmpw  R3a,0                                   
8 38f2: d7,3e                jne   3932               if (R3a != 0) goto I_Overf;
8 38f4: 36,1a,10             jnb   B6,R1a,3907        if ([IgnFlags].Underspeed == 0) goto 3907;
8 38f7: af,01,26,24,34       ldzbw R34,[2426]         R34 = (uns)[EmgyEnrich];
8 38fc: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
//  approx 30% richen if Underspeed -                                                 //
8 38ff: 0c,06,38             shrdw R38,6              R38L = R38L / 40;    
8 3902: 88,00,3a             cmpw  R3a,0                                   
8 3905: d7,2b                jne   3932               if (R3a != 0) goto I_Overf;
8 3907: 33,2c,10             jnb   B3,R2c,391a        if ([RPM_flags].Knock_Risk == 0) goto 391a;
//  Knock Enrich - Times 1 => redundant                                               //
8 390a: af,01,27,24,34       ldzbw R34,[2427]         R34 = (uns)[KnckEnrich];
8 390f: 6c,34,38             ml2w  R38,R34            R38 *= R34;          
8 3912: 0c,07,38             shrdw R38,7              R38L = R38L / 80;    
8 3915: 88,00,3a             cmpw  R3a,0                                   
8 3918: d7,18                jne   3932               if (R3a != 0) goto I_Overf;

391a - Sub 8 391a:
8 391a: a0,38,30             ldw   R30,R38            R30 = R38;           
//  Base_inj * enrich_factor/4096                                                     //
8 391d: 6c,32,38             ml2w  R38,R32            R38 *= R32;          
8 3920: 0c,0c,38             shrdw R38,c              R38L = R38L / 1000;  
8 3923: 88,00,3a             cmpw  R3a,0                                   
8 3926: d7,0a                jne   3932               if (R3a != 0) goto I_Overf;

3928 - Sub 8 3928:
8 3928: 64,50,38             ad2w  R38,R50            R38 += [Inj_slope];  
8 392b: 8b,01,a4,24,38       cmpw  R38,[24a4]                              
8 3930: d1,08                jleu  393a               if ((uns) R38 <= [InjMax]) goto 393a;

I_Overf:
8 3932: a3,01,a4,24,38       ldw   R38,[24a4]         R38 = [InjMax];      
//  Used only here - calc o/flow                                                      //
8 3937: 91,20,69             orrb  R69,20             [OVF_flags].InjC_OVF = 1;

393a - Sub 8 393a:
8 393a: 6d,74,cb,38          ml2w  R38,cb74           R38 *= cb74;         
8 393e: 37,1a,05             jnb   B7,R1a,3946        if ([IgnFlags].Cranking == 0) goto 3946;
8 3941: 32,20,02             jnb   B2,R20,3946        if ([TPS_flags].TPS_Wide == 0) goto 3946;
//  set limit if cranking and WOT                                                     //
8 3944: 01,3a                clrw  R3a                R3a = 0;             
8 3946: f0                   ret                      return;              

Trip_Calc:
//                                                                                    //
//  Trip PW Output ( =>freq) calculation.                                             //
//  PW limited 169 - 7fff no output if RPM = 0                                        //
//  faster freq = more fuel injected                                                  //
//  0x169 (361) implies 361*2*4.8uS = 288 Hz                                          //
//  0x7fff (32767) implies 32767*2*4.8uS = 3.17 Hz                                    //
//  inject time is in timer ticks                                                     //
//  843 ticks inject time for 3 injectors is 0.0249 grams.                            //
//  so (Elapsed Time/0.025g shots of fuel ?)                                          //
//  26000/1 = 4 hz = 0.024 grams/sec => 0.06g per Hz/'tick' ?                         //
//  26000/72 = 288Hz = 1.75g/sec = 6.3Kg/hr = 6.3/hr = 1.389 gals/hr.                 //
//  100Hz would be 0.6g/sec , 200Hz 1.2g ?                                            //
//  so is calibration actually 1Hz = 0.01g Fuel per cyl?                              //
//                                                                                    //
8 3947: 39,2c,0a             jb    B1,R2c,3954        if ([RPM_flags].No_Fuel == 1) goto 3954;
8 394a: 98,00,15             cmpb  R15,0                                   
8 394d: d7,05                jne   3954               if ([test_flags] != 0) goto 3954;
8 394f: 88,00,70             cmpw  R70,0                                   
8 3952: d7,05                jne   3959               if ([RPM] != 0) goto 3959;
8 3954: 71,df,5a             an2b  R5a,df             [Svc_flags].TRIP_Reqd = 0;
8 3957: 20,66                sjmp  39bf               goto endfunc;        

3959 - Sub 8 3959:
8 3959: a3,01,48,01,34       ldw   R34,[148]          R34 = [TPS_Interval];
8 395e: 67,01,62,01,34       ad2w  R34,[162]          R34 += [TRIP_CTimeH];
8 3963: a3,01,64,01,36       ldw   R36,[164]          R36 = [TRIP_CTimeL]; 
//  32 bit add CTIME + TPS_Intvl                                                      //
8 3968: a4,00,36             adcw  R36,0              R36 += 0 + CY;       
8 396b: a0,34,38             ldw   R38,R34            R38 = R34;           
8 396e: a0,36,3a             ldw   R3a,R36            R3a = R36;           
8 3971: 0c,03,38             shrdw R38,3              R38L = R38L / 8;     
8 3974: 8b,01,a8,24,38       cmpw  R38,[24a8]                              
8 3979: d3,3a                jnc   39b5               if ((uns) R38 < [DOL_Freq]) goto 39b5;
//     enter here (approx) every second (26000*8*4.8 uS [double])                     //
//                                                                                    //
8 397b: a3,01,5c,01,30       ldw   R30,[15c]          R30 = [Tot_Inj_L];   
//  (DBL) total injection time (- batt compensation)                                  //
8 3980: a3,01,5e,01,32       ldw   R32,[15e]          R32 = [Tot_Inj_H];   
//  R30 = Trip_Inj/843 ()                                                             //
8 3985: 8f,01,40,24,30       divw  R30,[2440]         R30 = R30L / [DOL_scaler];
8 398a: c3,01,5c,01,32       stw   [15c],R32          [Tot_Inj_L] = R32;   
//  keep remainder => mod(Trip_inj,843); double                                       //
8 398f: c3,01,5e,01,00       stw   [15e],0            [Tot_Inj_H] = 0;     
8 3994: 8c,30,34             divw  R34,R30            R34 = R34L / R30;    
//  = (Elapsed Time/(total_inj_time/843) ;                                            //
8 3997: a0,34,76             ldw   R76,R34            [TRIP_PW_Time] = R34;
8 399a: 89,69,01,76          cmpw  R76,169                                 
8 399e: db,04                jc    39a4               if ((uns) [TRIP_PW_Time] >= 169) goto 39a4;
8 39a0: a1,69,01,76          ldw   R76,169            [TRIP_PW_Time] = 169;
8 39a4: 89,ff,7f,76          cmpw  R76,7fff                                
8 39a8: d1,04                jleu  39ae               if ((uns) [TRIP_PW_Time] <= 7fff) goto 39ae;
8 39aa: a1,ff,7f,76          ldw   R76,7fff           [TRIP_PW_Time] = 7fff;
8 39ae: 01,34                clrw  R34                R34 = 0;             
//  clear Ctime.                                                                      //
8 39b0: 01,36                clrw  R36                R36 = 0;             
//  END of one sec update                                                             //
8 39b2: 91,20,5a             orrb  R5a,20             [Svc_flags].TRIP_Reqd = 1;
8 39b5: c3,01,62,01,34       stw   [162],R34          [TRIP_CTimeH] = R34; 
//  save Ctime (zero or accum. total)                                                 //
8 39ba: c3,01,64,01,36       stw   [164],R36          [TRIP_CTimeL] = R36; 

endfunc:
8 39bf: e7,f6,f1             jump  2bb8               goto Main_EXIT;      

Fuel_Pump:
//                                                                                    //
//  Fuel Pump driver, timeout check (~ 1 sec)                                         //
//                                                                                    //
8 39c2: 91,04,5a             orrb  R5a,4              [Svc_flags].PUMP_Reqd = 1;
8 39c5: 99,03,55             cmpb  R55,3                                   
8 39c8: d3,03                jnc   39cd               if ((uns) [FPUMP_Ticks] < 3) goto 39cd;
8 39ca: 71,fb,5a             an2b  R5a,fb             [Svc_flags].PUMP_Reqd = 0;
8 39cd: e7,e8,f1             jump  2bb8               goto Main_EXIT;      

Sensor_Test:
//                                                                                    //
//  sensor check and STI handler                                                      //
//  - called from tasklist for sensor check.                                          //
//  looks like R2d is simply "time powered up" - not used anywhere else               //
//                                                                                    //
8 39d0: 28,b7                scall 3a89               Check_Sensors();     
//  not until 2 secs since powered on ?                                               //
8 39d2: 99,02,2d             cmpb  R2d,2                                   
8 39d5: d1,30                jleu  3a07               if ((uns) [Pwrd_tmr] <= 2) goto 3a07;
8 39d7: 99,00,15             cmpb  R15,0                                   
8 39da: d7,02                jne   39de               if ([test_flags] != 0) goto 39de;
8 39dc: 11,14                clrb  R14                R14 = 0;             
8 39de: 3a,5a,0e             jb    B2,R5a,39ef        if ([Svc_flags].PUMP_Reqd == 1) goto 39ef;
8 39e1: 34,5a,18             jnb   B4,R5a,39fc        if ([Svc_flags].STI_Reqd == 0) goto 39fc;
8 39e4: 3a,15,26             jb    B2,R15,3a0d        if ([test_flags].KOEO == 1) goto 3a0d;
8 39e7: 3b,15,10             jb    B3,R15,39fa        if ([test_flags].KOER == 1) goto 39fa;
//  set $15:2 STI - Engine Off                                                        //
8 39ea: b1,04,15             ldb   R15,4              [test_flags] = 4;    
8 39ed: 20,1e                sjmp  3a0d               goto 3a0d;           

8 39ef: 34,5a,15             jnb   B4,R5a,3a07        if ([Svc_flags].STI_Reqd == 0) goto 3a07;
8 39f2: 3b,15,05             jb    B3,R15,39fa        if ([test_flags].KOER == 1) goto 39fa;
//  set $15:3 STI - Engine Running                                                    //
8 39f5: b1,08,15             ldb   R15,8              [test_flags] = 8;    
8 39f8: 11,14                clrb  R14                R14 = 0;             
8 39fa: 21,7c                sjmp  3b78               goto 3b78;           

8 39fc: 39,15,64             jb    B1,R15,3a63        if ([test_flags].EndTest == 1) goto 3a63;
//  SET $15:1 STI reset - KOEO only                                                   //
8 39ff: b1,02,15             ldb   R15,2              [test_flags] = 2;    
8 3a02: 71,f7,5a             an2b  R5a,f7             [Svc_flags].STO_Reqd = 0;
8 3a05: 20,5c                sjmp  3a63               goto 3a63;           

8 3a07: 11,15                clrb  R15                [test_flags] = 0;    
8 3a09: 11,14                clrb  R14                R14 = 0;             
8 3a0b: 21,f9                sjmp  3c06               goto endfunc;        

3a0d - Sub 8 3a0d:
8 3a0d: 99,08,67             cmpb  R67,8                                   
//  clear STO after 1 sec or more                                                     //
8 3a10: de,03                jlt   3a15               if ((sig) [STI_timer] < 8) goto 3a15;
8 3a12: 71,f7,5a             an2b  R5a,f7             [Svc_flags].STO_Reqd = 0;
8 3a15: 71,3f,20             an2b  R20,3f             [TPS_flags] &= 3f;   
8 3a18: 3d,16,0e             jb    B5,R16,3a29        if ([codeflags].VAF1code == 1) goto 3a29;
8 3a1b: 89,00,32,96          cmpw  R96,3200                                
//  1 volt                                                                            //
8 3a1f: d3,0b                jnc   3a2c               if ((uns) [VAF1_raw] < 3200) goto 3a2c;
8 3a21: 99,02,14             cmpb  R14,2                                   
8 3a24: df,06                je    3a2c               if (R14 == 2) goto 3a2c;
//  VAF 1 > 1V                                                                        //
8 3a26: 91,40,20             orrb  R20,40             [TPS_flags].TPS_Vaf1 = 1;
8 3a29: b1,01,14             ldb   R14,1              R14 = 1;             
8 3a2c: 39,16,17             jb    B1,R16,3a46        if ([codeflags].VAF2code == 1) goto 3a46;
8 3a2f: 89,00,32,7e          cmpw  R7e,3200                                
//  1 volt                                                                            //
8 3a33: d3,11                jnc   3a46               if ((uns) [VAF2_raw] < 3200) goto 3a46;
8 3a35: 99,01,14             cmpb  R14,1                                   
8 3a38: de,05                jlt   3a3f               if ((sig) R14 < 1) goto 3a3f;
//  VAF 1 AND 2 > 1V                                                                  //
8 3a3a: 91,80,20             orrb  R20,80             [TPS_flags].TPS_Vaf2 = 1;
8 3a3d: 20,07                sjmp  3a46               goto 3a46;           

3a3f - Sub 8 3a3f:
8 3a3f: 81,80,00,16          orrw  R16,80             [codeflags] |= 80;   
8 3a43: b1,02,14             ldb   R14,2              R14 = 2;             
8 3a46: b0,b5,30             ldb   R30,Rb5            R30 = [flags3];      
//  Keep Flags - $b5:1, $B5:2, $b5:3                                                  //
8 3a49: 71,0e,30             an2b  R30,e              R30 &= e;            
8 3a4c: 98,20,68             cmpb  R68,R20                                 
8 3a4f: d7,05                jne   3a56               if (R68 != [TPS_flags]) goto 3a56;
8 3a51: 98,30,f7             cmpb  Rf7,R30                                 
8 3a54: df,05                je    3a5b               if (Rf7 == R30) goto 3a5b;
8 3a56: 91,08,5a             orrb  R5a,8              [Svc_flags].STO_Reqd = 1;
//  set STO for 1 sec - TPS or NDS changed ?                                          //
8 3a59: 11,67                clrb  R67                [STI_timer] = 0;     
8 3a5b: b0,20,68             ldb   R68,R20            R68 = [TPS_flags];   
//  remember TPS and NDS flags                                                        //
8 3a5e: b0,30,f7             ldb   Rf7,R30            Rf7 = R30;           
8 3a61: 21,a3                sjmp  3c06               goto endfunc;        

3a63 - Sub 8 3a63:
8 3a63: ac,14,30             ldzbw R30,R14            R30 = (uns)R14;      
8 3a66: b3,31,84,3a,32       ldb   R32,[R30+3a84]     R32 = [R30+OSt8_001_3a84];
8 3a6b: 71,07,20             an2b  R20,7              [TPS_flags] &= 7;    
8 3a6e: 98,20,32             cmpb  R32,R20                                 
8 3a71: d7,0f                jne   3a82               if (R32 != [TPS_flags]) goto 3a82;
8 3a73: 17,14                incb  R14                R14++;               
8 3a75: 99,04,14             cmpb  R14,4                                   
8 3a78: da,08                jle   3a82               if ((sig) R14 <= 4) goto 3a82;
8 3a7a: 88,00,16             cmpw  R16,0                                   
8 3a7d: d7,03                jne   3a82               if ([codeflags] != 0) goto 3a82;
8 3a7f: 91,08,5a             orrb  R5a,8              [Svc_flags].STO_Reqd = 1;
8 3a82: 21,82                sjmp  3c06               goto endfunc;        

        Inc   8 3a84: ostruct   OSt8_001_3a84 - Other Structure 8 001

8 3a84: 03,00                                         Unknown Operation/Structure


OSt8_001 - Other Structure 8 001:
8 3a86: 04      ostruct    4
8 3a87: 00      ostruct    0
8 3a88: 03      ostruct    3
//  index counter to traverse vector list                                             //
8 3a89: b1      ostruct   b1

//  sensor_number, used for bitmap                                                    //
8 3a8c: a1,01,00,38          ldw   R38,1              R38 = 1;             
8 3a90: ac,66,3a             ldzbw R3a,R66            R3a = (uns)R66;      
//  index*2 for word offset                                                           //
8 3a93: 09,01,3a             shlw  R3a,1              R3a = R3a * 2;       
//  get current fail flags                                                            //
8 3a96: a0,18,36             ldw   R36,R18            R36 = [Fail_flags];  
//  B0 R36 = Fail Flag for this sensor                                                //
8 3a99: 0c,38,34             shrdw R34,38             R34L = R34L >> R38;  
//  Each (raw) sensor value                                                           //
8 3a9c: a3,3a,7c,30          ldw   R30,[R3a+7c]       R30 = [R3a+Octane_adj];
//  Call checker for each sensor type                                                 //
8 3aa0: cb,3b,a4,3a          push  [R3a+3aa4]         push([R3a+VecLst8_002]);
8 3aa4: f0                   ret                      return;              


8 3aa6: c2,3a                3ac2  Bank 8 Vector      VAF_Check
8 3aa8: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor
8 3aaa: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor
8 3aac: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor
8 3aae: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor
8 3ab0: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor
8 3ab2: 6e,3b                3b6e  Bank 8 Vector      Skip_Sensor


8 3ab4: d2,3a,e2,3a,f2,3a,6e,3b                       Unknown Operation/Structure
8 3abc: 6e,3b,c2,3a,02,3b                             Unknown Operation/Structure


VAF_Check:
8 3ac2: 8b,01,90,24,30       cmpw  R30,[2490]                              
8 3ac7: d9,75                jgtu  3b3e               if ((uns) R30 > [5V]) goto Sensor_fail;
8 3ac9: 8b,01,92,24,30       cmpw  R30,[2492]                              
8 3ace: d3,6e                jnc   3b3e               if ((uns) R30 < [0.2V]) goto Sensor_fail;
8 3ad0: 20,43                sjmp  3b15               goto Sensor_pass;    

TPS_Check:
8 3ad2: 8b,01,84,24,30       cmpw  R30,[2484]                              
8 3ad7: d9,65                jgtu  3b3e               if ((uns) R30 > [5V]) goto Sensor_fail;
8 3ad9: 8b,01,86,24,30       cmpw  R30,[2486]                              
8 3ade: d3,5e                jnc   3b3e               if ((uns) R30 < [0.125V]) goto Sensor_fail;
8 3ae0: 20,33                sjmp  3b15               goto Sensor_pass;    

ECT_Check:
8 3ae2: 8b,01,88,24,30       cmpw  R30,[2488]                              
8 3ae7: d9,55                jgtu  3b3e               if ((uns) R30 > [4.6V]) goto Sensor_fail;
8 3ae9: 8b,01,8a,24,30       cmpw  R30,[248a]                              
8 3aee: d3,4e                jnc   3b3e               if ((uns) R30 < [0.15V]) goto Sensor_fail;
8 3af0: 20,23                sjmp  3b15               goto Sensor_pass;    

ACT_Check:
8 3af2: 8b,01,8c,24,30       cmpw  R30,[248c]                              
8 3af7: d9,45                jgtu  3b3e               if ((uns) R30 > [4.6V]) goto Sensor_fail;
8 3af9: 8b,01,8e,24,30       cmpw  R30,[248e]                              
8 3afe: d3,3e                jnc   3b3e               if ((uns) R30 < [0.26V]) goto Sensor_fail;
8 3b00: 20,13                sjmp  3b15               goto Sensor_pass;    

BAP_Check:
8 3b02: a3,01,56,01,30       ldw   R30,[156]          R30 = [BAP_Freq];    
8 3b07: 8b,01,70,24,30       cmpw  R30,[2470]                              
8 3b0c: d9,30                jgtu  3b3e               if ((uns) R30 > [BAP_MAX]) goto Sensor_fail;
8 3b0e: 8b,01,72,24,30       cmpw  R30,[2472]                              
8 3b13: d3,29                jnc   3b3e               if ((uns) R30 < [BAP_MIN]) goto Sensor_fail;

Sensor_pass:
8 3b15: 39,15,0d             jb    B1,R15,3b25        if ([test_flags].EndTest == 1) goto 3b25;
8 3b18: 3a,15,0a             jb    B2,R15,3b25        if ([test_flags].KOEO == 1) goto 3b25;
//  already flagged as failed ?                                                       //
8 3b1b: 38,36,09             jb    B0,R36,3b27        if (B0_R36) goto 3b27;
8 3b1e: 11,ba                clrb  Rba                Rba = 0;             
//  clear [f7+sensor no]                                                              //
8 3b20: c7,39,f7,00,ba       stb   [R38+f7],Rba       [R38+f7] = Rba;      
8 3b25: 20,45                sjmp  3b6c               goto Next_Sensor;    

3b27 - Sub 8 3b27:
8 3b27: b3,39,f7,00,32       ldb   R32,[R38+f7]       R32 = [R38+f7];      
8 3b2c: 9b,01,2a,24,32       cmpb  R32,[242a]                              
8 3b31: d3,39                jnc   3b6c               if ((uns) R32 < [Sensor_1]) goto Next_Sensor;
8 3b33: 71,fe,36             an2b  R36,fe             R36 &= fe;           
8 3b36: 0d,38,34             shldw R34,38             R34L = R34L << R38;  
//  update 'master' copy                                                              //
8 3b39: a0,36,18             ldw   R18,R36            [Fail_flags] = R36;  
8 3b3c: 20,2e                sjmp  3b6c               goto Next_Sensor;    

Sensor_fail:
8 3b3e: 39,15,1b             jb    B1,R15,3b5c        if ([test_flags].EndTest == 1) goto 3b5c;
8 3b41: 3a,15,18             jb    B2,R15,3b5c        if ([test_flags].KOEO == 1) goto 3b5c;
//  already flagged as failed ?                                                       //
8 3b44: 30,36,09             jnb   B0,R36,3b50        if (!B0_R36) goto 3b50;
8 3b47: 11,ba                clrb  Rba                Rba = 0;             
//  clear [f7+sensor no]                                                              //
8 3b49: c7,39,f7,00,ba       stb   [R38+f7],Rba       [R38+f7] = Rba;      
8 3b4e: 20,1c                sjmp  3b6c               goto Next_Sensor;    

3b50 - Sub 8 3b50:
8 3b50: b3,39,f7,00,32       ldb   R32,[R38+f7]       R32 = [R38+f7];      
8 3b55: 9b,01,2b,24,32       cmpb  R32,[242b]                              
8 3b5a: d3,10                jnc   3b6c               if ((uns) R32 < [sensorx_1]) goto Next_Sensor;
8 3b5c: 91,01,36             orrb  R36,1              R36 |= 1;            
//  set [f7+sensor no]                                                                //
8 3b5f: 0d,38,34             shldw R34,38             R34L = R34L << R38;  
8 3b62: a0,36,18             ldw   R18,R36            [Fail_flags] = R36;  
//  update 'master' and 'test' copies                                                 //
8 3b65: 80,36,16             orrw  R16,R36            [codeflags] |= R36;  
//  ignore BAP error                                                                  //
8 3b68: 61,bf,ff,16          an2w  R16,ffbf           [codeflags] &= ffbf; 

Next_Sensor:
8 3b6c: 07,38                incw  R38                R38++;               

Skip_Sensor:
8 3b6e: 17,66                incb  R66                R66++;               
8 3b70: 99,0e,66             cmpb  R66,e                                   
8 3b73: d9,02                jgtu  3b77               if ((uns) R66 > e) goto 3b77;
8 3b75: 27,19                sjmp  3a90               goto 3a90;           

8 3b77: f0                   ret                      return;              

3b78 - Sub 8 3b78:
8 3b78: 99,00,14             cmpb  R14,0                                   
8 3b7b: d7,10                jne   3b8d               if (R14 != 0) goto 3b8d;
8 3b7d: 3d,5a,0b             jb    B5,R5a,3b8b        if ([Svc_flags].TRIP_Reqd == 1) goto 3b8b;
8 3b80: 36,b4,08             jnb   B6,Rb4,3b8b        if ([OP_Reqd_flags].DOL_rqd == 0) goto 3b8b;
8 3b83: 91,08,5a             orrb  R5a,8              [Svc_flags].STO_Reqd = 1;
//  Timer = 16 secs (effectively)                                                     //
8 3b86: 11,67                clrb  R67                [STI_timer] = 0;     
8 3b88: b1,ff,14             ldb   R14,ff             R14 = ff;            
8 3b8b: 20,79                sjmp  3c06               goto endfunc;        

8 3b8d: 99,ff,14             cmpb  R14,ff                                  
8 3b90: d7,0f                jne   3ba1               if (R14 != ff) goto 3ba1;
8 3b92: 99,28,67             cmpb  R67,28                                  
//   < 5 seconds                                                                      //
8 3b95: de,6f                jlt   3c06               if ((sig) [STI_timer] < 28) goto endfunc;
8 3b97: 71,f7,5a             an2b  R5a,f7             [Svc_flags].STO_Reqd = 0;
//  reset timer to 16 secs (256) ?                                                    //
8 3b9a: 11,67                clrb  R67                [STI_timer] = 0;     
//  start output here after 5 secs                                                    //
8 3b9c: b1,01,14             ldb   R14,1              R14 = 1;             
8 3b9f: 20,65                sjmp  3c06               goto endfunc;        

8 3ba1: b0,67,31             ldb   R31,R67            R31 = [STI_timer];   
//  R30 = Timer*16                                                                    //
8 3ba4: 08,04,30             shrw  R30,4              R30 = R30 / 10;      
8 3ba7: 3f,30,05             jb    B7,R30,3baf        if (B7_R30) goto 3baf;
//  Timer < 16, (2 secs) skip ?                                                       //
8 3baa: 71,f7,5a             an2b  R5a,f7             [Svc_flags].STO_Reqd = 0;
8 3bad: 20,57                sjmp  3c06               goto endfunc;        

8 3baf: 99,10,31             cmpb  R31,10                                  
//  Timer < 1 sec                                                                     //
8 3bb2: de,0f                jlt   3bc3               if ((sig) R31 < 10) goto 3bc3;
8 3bb4: 11,67                clrb  R67                [STI_timer] = 0;     
8 3bb6: 88,00,16             cmpw  R16,0                                   
8 3bb9: d7,04                jne   3bbf               if ([codeflags] != 0) goto 3bbf;
8 3bbb: 11,14                clrb  R14                R14 = 0;             
8 3bbd: 20,47                sjmp  3c06               goto endfunc;        

3bbf - Sub 8 3bbf:
8 3bbf: 17,14                incb  R14                R14++;               
8 3bc1: 20,43                sjmp  3c06               goto endfunc;        

8 3bc3: 88,00,16             cmpw  R16,0                                   
8 3bc6: d7,07                jne   3bcf               if ([codeflags] != 0) goto 3bcf;
//  code 11 - all OK                                                                  //
8 3bc8: a3,01,0a,3c,34       ldw   R34,[3c0a]         R34 = [OSt8_003_3c0a];
8 3bcd: 20,1f                sjmp  3bee               goto 3bee;           

8 3bcf: a0,16,32             ldw   R32,R16            R32 = [codeflags];   
8 3bd2: 08,14,32             shrw  R32,14             R32 = R32 >> R14;    
8 3bd5: 38,32,0b             jb    B0,R32,3be3        if (B0_R32) goto 3be3;
8 3bd8: 17,14                incb  R14                R14++;               
8 3bda: 99,10,14             cmpb  R14,10                                  
//  all 16 bits scanned...                                                            //
8 3bdd: da,f0                jle   3bcf               if ((sig) R14 <= 10) goto 3bcf;
8 3bdf: 11,14                clrb  R14                R14 = 0;             
8 3be1: 20,23                sjmp  3c06               goto endfunc;        

8 3be3: ac,14,38             ldzbw R38,R14            R38 = (uns)R14;      
//  times 2 for word offset                                                           //
8 3be6: 09,01,38             shlw  R38,1              R38 = R38 * 2;       
8 3be9: a3,39,0a,3c,34       ldw   R34,[R38+3c0a]     R34 = [R38+OSt8_003_3c0a];

3bee - Sub 8 3bee:
8 3bee: 01,36                clrw  R36                R36 = 0;             
8 3bf0: 0d,31,34             shldw R34,31             R34L = R34L << R31;  
8 3bf3: 3f,35,05             jb    B7,R35,3bfb        if (B7_R35) goto 3bfb;
8 3bf6: 71,f7,5a             an2b  R5a,f7             [Svc_flags].STO_Reqd = 0;
8 3bf9: 20,03                sjmp  3bfe               goto 3bfe;           

8 3bfb: 91,08,5a             orrb  R5a,8              [Svc_flags].STO_Reqd = 1;

3bfe - Sub 8 3bfe:
8 3bfe: 0c,03,34             shrdw R34,3              R34L = R34L / 8;     
8 3c01: 88,00,34             cmpw  R34,0                                   
8 3c04: df,ae                je    3bb4               if (R34 == 0) goto 3bb4;

endfunc:
8 3c06: e7,af,ef             jump  2bb8               goto Main_EXIT;      

        Inc   8 3c0a: ostruct   OSt8_003_3c0a - Other Structure 8 003

8 3c09: ff,00                                         Unknown Operation/Structure


OSt8_003 - Other Structure 8 003:
8 3c0b: 48,00      ostruct     48
8 3c0d: 66,80      ostruct   8066
8 3c0f: 4f,00      ostruct     4f
8 3c11: 4e,00      ostruct     4e
8 3c13: 4f,00      ostruct     4f
8 3c15: 4c,c0      ostruct   c04c
8 3c17: 67,00      ostruct     67
8 3c19: 67,00      ostruct     67
8 3c1b: 72,00      ostruct     72
8 3c1d: 73,91      ostruct   9173
8 3c1f: 20,b5      ostruct   b520

8 3c21: 3a,5a,05             jb    B2,R5a,3c29        if ([Svc_flags].PUMP_Reqd == 1) goto 3c29;
//  No ISC required if no Fuel Pump                                                   //
8 3c24: a0,00,38             ldw   R38,0              R38 = 0;             
8 3c27: 21,c1                sjmp  3dea               goto endfunc;        

8 3c29: a0,be,32             ldw   R32,Rbe            R32 = [Averaged_RPM];
8 3c2c: a0,70,34             ldw   R34,R70            R34 = [RPM];         
//  100% of change but negated                                                        //
8 3c2f: a3,01,4e,24,36       ldw   R36,[244e]         R36 = [RPM_VFilter]; 
8 3c34: ef,aa,f3             call  2fe1               SWfilter();          
8 3c37: a0,3e,be             ldw   Rbe,R3e            [Averaged_RPM] = R3e;
8 3c3a: 01,38                clrw  R38                R38 = 0;             
//  fixed pulsewidth if = 1 (is zero)                                                 //
8 3c3c: b3,01,52,24,30       ldb   R30,[2452]         R30 = [ISC_FixPW];   
8 3c41: 99,01,30             cmpb  R30,1                                   
8 3c44: d7,07                jne   3c4d               if (R30 != 1) goto 3c4d;
//  Fixed ISC pulswidth in TICKS                                                      //
8 3c46: b3,01,53,24,39       ldb   R39,[2453]         R39 = [ISC_FPW];     
8 3c4b: 21,9d                sjmp  3dea               goto endfunc;        

3c4d - Sub 8 3c4d:
8 3c4d: 01,b8                clrw  Rb8                Rb8 = 0;             
8 3c4f: 34,5a,0f             jnb   B4,R5a,3c61        if ([Svc_flags].STI_Reqd == 0) goto 3c61;
8 3c52: af,01,9a,24,32       ldzbw R32,[249a]         R32 = (uns)[32_secs];
8 3c57: 67,01,7a,24,32       ad2w  R32,[247a]         R32 += [3_secs];     
8 3c5c: 88,32,ea             cmpw  Rea,R32                                 
8 3c5f: d1,05                jleu  3c66               if ((uns) [Run_Time] <= R32) goto 3c66;
8 3c61: 99,02,30             cmpb  R30,2                                   
//  always jumps...2452 is zero                                                       //
8 3c64: d7,07                jne   3c6d               if (R30 != 2) goto 3c6d;
8 3c66: 3a,ea,04             jb    B2,Rea,3c6d        if (B2_[Run_Time]) goto 3c6d;
//  add 200 rpm for 4 sec intervals ? part of self test ?                             //
8 3c69: a1,20,03,b8          ldw   Rb8,320            Rb8 = 320;           
8 3c6d: a3,01,3c,01,3e       ldw   R3e,[13c]          R3e = [Last_ISC_H];  
//  from last calc                                                                    //
8 3c72: a3,01,3a,01,3c       ldw   R3c,[13a]          R3c = [Last_ISC_L];  
8 3c77: a1,7c,2a,32          ldw   R32,2a7c           R32 = ISC_Start_PW;  
8 3c7b: bc,72,34             ldsbw R34,R72            R34 = (sig)[ECT_val];
8 3c7e: ef,3e,f6             call  32bf               SSWordLU();          
//  Value  Used directly if TPS fail                                                  //
8 3c81: a0,38,ba             ldw   Rba,R38            Rba = R38;           
8 3c84: 37,1a,0a             jnb   B7,R1a,3c91        if ([IgnFlags].Cranking == 0) goto 3c91;
//  Cranking - fixed ISC (100%) and exit                                              //
8 3c87: b3,01,51,24,39       ldb   R39,[2451]         R39 = [CrnKISC_PW];  
8 3c8c: 71,bf,5a             an2b  R5a,bf             [Svc_flags].ISC_Calc_reqd = 0;
8 3c8f: 21,59                sjmp  3dea               goto endfunc;        

8 3c91: 36,1a,0a             jnb   B6,R1a,3c9e        if ([IgnFlags].Underspeed == 0) goto 3c9e;
//  Underspeed - fixed (80%) ISC and exit                                             //
8 3c94: b3,01,50,24,39       ldb   R39,[2450]         R39 = [UspISC_PW];   
8 3c99: 71,bf,5a             an2b  R5a,bf             [Svc_flags].ISC_Calc_reqd = 0;
8 3c9c: 21,4c                sjmp  3dea               goto endfunc;        

8 3c9e: 31,2c,1b             jnb   B1,R2c,3cbc        if ([RPM_flags].No_Fuel == 0) goto 3cbc;
8 3ca1: 3e,5a,0a             jb    B6,R5a,3cae        if ([Svc_flags].ISC_Calc_reqd == 1) goto 3cae;
8 3ca4: 3f,5a,38             jb    B7,R5a,3cdf        if ([Svc_flags].ISC_Tmr_reqd == 1) goto ISC_TimCheck;
8 3ca7: 01,f4                clrw  Rf4                [ISCTimer] = 0;      
8 3ca9: 91,80,5a             orrb  R5a,80             [Svc_flags].ISC_Tmr_reqd = 1;
8 3cac: 20,31                sjmp  3cdf               goto ISC_TimCheck;   

3cae - Sub 8 3cae:
8 3cae: 01,f4                clrw  Rf4                [ISCTimer] = 0;      
8 3cb0: a0,be,34             ldw   R34,Rbe            R34 = [Averaged_RPM];
//  Straight lookup and exit                                                          //
8 3cb3: a1,64,2a,32          ldw   R32,2a64           R32 = ISC_RPM_2;     
8 3cb7: ef,02,f6             call  32bc               UUWordLU();          
8 3cba: 21,2e                sjmp  3dea               goto endfunc;        

3cbc - Sub 8 3cbc:
8 3cbc: 32,18,05             jnb   B2,R18,3cc4        if ([Fail_flags].TPSFail == 0) goto 3cc4;
8 3cbf: a0,ba,3e             ldw   R3e,Rba            R3e = Rba;           
8 3cc2: 20,f6                sjmp  3dba               goto ISC_Set_Final;  

8 3cc4: 30,20,0c             jnb   B0,R20,3cd3        if ([TPS_flags].TPS_Closed == 0) goto 3cd3;
8 3cc7: 38,2c,0e             jb    B0,R2c,3cd8        if ([RPM_flags].Cold_start == 1) goto 3cd8;
8 3cca: 8b,01,b6,24,70       cmpw  R70,[24b6]                              
8 3ccf: db,d0                jc    3ca1               if ((uns) [RPM] >= [RPM_1200]) goto 3ca1;
8 3cd1: 20,0c                sjmp  3cdf               goto ISC_TimCheck;   

3cd3 - Sub 8 3cd3:
8 3cd3: 91,40,5a             orrb  R5a,40             [Svc_flags].ISC_Calc_reqd = 1;
8 3cd6: 20,e2                sjmp  3dba               goto ISC_Set_Final;  

8 3cd8: 8b,01,56,24,70       cmpw  R70,[2456]                              
8 3cdd: db,c2                jc    3ca1               if ((uns) [RPM] >= [RPM_1430]) goto 3ca1;

ISC_TimCheck:
8 3cdf: 8b,01,7a,24,ea       cmpw  Rea,[247a]                              
8 3ce4: db,05                jc    3ceb               if ((uns) [Run_Time] >= [3_secs]) goto 3ceb;
8 3ce6: a0,ba,3e             ldw   R3e,Rba            R3e = Rba;           
8 3ce9: 20,cf                sjmp  3dba               goto ISC_Set_Final;  

3ceb - Sub 8 3ceb:
8 3ceb: 71,df,b5             an2b  Rb5,df             [flags3].No_Lock_Ign_ISC = 0;
8 3cee: 71,bf,5a             an2b  R5a,bf             [Svc_flags].ISC_Calc_reqd = 0;
8 3cf1: a3,01,54,24,34       ldw   R34,[2454]         R34 = [20mSec];      
8 3cf6: 88,e6,34             cmpw  R34,Re6                                 
8 3cf9: d1,02                jleu  3cfd               if ((uns) R34 <= [Timer6]) goto 3cfd;
8 3cfb: 20,f2                sjmp  3def               goto 3def;           

8 3cfd: 01,e6                clrw  Re6                [Timer6] = 0;        
8 3cff: a1,e8,29,32          ldw   R32,29e8           R32 = IDLE_ECT;      
8 3d03: bc,72,34             ldsbw R34,R72            R34 = (sig)[ECT_val];
8 3d06: ef,b6,f5             call  32bf               SSWordLU();          
8 3d09: 64,38,b8             ad2w  Rb8,R38            Rb8 += R38;          
8 3d0c: 32,b5,11             jnb   B2,Rb5,3d20        if ([flags3].NDS_Neutral == 0) goto 3d20;
8 3d0f: 3c,b5,05             jb    B4,Rb5,3d17        if ([flags3].NDS_Change == 1) goto 3d17;
8 3d12: 91,10,b5             orrb  Rb5,10             [flags3].NDS_Change = 1;
8 3d15: 01,fe                clrw  Rfe                [NDS_Timer] = 0;     
8 3d17: 8b,01,9c,24,fe       cmpw  Rfe,[249c]                              
8 3d1c: d3,1e                jnc   3d3c               if ((uns) [NDS_Timer] < [1_sec_T9]) goto 3d3c;
8 3d1e: 20,0f                sjmp  3d2f               goto 3d2f;           

8 3d20: 34,b5,05             jnb   B4,Rb5,3d28        if ([flags3].NDS_Change == 0) goto 3d28;
8 3d23: 71,ef,b5             an2b  Rb5,ef             [flags3].NDS_Change = 0;
8 3d26: 01,fe                clrw  Rfe                [NDS_Timer] = 0;     
8 3d28: 8b,01,9e,24,fe       cmpw  Rfe,[249e]                              
8 3d2d: d9,0d                jgtu  3d3c               if ((uns) [NDS_Timer] > [1_sec_T9x]) goto 3d3c;
8 3d2f: bc,72,34             ldsbw R34,R72            R34 = (sig)[ECT_val];
8 3d32: a1,04,2b,32          ldw   R32,2b04           R32 = NDS_IDLE_CHANGE;
8 3d36: ef,86,f5             call  32bf               SSWordLU();          
8 3d39: 68,38,b8             sb2w  Rb8,R38            Rb8 -= R38;          
8 3d3c: 35,b7,05             jnb   B5,Rb7,3d44        if ([Rb7].Idle_Adjust == 0) goto 3d44;
//  add 75 rpm - Idle Speed Adjust                                                    //
8 3d3f: 67,01,a6,24,b8       ad2w  Rb8,[24a6]         Rb8 += [IdleAdjRPM]; 
8 3d44: c3,01,32,01,b8       stw   [132],Rb8          [Reqd_idle_RPM] = Rb8;
8 3d49: 48,b8,be,34          sb3w  R34,Rbe,Rb8        R34 = [Averaged_RPM] - Rb8;
8 3d4d: c3,01,34,01,34       stw   [134],R34          [Delta_ISC_RPM] = R34;
8 3d52: 3f,35,0c             jb    B7,R35,3d61        if (B7_R35) goto 3d61;
8 3d55: 8b,01,82,24,f4       cmpw  Rf4,[2482]                              
8 3d5a: d9,05                jgtu  3d61               if ((uns) [ISCTimer] > [ISC_2_secs]) goto 3d61;
8 3d5c: a0,ba,3e             ldw   R3e,Rba            R3e = Rba;           
8 3d5f: 20,59                sjmp  3dba               goto ISC_Set_Final;  

8 3d61: 71,7f,5a             an2b  R5a,7f             [Svc_flags].ISC_Tmr_reqd = 0;
8 3d64: a1,fc,29,32          ldw   R32,29fc           R32 = ISCxRPM;       
8 3d68: ef,54,f5             call  32bf               SSWordLU();          
8 3d6b: c3,01,36,01,38       stw   [136],R38          [ISC_val3] = R38;    
8 3d70: bc,72,34             ldsbw R34,R72            R34 = (sig)[ECT_val];
8 3d73: a1,24,2a,32          ldw   R32,2a24           R32 = ECT_LU2;       
8 3d77: ef,45,f5             call  32bf               SSWordLU();          
8 3d7a: c3,01,38,01,38       stw   [138],R38          [DBG_ISC_V5] = R38;  
8 3d7f: 31,b5,08             jnb   B1,Rb5,3d8a        if ([flags3].NDS_Drive == 0) goto 3d8a;
8 3d82: 6f,01,aa,24,38       ml2w  R38,[24aa]         R38 *= [NDS_Scaler]; 
8 3d87: 0c,07,38             shrdw R38,7              R38L = R38L / 80;    
8 3d8a: a3,01,36,01,32       ldw   R32,[136]          R32 = [ISC_val3];    
8 3d8f: 3f,33,17             jb    B7,R33,3da9        if (B7_R33) goto 3da9;
//  R38 = ECT_LU2(ECT_val)*ISC_PW_RPM(delta_rpm) (scale redundant)                    //
8 3d92: 6c,32,38             ml2w  R38,R32            R38 *= R32;          
8 3d95: 64,38,3c             ad2w  R3c,R38            R3c += R38;          
//  32 bit addition and overflow check follows                                        //
8 3d98: a4,3a,3e             adcw  R3e,R3a            R3e += R3a + CY;     
8 3d9b: 89,00,80,3e          cmpw  R3e,8000                                
8 3d9f: d3,19                jnc   3dba               if ((uns) R3e < 8000) goto ISC_Set_Final;
8 3da1: a1,00,80,3e          ldw   R3e,8000           R3e = 8000;          
8 3da5: 01,3c                clrw  R3c                R3c = 0;             
8 3da7: 20,11                sjmp  3dba               goto ISC_Set_Final;  

8 3da9: 03,32                negw  R32                R32 = -R32;          
8 3dab: 6c,32,38             ml2w  R38,R32            R38 *= R32;          
8 3dae: 68,38,3c             sb2w  R3c,R38            R3c -= R38;          
//  32 bit subtract                                                                   //
8 3db1: a8,3a,3e             sbbw  R3e,R3a            R3e -= R3a - CY;     
8 3db4: db,04                jc    3dba               if (R3e >= 0) goto ISC_Set_Final;
8 3db6: 01,3c                clrw  R3c                R3c = 0;             
//  add/subtract R38 from/to ISC_val_last (32 bit)                                    //
8 3db8: 01,3e                clrw  R3e                R3e = 0;             

ISC_Set_Final:
//       final ISC value in 32 bits, limit check, add NDS, ACC and lookup (slope ?) for final value       //

ISC_Set_Final:
8 3dba: 8b,01,7c,24,3e       cmpw  R3e,[247c]                              
8 3dbf: d9,05                jgtu  3dc6               if ((uns) R3e > [ISC_Min]) goto 3dc6;
//  10% minimum                                                                       //
8 3dc1: a3,01,7c,24,3e       ldw   R3e,[247c]         R3e = [ISC_Min];     
8 3dc6: c3,01,3c,01,3e       stw   [13c],R3e          [Last_ISC_H] = R3e;  
8 3dcb: c3,01,3a,01,3c       stw   [13a],R3c          [Last_ISC_L] = R3c;  
//  R34 = ISC_Val / 65536                                                             //
8 3dd0: a0,3e,34             ldw   R34,R3e            R34 = R3e;           
8 3dd3: 33,b5,05             jnb   B3,Rb5,3ddb        if ([flags3].ACC_On == 0) goto 3ddb;
//  +0%                                                                               //
8 3dd6: 67,01,7e,24,34       ad2w  R34,[247e]         R34 += [ISC_ACC_0];  
8 3ddb: 31,b5,05             jnb   B1,Rb5,3de3        if ([flags3].NDS_Drive == 0) goto 3de3;
//  +6.5% (65536 base)                                                                //
8 3dde: 67,01,80,24,34       ad2w  R34,[2480]         R34 += [ISC_NDS_4260];
8 3de3: a1,3c,2a,32          ldw   R32,2a3c           R32 = ISC_Slope;     
//  R34 is 0-65535 for 0-100% at this point                                           //
8 3de7: ef,d2,f4             call  32bc               UUWordLU();          

endfunc:
8 3dea: c3,01,30,01,38       stw   [130],R38          [ISC_PW_Final] = R38;
8 3def: e7,c6,ed             jump  2bb8               goto Main_EXIT;      

Timer_Update:
//                                                                                    //
//     Main Timer Update function                                                     //
//                                                                                    //
8 3df2: 3f,1a,05             jb    B7,R1a,3dfa        if ([IgnFlags].Cranking == 1) goto 3dfa;
//  Continue/Start 'Engine Runnning' Timer                                            //
8 3df5: 91,02,ae             orrb  Rae,2              [flags1].Running = 1;
8 3df8: 20,05                sjmp  3dff               goto 3dff;           

3dfa - Sub 8 3dfa:
8 3dfa: 71,fd,ae             an2b  Rae,fd             [flags1].Running = 0;
//  and Zero it                                                                       //
8 3dfd: 01,ea                clrw  Rea                [Run_Time] = 0;      

3dff - Sub 8 3dff:
8 3dff: ef,28,00             call  3e2a               Upd_Timers();        
8 3e02: e7,b3,ed             jump  2bb8               goto Main_EXIT;      



Timer_List:
//  Word, mSecs, Up (and next one)                                                    //
8 3e05: 22,de,22,e0,83,ea,02,ae                       Unknown Operation/Structure
//  Byte, 1/8s , Up                                                                   //
8 3e0d: 40,67,80,2d,80,f8,80,f9                       Unknown Operation/Structure
//   Are these dummy or for self test ?                                               //
8 3e15: 80,fa,80,fb,80,fc,80,fd                       Unknown Operation/Structure
//  Word, mSecs, Up (next 4)                                                          //
8 3e1d: 22,e6,22,4e,22,f4,22,fe                       Unknown Operation/Structure
//  Word, mSecs, Up  Count if $ae:5 = 0                                               //
8 3e25: 2b,c0,20,ae,00                                Unknown Operation/Structure


Upd_Timers:
//                                                                                                   //
//  Update Timers.                                                                                   //
//  NB. at 3e3c  R38 =(R38*256)/d055 is elapsed integer mSecs for 4.8uS timer [208.33 ticks per mS]  //
//                                                                                                   //
8 3e2a: a1,05,3e,30          ldw   R30,3e05           R30 = 3e05;          
8 3e2e: a0,06,36             ldw   R36,R06            R36 = IO_TIMER;      
8 3e31: 4b,01,44,01,36,38    sb3w  R38,R36,[144]      R38 = R36 - [Timers_last_run];
8 3e37: 01,3a                clrw  R3a                R3a = 0;             
8 3e39: 0d,08,38             shldw R38,8              R38L = R38L * 100;   
//  mS elapsed since last run                                                         //
8 3e3c: 8d,55,d0,38          divw  R38,d055           R38 = R38L / d055;   
8 3e40: 89,00,00,38          cmpw  R38,0                                   
//  return if 0 mSec elapsed                                                          //
8 3e44: d7,02                jne   3e48               if (R38 != 0) goto 3e48;
8 3e46: 20,88                sjmp  3ed0               goto 3ed0;           

3e48 - Sub 8 3e48:
8 3e48: 65,80,00,3a          ad2w  R3a,80             R3a += 80;           
8 3e4c: 08,08,3a             shrw  R3a,8              R3a = R3a / 100;     
8 3e4f: 48,3a,36,b8          sb3w  Rb8,R36,R3a        Rb8 = R36 - R3a;     
8 3e53: c3,01,44,01,b8       stw   [144],Rb8          [Timers_last_run] = Rb8;
//  New mSec(s)                                                                       //
8 3e58: b1,20,3e             ldb   R3e,20             R3e = 20;            
8 3e5b: 74,38,21             ad2b  R21,R38            [mS_Count] += R38;   
8 3e5e: 59,7d,21,3f          sb3b  R3f,R21,7d         R3f = [mS_Count] - 7d;
8 3e62: d3,0f                jnc   3e73               if (R3f < 0) goto Next_item;
//  cycle mS count around 0-125 mSecs i.e. 1/8ths sec                                 //
8 3e64: b0,3f,21             ldb   R21,R3f            [mS_Count] = R3f;    
//  New 8th sec                                                                       //
8 3e67: 91,40,3e             orrb  R3e,40             R3e |= 40;           
8 3e6a: e0,2a,06             djnz  R2a,3e73           [8ths_sec]--; if ([8ths_sec] !=  0) goto Next_item;
//  New sec                                                                           //
8 3e6d: 91,80,3e             orrb  R3e,80             R3e |= 80;           
8 3e70: b1,08,2a             ldb   R2a,8              [8ths_sec] = 8;      

Next_item:
8 3e73: b2,31,3c             ldb   R3c,[R30++]        R3c = [R30++];       
8 3e76: 99,00,3c             cmpb  R3c,0                                   
//  end of list, return                                                               //
8 3e79: df,55                je    3ed0               if (R3c == 0) goto 3ed0;
//  register (value) pointer                                                          //
8 3e7b: ae,31,32             ldzbw R32,[R30++]        R32 = (uns)[R30++];  
//  2 word entry, skip mask check                                                     //
8 3e7e: 30,3c,12             jnb   B0,R3c,3e93        if (!B0_R3c) goto 3e93;
//  4 word entry, get flags mask                                                      //
8 3e81: b2,31,3d             ldb   R3d,[R30++]        R3d = [R30++];       
//  get actual flags/register                                                         //
8 3e84: ae,31,34             ldzbw R34,[R30++]        R34 = (uns)[R30++];  
//  and mask them                                                                     //
8 3e87: 72,34,3d             an2b  R3d,[R34]          R3d &= [R34];        
//  Result <> 0 to count                                                              //
8 3e8a: 33,3c,04             jnb   B3,R3c,3e91        if (!B3_R3c) goto 3e91;
//  Result == 0 to count                                                              //
8 3e8d: df,04                je    3e93               if (R3d == [R34]) goto 3e93;
8 3e8f: 27,e2                sjmp  3e73               goto Next_item;      

3e91 - Sub 8 3e91:
8 3e91: df,e0                je    3e73               if (R3d == [R34]) goto Next_item;

3e93 - Sub 8 3e93:
8 3e93: 50,3c,3e,00          an3b  0,R3e,R3c          0 = R3e & R3c;       
//  No time bits overlap - skip count                                                 //
8 3e97: df,da                je    3e73               if (R3e != R3c) goto Next_item;
8 3e99: 31,3c,05             jnb   B1,R3c,3ea1        if (!B1_R3c) goto 3ea1;
//  Count size is word                                                                //
8 3e9c: a2,32,36             ldw   R36,[R32]          R36 = [R32];         
8 3e9f: 20,03                sjmp  3ea4               goto 3ea4;           

3ea1 - Sub 8 3ea1:
8 3ea1: be,32,36             ldsbw R36,[R32]          R36 = (sig)[R32];    
8 3ea4: 32,3c,04             jnb   B2,R3c,3eab        if (!B2_R3c) goto 3eab;
//  Negate if counting DOWN                                                           //
8 3ea7: 03,36                negw  R36                R36 = -R36;          
//  Skip ovf checks if cntg down and zero                                             //
8 3ea9: df,18                je    3ec3               if (R36 == R36) goto Save_Timer;
8 3eab: 3d,3c,04             jb    B5,R3c,3eb2        if (B5_R3c) goto 3eb2;
//  inc (dec) timer value if not mS based                                             //
8 3eae: 07,36                incw  R36                R36++;               
8 3eb0: 20,03                sjmp  3eb5               goto 3eb5;           

3eb2 - Sub 8 3eb2:
8 3eb2: 64,38,36             ad2w  R36,R38            R36 += R38;          
8 3eb5: d3,07                jnc   3ebe               if (R36 <= ffff) goto 3ebe;
//  overflow - reset value to zero (up).                                              //
8 3eb7: 01,36                clrw  R36                R36 = 0;             
8 3eb9: 3a,3c,07             jb    B2,R3c,3ec3        if (B2_R3c) goto Save_Timer;
//  overflow - reset value to max  (down)                                             //
8 3ebc: 05,36                decw  R36                R36--;               
8 3ebe: 32,3c,02             jnb   B2,R3c,3ec3        if (!B2_R3c) goto Save_Timer;
//  Negate (restore) if counting down                                                 //
8 3ec1: 03,36                negw  R36                R36 = -R36;          

Save_Timer:
8 3ec3: 31,3c,05             jnb   B1,R3c,3ecb        if (!B1_R3c) goto 3ecb;
//  save timer - word                                                                 //
8 3ec6: c2,32,36             stw   [R32],R36          [R32] = R36;         
8 3ec9: 27,a8                sjmp  3e73               goto Next_item;      

3ecb - Sub 8 3ecb:
8 3ecb: c6,32,36             stb   [R32],R36          [R32] = R36;         
8 3ece: 27,a3                sjmp  3e73               goto Next_item;      

8 3ed0: e7,e5,ec             jump  2bb8               goto Main_EXIT;      

CAL_CON:
//                                                                                    //
8 3ed3: f2                   pushp                    push(PSW);           
8 3ed4: a3,01,00,0d,30       ldw   R30,[d00]          R30 = [CC_d00];      
8 3ed9: 99,2a,31             cmpb  R31,2a                                  
8 3edc: df,0a                je    3ee8               if (R31 == 2a) goto 3ee8;
8 3ede: a1,5a,00,30          ldw   R30,5a             R30 = 5a;            
8 3ee2: 05,30                decw  R30                R30--;               
//  Delay, 90 loops and then skip CALCON call                                         //
8 3ee4: d2,fc                jgt   3ee2               if ((sig) R31 > R30) goto 3ee2;
8 3ee6: 20,03                sjmp  3eeb               goto 3eeb;           

3ee8 - Sub 8 3ee8:
8 3ee8: ef,15,91             call  d000               CC_d000();           
8 3eeb: fa                   di                       disable ints;        
8 3eec: ff                   ff                                            
8 3eed: f3                   popp                     pop(PSW);            
8 3eee: e7,c7,ec             jump  2bb8               goto Main_EXIT;      

Calc_EGR_PW:
//                                                                                    //
//  Answer EGR_PW appears scaled as 0-32768 = 20mS  #                                 //
//                                                                                    //
8 3ef1: b3,01,58,24,ba       ldb   Rba,[2458]         Rba = [EGR_Present]; 
8 3ef6: 99,00,ba             cmpb  Rba,0                                   
8 3ef9: df,70                je    3f6b               if (Rba == 0) goto 3f6b;
8 3efb: 99,01,ba             cmpb  Rba,1                                   
//  Fixed EGR pulswidth                                                               //
8 3efe: df,61                je    3f61               if (Rba == 1) goto 3f61;
//  not in test mode                                                                  //
8 3f00: 34,5a,2b             jnb   B4,R5a,3f2e        if ([Svc_flags].STI_Reqd == 0) goto 3f2e;
8 3f03: af,01,9a,24,32       ldzbw R32,[249a]         R32 = (uns)[32_secs];
8 3f08: 67,01,7a,24,32       ad2w  R32,[247a]         R32 += [3_secs];     
8 3f0d: 88,32,ea             cmpw  Rea,R32                                 
//  less than 35 secs                                                                 //
8 3f10: d1,1c                jleu  3f2e               if ((uns) [Run_Time] <= R32) goto 3f2e;
8 3f12: af,01,9b,24,30       ldzbw R30,[249b]         R30 = (uns)[Sc0090]; 
8 3f17: 64,30,32             ad2w  R32,R30            R32 += R30;          
8 3f1a: 88,32,ea             cmpw  Rea,R32                                 
//  Greater than 67 secs                                                              //
8 3f1d: d9,0f                jgtu  3f2e               if ((uns) [Run_Time] > R32) goto 3f2e;
//  20% on                                                                            //
8 3f1f: a3,01,96,24,ba       ldw   Rba,[2496]         Rba = [EGR_PW2];     
//  2 sec intervals ?                                                                 //
8 3f24: 39,ea,3f             jb    B1,Rea,3f66        if (B1_[Run_Time]) goto 3f66;
//  5% on                                                                             //
8 3f27: a3,01,98,24,ba       ldw   Rba,[2498]         Rba = [EGR_PW3];     
8 3f2c: 20,38                sjmp  3f66               goto 3f66;           

8 3f2e: b0,72,34             ldb   R34,R72            R34 = [ECT_val];     
8 3f31: a1,94,2a,32          ldw   R32,2a94           R32 = EGR_ECT;       
8 3f35: ef,67,f0             call  2f9f               SSByteLU();          
8 3f38: b0,38,b8             ldb   Rb8,R38            Rb8 = R38;           
8 3f3b: b0,73,34             ldb   R34,R73            R34 = [ACT_val];     
8 3f3e: a1,9e,2a,32          ldw   R32,2a9e           R32 = EGR_ACT;       
8 3f42: ef,5a,f0             call  2f9f               SSByteLU();          
//  both tabs fixed at 64 (=4096)                                                     //
8 3f45: 7c,38,b8             ml2b  Rb8,R38            Rb8 *= R38;          
8 3f48: a0,70,34             ldw   R34,R70            R34 = [RPM];         
8 3f4b: a1,a8,2a,32          ldw   R32,2aa8           R32 = RPM_SCALE_7;   
8 3f4f: ef,6a,f3             call  32bc               UUWordLU();          
8 3f52: a0,38,ba             ldw   Rba,R38            Rba = R38;           
8 3f55: a0,62,34             ldw   R34,R62            R34 = [Cyl_Mass_BK1];
8 3f58: 28,14                scall 3f6e               EGR_AECT_calc();     
8 3f5a: c3,01,40,01,32       stw   [140],R32          [EGR_PW] = R32;      
8 3f5f: 20,0a                sjmp  3f6b               goto 3f6b;           

3f61 - Sub 8 3f61:
8 3f61: a3,01,5a,24,ba       ldw   Rba,[245a]         Rba = [EGR_PW1];     
8 3f66: c3,01,40,01,ba       stw   [140],Rba          [EGR_PW] = Rba;      
8 3f6b: e7,4a,ec             jump  2bb8               goto Main_EXIT;      

EGR_AECT_calc:
8 3f6e: a1,bc,2a,32          ldw   R32,2abc           R32 = FLOW_SCALE_7;  
8 3f72: ef,47,f3             call  32bc               UUWordLU();          
//  scaled flow                                                                       //
8 3f75: a0,38,32             ldw   R32,R38            R32 = R38;           
//  multiplier from above                                                             //
8 3f78: a0,ba,30             ldw   R30,Rba            R30 = Rba;           
8 3f7b: a1,08,00,34          ldw   R34,8              R34 = 8;             
//  all 32 in table                                                                   //
8 3f7f: a1,14,27,38          ldw   R38,2714           R38 = EGR_PW_Tab;    
8 3f83: ef,f1,f2             call  3277               UTabLU();            
8 3f86: 11,3a                clrb  R3a                R3a = 0;             
//  =4096*32 = 131072                                                                 //
8 3f88: 4c,3a,b8,30          ml3w  R30,Rb8,R3a        R30 = Rb8 * R3a;     
//  R32 = 32                                                                          //
8 3f8c: 0d,04,30             shldw R30,4              R30L = R30L * 10;    
8 3f8f: 89,00,40,32          cmpw  R32,4000                                
8 3f93: d1,04                jleu  3f99               if ((uns) R32 <= 4000) goto 3f99;
8 3f95: a1,00,40,32          ldw   R32,4000           R32 = 4000;          
8 3f99: f0                   ret                      return;              



SubTaskList:
8 3f9a: d3,3e                3ed3  Bank 8 Vector      CAL_CON
8 3f9c: 17,30                3017  Bank 8 Vector      Process_Sensors
8 3f9e: 25,31                3125  Bank 8 Vector      Main_airflow_calc
8 3fa0: c9,31                31c9  Bank 8 Vector      Process_TPS
8 3fa2: 2e,32                322e  Bank 8 Vector      RPM_calc
8 3fa4: f2,3d                3df2  Bank 8 Vector      Timer_Update
8 3fa6: f4,33                33f4  Bank 8 Vector      Base_inj_calc
8 3fa8: b8,35                35b8  Bank 8 Vector      Enrich_Flow_calc
8 3faa: 41,36                3641  Bank 8 Vector      Cranking_Inj_Calc
8 3fac: 83,36                3683  Bank 8 Vector      Calc_Accelpump
8 3fae: d4,36                36d4  Bank 8 Vector      Load_Calc
8 3fb0: f1,36                36f1  Bank 8 Vector      Clip_Inj_Calc
8 3fb2: f2,3d                3df2  Bank 8 Vector      Timer_Update
8 3fb4: 1a,37                371a  Bank 8 Vector      Inject_Time_calc
8 3fb6: 47,39                3947  Bank 8 Vector      Trip_Calc
8 3fb8: da,2d                2dda  Bank 8 Vector      Spark_calc_1
8 3fba: eb,2d                2deb  Bank 8 Vector      IGN_clc3
8 3fbc: be,34                34be  Bank 8 Vector      Set_RPM_flags
8 3fbe: f2,3d                3df2  Bank 8 Vector      Timer_Update
8 3fc0: c2,39                39c2  Bank 8 Vector      Fuel_Pump
8 3fc2: 01,33                3301  Bank 8 Vector      Ign_Delta_Calc
8 3fc4: d0,39                39d0  Bank 8 Vector      Sensor_Test
8 3fc6: 1e,3c                3c1e  Bank 8 Vector      ISC_pw_calc
8 3fc8: f1,3e                3ef1  Bank 8 Vector      Calc_EGR_PW
8 3fca: f2,3d                3df2  Bank 8 Vector      Timer_Update


8 3fcc -> 3fff                     fill               ff
╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                      ║
║                                                  End of Disassembly                                                  ║
║                                                                                                                      ║
╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
