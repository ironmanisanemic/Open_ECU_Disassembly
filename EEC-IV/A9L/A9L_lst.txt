
########################################################################
#
#  Disassembly listing of binary 'A9L' (8061, 1 bank)
#
#  See 'A9L_msg.txt' for warnings, command list and other info
#
########################################################################
 


#################################################################################################### 
# Disassembly of Ford A9L EECIV
# Comments shamelessly stolen from various web listings and merged here
# 15Mhz Clock (2.4 uS HSI/HSO), ROM 2000-9fff, RAM 100-4ff, KAM 700-7ff ?
#####################################################################################################
#
# AD Channels:
# 0 TAR  1 VCAL  2 VPWR  3 OCC  4 SCCS  5 EGO2  6 MAF  7 TP  8 ECT  9 ACT A NDS  B EGO1  C EVP
#
# I/0 mappings:
# bitno or chan   0      1      2      3      4      5      6      7      8      9      10
# HSO: (chan)     INJ3   INJ4   INJ6   INJ7   INJ5   SPOUT  INJ1   INJ2   INJ8   KTS    S/W (1 mS)
# HSI: (bit)      PIP    KI     BP     STI           CID    VSS    IDM
# LSO: (bit)      SCVAC  DOL    EVR    ISC    SCVNT  MIL    ACC/WD FP
# BIDI:(bit)      ?      CANP   SHIFT  AM1    AM2    FAN    FANHI  ?
# 
# TAR   Throttle angle rate
# VCAL  Calibration constant (normally 2.5 volts)
# VPWR  Ignition key-on power 
# OCC   Open Circuit test voltage
# SCCS  Speed Control Command Switch
# EGO2  LH heated exhaust gas sensor (oxygen)
# MAF   Mass air flow sensor
# TP    Throttle position 
# ECT   Engine coolant temp sensor
# ACT   Air charge temp sensor
# NDS   PRNDL(AUTO) Clutch/Neutral(Manual)
# EGO1  RH heated exhaust sensor
# EVP   EGR valve position sensor
#
# INJn  Fuel Injectors 1 through 8
# KTS   pulsewidth (secs) of the charging pulse for knock sensing.
# SPOUT Spark output signal
# S/W   software interrupt - set every 1 millisec
#
# PIP   Profile ignition pickup
# KI    Knock indicated
# BP    Baromatic pressure sensor
# STI   Self test input
# CID   Camshaft Cyl No 1 identifier sensor
# VSS   Vehicle speed sensor
# IDM   Ignition diagnostic monitor
#
# SCVAC Speed Control Vacuum (speed control servo)
# DOL   Data Output Link 
# EVR   EGR Vacuum Regulator
# ISC   Idle Speed Control (Bypass air solenoid)
# SCVNT Speed Control Vent   (speed control servo)
# MIL   Self test ouput / Malfunction indicator Light
# WD    LOS watchdog - must be flipped every 4 ms - also used for ACC cutoff
# FP    Fuel Pump
#
# CANP  Canister Purge
# SHIFT Shift light/indicator
# AM2   Air management solenoid 2 (Thermactor Air Diverter)
# AM1   Air Management solenoid 1 (Thermactor Air Bypass)
# FAN   engine coooling fan
#
###############
# Register mappings:  Address, [Bit], Name,  notes 
#################
# standard I/O int regs etc (0-0x11)
# 0 (Zero)  always zero 
# 2  LSO_Port              bits 6 CPU_OK watchdog    7 LSO_Port
# 3  LIO_Port             
# 4  AD_Low               
# 5  AD_High              
# 6  IO_Timer             
# 8  INT_Mask             
# 9  INT_Pend             
# a  IO_Status             bits  0 HSO_OVF   1 HSI_OVF  2 HSI_Ready  3 AD_Ready  4 INT_Service
# b  HSI_Sample           
# c  HSI_Mask             
# d  HSI_Data             
# e  HSI_Time             
# 10 STACK                
# 12 Tmr_OVF_cnt           (word)
#
# 14 - 22 general use
#
# 24 Flags_24             
#  0 Wot = Wide Open Throttle
#  1 Ctnq = RPM is < 850
#  2 Awotmr_On = Run Timer if set
#  3 Pw_sign2 (?) 
#  4 Console_flag=Console in use
#  5 Nactmr_On = Run Timer if set
#  6 Atmr2_On    "
#  7 Tsegre_On    "
# 25 Flags_25             
#  0 Include_ae            Not Used ?
#  1 Warm_up               STI ignored if set ? below temp threshhold
#  2 Mhpfd_neg             
#  3 Fam_flg               
#  4 Slq2                  
#  5 Slq1                  
#  6 Chkair                
#  7 Chkair_flag           
# 26 Flags_26             
#  0 Imfmflg                MAF count out of range error
#  1 Archflg               
#  2 Nflg                  
#  3 Jmpflg                
#  4 Trsprpml              
#  5 Pipflg                
#  6 Dndsup                
#  7 Hcamfg                
# 27 Flags_27             
#  0 Swtfl2                
#  1 Dfsflg                
#  2 Fpwq2                 
#  3 Swtfl1                
#  4 Powsfg                Power Steering Flag
#  5 Booflg                
#  6 Lestmr2_On            
#  7 Lestmr1_On            
# 28 Flags_28             
#  0 Egren                  Egr enabled (zero at cranking)
#  1 Ptpflg                
#  2 Newsa                 
#  3 Efflg1                
#  4 Ramp_rich             
#  5 Egoste                
#  6 Fpwq3                 
#  7 Kam_error             
# 29 Flags_29             
#  0 Hltmr_Off             
#  1 Taq6                  
#  2 Qtpclol               
#  3 Taq1                  
#  4 Iacflg                
#  5 Aeoflg                
#  6 Evpout                
#  7 Egrflg                
# 2a VIP_flags             VIP mode flags (diagnostic testing flags)
#  0 Vscdt                 VSCDT Vehicle Speed Control thing
#  1 Vscst                 Vehicle Speed Control Self Test ?
#  2 Vip_enable            VIP enable (self tests? ) set after engine running for 10 seconds?
#  3 Disable_running       disable - 'running' after reset - never cleared
#  4 Disable_nostart       Set if hardware fault detected ? - never cleared
#  5 Self_test             engine is running
#  6 No_start              indicates KOEO test in progress (engine off)
#  7 Disable_vscdt         disable VSCDT after reset - never cleared
#
# 2b Flags_2B              - flags
#  0 Rvip_cyl_quit         Self Test Output trigger
#  1 Rvip_cyl_bal          Passed Cyl Balance Test ?
#  2 Sto_trigger           Self Test Output trigger - to turn off STO
#  3 Error_detected        Self test error marker
#  4 Disable_isc           Disable Idle Speed Control if set
#  5 Stiflg                STI input state
#  6 Egoste2               HEGO2 cross over voltage detected
#  7 Egoste1               HEGO1 cross over voltage detected
# 2c Flags_2C             
#  0 Idm_bypass            
#  1 Kflg_local            
#  2 Flags_2C              
#  3 Wigflg                
#  4 Sto_hyper             Sets STO time to 2mS instead of 0.5 secs ?
#  5 Disable_eolt          
#  6 Egrfg2                
#  7 Egrfg1                
# 2d Flags_2D             
#  0 Spout_pending         
#  1 Undsp_trans           
#  2 Double_edge           
#  3 No_fuel_save          
#  4 First_pip             Set at startup to await very first PIP interrupt (for intialisation etc)
#  5 Ctflg                 
#  6 Tipflg                
#  7 Tblsflg               
# 2e Flags_2E             
#  2 New_ibeta             
#  3 Simultaneous          
#  4 Sync_up_fuel          Fuel synchronization  request Set to request sequential injection? 
#  5 Base_fuel             
#  6 Synflg                Whether AE fuel is synchronous (1) or asynchronous (0). Initialized to 0.
#  7 Fuel_in_sync          Fuel synchronized with PIP - Sequential Injection in force ?
# 2f Flags_2F             
#  0 Vip_fuel_disable      
#  1 Fgs                   
#  2 Ocport_req            
#  3 Nlmt_flg              
#  4 Ptscr                 
#  5 Maf_pip              
#  6 New_idelay2           
#  7 New_idelay1           
#
# 30 - 42  General Use
#
# 44 HSOut_Flags           State of HSO (Output) lines (WORD)
#  0 Inj3_State            
#  1 Inj4_State            
#  2 Inj6_State            
#  3 Inj7_State            
#  4 Inj5_State            
#  5 Spout_state           
#  6 Inj1_State            
#  7 Inj2_State            
#  8 Inj8_State            
#
# 46 IO_Port_State         LSO image - sets LSO (R2) bits from this register
#  0 Scvac                 
#  1 Dol                  
#  2 Evr                  
#  3 Isc                  
#  4 Scvnt                 
#  5 Sto_state             
#  6 WOT_AC                
#  7 Pump                  
# 47 Flags_47               bidirectional IO (output) image - sets Low speed IO (R3) from this register
#  1 Canp                  
#  2 ShLight_On            
#  3 Sbs1                   Air management (thermactor)
#  4 Iac                    Air management (IAC)
#  5 Fan                   
#  6 Hi_fan                
#
# 48 - 4b General use
#
# 4c Flags_4C             
#  1 Bypass_time           Skips time check (set with Immediate?)
#  2 Bypass_limit          Set to disable max event count (12) in each time slice
#  3 Immediate             Set to cause immediate HSO output (do not queue)
#  4 No_service            Set for empty queue ?
#  5 Late_output           HSO output time has been missed
#  6 Queued                Events are queued (software queue)
#  7 No_queue              Set for no queued events ?
# 4d                       Not Used ?
# 4E Flags_4E              HSI bit flags
#  0 Hsi_error             Indicates an unexpected HS Interrupt Occurred
#  1 Kts_pending           
#  2 New_Bpv               New BAP average calc required 
#  3 New_rpm               new RPM calc reqd
#  4 New_idm               new IDM
#  5 New_sti                - etc -
#  6 New_bap               
#  7 New_pip               
# 4F Flags_4F              
#  0 Pip_double            A PIP 'double edge' (impossibly short time) has occurred - faulty sensor ?
#  1 Sto_quick             
#  2 Clkext_ovr            Timer overflow has occured (32 bit = 171.8 mins) 
#  3 Knock_detected        
#  4 Pending               
#  5 Canceled              
#  6 Knock_enabled         
#  7 Knock_occurred        
# 50 - 70  General use
# 72 Rp                    = 0x180 RAM Pointers, used as "Base+Offset" for indexed instructions
# 74 Rp2                   = 0x27e
# 76 Rp3                   = 0x37a 
# 78 Cp                    ROM Pointer 8eda  - overlaps F2 pointer, not obvious why
# 7a Event_time            (word)  
# 7c Event_timeH           (byte)
# 7d Cmd                   Used for STO output ?
# 7e Rtab                  Pointer to RAM table
# 80 HSO_time              Calculated HSO Time  (for any output via HSO) 
# 82 HSO_timeH             Calc HSO Time top 8 bits
# 83 HSI_State             Image of Last HSI byte (state of interupt bits) 
# 84-86  General
# 87 New_irqs              Image of HSI bits CHANGED since last HS Interrupt  
#  0 Pip_irq              
#  1 Knk_irq               these set for handler reqd.
#  2 Bap_irq              
#  5 Cid_irq              
#  6 Mph_irq              
#  7 Idm_irq              
# 88                       Used as ROM pointer in HSO output routine (cell no) 
# 8a                       Used as RAM pointer in HSO output routine (cell no) 
# 8C Reftime               master reference time, 24 bits 
# 8e ReftimeH              master reference time, 24 bits 
# 8f Wd_time               Time delta for watchdog reset
# 90 Last_HSI              Last HSI status (for bit changes)
# 91 Slice_ptr             pointer to 8 entries, each is count of HSO outputs queued. Per 5ms slice ?
# 92 TPtr                  pointer to HSO or Injection entries in tables in RAM (HSOTable, InjTTab)
# 94 - 96 General, but used in STO output
#
# 98 NOT USED ?
# 9a Bg_point              Mass flow after calculations (BAP, ACT etc)
# 9b Vsc_count            
# 9c Anpip1               
# 9d Anpip2               
# 9e Eftr                 
# 9f                       Initial Start value ECT - choke/enrich ?
# a0 Vsc_states           
#  0 Vsc_pulse             
#  1 Acc_req               
#  2 Hold_state            
#  3 Resum_state           
#  4 Accel_state           
#  5 Brake_state           
#  6 Coast_state           
#  7 On_state              
# a1 a1_Flags             
#  0 Adptmr_On             engine at operating temp ( 170 < temp < 226 ) 
#  1 Idleq                 eng RPM something?
#  2 Undsp                 underspeed, RPM < ?
#  3 Dmflg                 eng RPM something?
#  4 Egonflg               eng RPM something?
#  5 Purging               Canister Purge ?
#  6 Cttmr_On              eng RPM something?
#  7 Cranking              set if RPM > 50
# a2 AM                   
# a4 Ampem                
# a6 Nrmces               
# a8 Nrmrld               
# AA TP                    Throttle position ( )
# ac Tcstrl               
# AE Rpmx4                 engine RPMx4 ( ) - Raw from calc
# B0 ECT                   Engine Coolant Temperature in degrees Farenheit( )[multiply by 2]
# B1 ACT                   Air Charge Temperature in degrees Farenheit( )[multiply by 2]
# b2 Mphcnt               
# b3 Ppctr                
# b4 Pipcnt               
# b5 Vsc_flagsb            speed control flags = Cruise control
#  1 SCCS_error            Error ?
#  3 SCCS_Resume           Resume Button
#  4 SCCS_Accel            Accel  Button
#  5 SCCS_Coast            Coast  Button
#  6 SCCS_On               On     Button
#  7 SCCS_Off              Off    Button
# B6 Bapcnt                MAP(BP) counts per unit of time
# b7 Ifreq                 required ISC output frequency
# b8 Iscdty                required ISC duty cycle
# ba PIPHi_ETime           PIP high event time, 24 bits
# bc PIPHi_ETimeH          PIP high event time, 24 bits
# bd Kayctr                A counter to indicate how often to update MKAY (linked to PIPs per rev)
# be PIPH_PW               PIP hi-lo time delta (Pulsewidth)
# c0 Mkay                  Half period multiplier.  Corrects for average error caused by hall effect sensor in distributor and armature.
# c2 Saf                  
# c4 Vsc_flags            
#  0 Code_87               
#  1 Vsc_flags             
#  2 First_mph             Flag for very first VSS tick received. 
#  3 Vsc_state             
#  4 Vscq2                  
#  5 Vscq1                 
#  6 Vsc_vac_active        
#  7 Vsc_flags             
# c5 Fmem_flags           
#  0 Fmem_flags            
#  1 Bfmflag               
#  2 Pefmfag               
#  3 Mfmflag               
#  4 Tfmflag               
#  5 Afmflag               
#  6 Efmflag               
#  7 Cfmflag               
# c6 Dol_count            
# C8 Atmr1                 Seconds since start (i.e. time since exiting crank mode, Cranking = 0)
# C9 Atmr2                 Seconds since ECT became greater than TEMPFB  (Atmr2_On = 1)
# ca Flag_ca              
#  0 Asp_input             Do not use background timer for Filter subroutine call
#  1 Declflg               
#  2 Dfldl_hys_flag        
#  3 Dfsvs_hys_flag        
#  4 Ecadq3                
#  5 Ecadq2                
#  6 Ecadq1                
#  7 Usaflg                
# CB Awotmr                Time at WOT, sec. (Undsp = 1)
# CC Nddtim                Time since Neutral/Drive Switch State change, sec.
# CD Nactmr                Not at Closed throttle Timer, sec. (Awotmr_On = 1)
# CE Mfatmr                Managed Fuel Air Timer, sec.
# cf HQcnt                 Count of events in the HSO hardware queue.
# d0 Apt                  
# d1 Synctr                Pointer to injection delay table ? incremented by 32 and checked when syncing ?
# d2 Egrdc                
# d3                      
# d4 Vip_code             
# d5                      
# d6 STO_flags            
#  0 High_speed            
#  1 Lowspeed_repeat       
#  2 Low_speed             
#  3 Sto_working           
#  4 Sto_fast              sets STO time to 5 mS instead of 0.5 secs ?
#  5 Sto_code              
#  6 Sto_off               
#  7 Sto_on                
# d7 Tc_flags              Trouble Code Flags
#  0 Code_75               
#  1 Code_74               
#  2 Code_67_94            
#  3 Code_45_92            
#  4 Code_77_91            
#  5 Code_44_73            
#  6 Code_42_72            
#  7 Code_25_41            
# d8 Vip_flags3           
#  0 Sto_holdoff           
#  1 Vf1                   
#  2 Output_tst_mode       
#  3 Reqflg                
#  4 Sto_pending           
#  5 Code_48               
#  6 Vip_kam               Indicates KAM invalid for VIP.
#  7 Threshold_lvl         
# d9 Vip_flags4           
#  0 Vip_fp_override       Prevents fuel pump being checked for timeout (normally 1 sec) 
#  1 Goose                 
#  2 Onedigit_out          
#  3 Vip_knock             
#  4 Kam_codes             
#  5 Vvsfl1                
#  6 Vegrbp                
#  7 Rmspru                
#da Sto_time             
#dc Pip_counter          
#de Input_image           HSI changed bits, AND low speed changed input bits since last time
#e0 Inj_mode             
#e1 Tipret               
#e2 Retinc               
#e3 - e5 not used ?
#e6 Flags_e6             
#  0 Hwflgl                 
#  1 Hwflag                
#  2 Powoff                
#  3 Powon                 
#  4 Vhfnon                
#  5 Vlfnon                
#  6 Pfehp_flg             
#  7 Flags_e6              
#e7 Flag_e7              
#  0 Fofflg                Low speed limit - fire alternate injectors
#  1 Fgfflg                Flip state for alternate firing
#  2 Hspflg                High speed limit - alternate fuel/spark
#  3 Flg_dasmnq            
#  4 Fulq2                 
#  5 Ffulflg               Full Fuel ?
#  6 Pw_sign               - not used - ?
#  7 Ndsflg                 In 'Drive' if set
#e8 Flags_e8             
#  0 Ctntmr_dwn            Control flags for ctntmr 
#  1 Ctntmr_up             
#  2 Ctnflg                
#  3 Dcelq5                
#  4 Dcelq4                
#  5 Dcelq3                
#  6 Dcelq2                
#  7 Dcelq1                
#e9 Flags_e9             
#  0 Prld_ff               
#  1 Ldflg                 
#  2 Lospd_ect             
#  3 Hispd                 
#  4 Crnk_trans            
#  5 Hsfflg                
#  6 CanPurgeOK            
#  7 Ctptfg                
#ea Flags_ea             
#  0 Paccflg               
#  1 Biflg                 
#  2 Aciflg                
#  3 Accflg                
#  4 Acr_n                 
#  5 Acr_ect               
#  6 Egofl2                
#  7 Egofl1                
#eb Flags_eb             
#  0 Ol_cl_transition      
#  1 Sigpip                set when PIP is at narrow slot/signature PIP
#  2 Hmtmr_On             
#  3 Ctaflg                
#  4 Ctupr_flg             
#  5 Acn_flg               
#  6 Acect_flg             
#  7 Acwflg                
#ec Flag_ec              
#  0 Mfa_on                Managed Fuel Air State flag, set to 1 if MFA is being used.
#  1 Neuflg                
#  2 Psflag                
#  3 Refflg                
#  4 Tfq1                  
#  5 Bpuflg                
#  6 Sltmr_flgs            
#  7 Swtflg                
#ed Flags_ed             
#  0 Legofg2               
#  1 Legofg1               
#  2 Hvq2                  
#  3 Hvq1                  
#  4 Hcsdq                 
#  5 Fpwq1                 
#  6 Lugtmr_dwn            
#  7 Lugtmr_up             
#ee Flags_ee             
#  0 Swtfl                 
#  1 Egofl                 
#  2 Olflg                 
#  3 Qclol                 
#  4 Signdy                
#  5 Signdslp              
#  6 Indflg                
#  7 A3C                   
#ef Flags_ef             
#  0 Power_up              
#  1 Wmegol                
#  2 Wrmego                
#  3 Idlflg                
#  4 Byptmr_dwn            
#  5 Lesflg                
#  6 Prgflg                
#  7 Byptmr_up             
#
#F0 = 8c00  ROM 'Base' Pointers to data areas
#F2 = 8e5a  used as index pointers, i.e  "Base Reg+Offset" 
#F4 = 8fd6  Also R78 = 8eda ROM Pointer  
#F6 = 93a8
#F8 = 9430 
#FA = 97a8
#FC = 9a7e
#FE = 9e5a
#
# RAM locations 
# 100 TP_Filt               filtered TP (throttle Position)
# 102 EGR_Filt              filtered EVP (for EGR position ?)
# 104 EPT_Filt              filtered EPT (?)
# 106 EGO_Filt              Filtered EGO (?)
# 108 RPM_Filt1             filtered RPM A
# 10A BAP_Intvl             MAP/BP
# 10C Key_Pwr               KEYPWR reference voltage (Iivpwr)
# 10e OCC_Raw               Open circuit ref voltage ? Iocc
# 110 VSS_Raw               VCAL regulated voltage (2.5volts? )(Ivcal)
# 112 ECT_Raw               ECT raw AD (Iect)
# 114 ACT_Raw               ACT raw AD (Iact)
# 116 EVP_Raw               EVP raw AD (Ievp)
# 118 Vsc_Raw               not used here (Iacc nds)
# 11A NDS_Raw               NDS/A3C raw AD (multiplexed) (Iacc nds) 
# 11C EGO1_Raw              HEGO1 raw AD right side oxygen sensor (Iego1)
# 11E EGO2_Raw              HEGO2 raw AD (Iego2)
# 120 TAR_Raw               ? TAR Throttle position sensor rate NOT USED ? (Itar)
# 122 TPS_Raw               TP raw AD  (Itp)
# 124 MAF_Raw               MAF (raw) (read at 2D33) (Imaf)
# 126 TPS_Min               Minimum Value when throttle closed (RATCH - from filtered TPS)
# 128 EVP_Def               default EVP - if sensor is bad  (Eoff)
# 12A Cttmr                 Time at closed throttle timer (secs)(set with CTTMR FLG)
# 12C Purgdc               
# 130 Bap_Filtl             Filtered Barometric Pressure
# 132 Ffmtmr                FAM filter timer (sec)
# 134 Putmr                 Time since CPU power -up  (mSecs)
# 136 Baptmr                time since last BP pulse? (mS, counts up)
# 137 Hmtmr                 High Power Demand Timer, secs
# 138 Ctatmr                Closed Throttle Upstream Air Timer (sec)
# 139 Sltmr                 Shift Light Timer.
# 13A Adptmr                Adaptive fuel timer (sec)  ( 170 < ECT temp < 226 ?) 
# 13c Mintim2              
# 13E Tslpip                time since last PIP recieved
# 140 Eighths_ext          
# 142 Loop_time            
# 144 Ctntmr                Closed throttle neutral timer UP AND DOWN modes
# 145 Lugtmr                LOM load transition timer (sec)
# 146 Isctmr                RPM sampling timer ?
# 147 Multmr                Time since incrementing LAMMUL (msec)
# 148 Mfactr               
# 149 Prgtmr                Canister purge accumulation timer (sec) (PRGFLG)
# 14A Cprgtmr               Current Purge on time(PRGFLG)
# 14C Hltmr                 High Load Timer Time in 1/8 seconds. Incr only under high load, resets when not running under high load. High load is defined as a load (VE) greater tha
                           n 70% when warm or 80% when cold.
# 14d Atmr3                 Secs since Entering RUN Mode (Cttmr_On = 0) i.e. engine running 
# 14E Edftmr                ElectroDrive Fan Timer (Sec)
# 14F Crktmr                Time in CRANK Mode (1/8 sec)
# 150 Dltmr                 Decel fuel low load timer, sec.
# 152 Rannum               
# 154 Ipsibr               
# 156 Spkmul               
# 157 Iscflg               
# 158 Desmaf               
# 15a Dstpbr               
# 15c Daspot               
# 15e Fam                  
# 160 Ibgpsi               
# 162 Nlast                
# 164 Desnlo               
# 166 Dsdrpm               
# 168 Lammul               
# 16a Bgcnt                
# 16c Islast               
# 16e Egract               
# 170 Evp                   range checked EVP
# 172 Egrerr                
# 174 Desdp                 
# 176 Delpr                 Pressure drop across the control orifice
# 178 Dp                    
# 17a Preser                
# 17c Conpr                 
# 17e Desem                 
# 180 Injdly                Injector delay in degrees
# 182 Baseff1              
# 184 Baseff2              
# 186 Eftrffl              
# 188 Eftrff               
# 18a Basefft              
# 18c Aefuel               
# 18e Pwoff                
# 190 Inj_base             
# 192 Inj_pending          
# 194 Bias                 
# 196 Lbmf_inj1            
# 198 Lbmf_inj2            
# 19a Lbmf_i1              
# 19c Lbmf_i2              
# 19e Lbmf_i3              
# 1a0 Lbmf_i4              
# 1a2 Lbmf_i5              
# 1a4 Lbmf_i6              
# 1a6 Lbmf_i7              
# 1a8 Lbmf_i8              
# 1aa C14FIL                probably trouble codes stored from here to 1bd
# 1ac C14FIL               
# 1ae C32FIL               
# 1b0 C34FIL               
# 1b2 C41FIL               
# 1b4 C53FIL               
# 1b6 C56FIL               
# 1b8 C63FIL               
# 1ba C66FIL               
# 1BD C95FIL                
# 1C0 Miltmr                1/8 second timer for the MIL logic.
# 1C2 Outtmr                Time since NO START flag set?
# 1C4 Tslidm                Time since last idm
# 1C6 Vip_fpmtmr            VIP timer?
# 1C8 Tsstil                Time since Stiflg   (R2B bit 5) 
# 1C9 Vsstmr                Vehicle Speed Sensor Time (.125 Sec) (Test only? )
# 1CA Vip_timer_ex          VIP timer?
# 1FE Bp                    filtered BP
# 200 Mult_bp311           
# 202 Dslmbs1              
# 204 Dslmbs2              
# 206 Fuelpw1               Injector Pulse Width in ms for Bank 1 (port 0)
# 208 Fuelpw2               Injector Pulse Width in ms for Bank 2 (port 2)
# 20A Lambse1               Desired fuel ratio for the left side bank of injectors. 
# 20C Lambse2               Desired fuel ratio for the right side bank of injectors. Larger values mean LESS fuel
# 20e Delopt                Filtered desired EGR valve position.
# 210 Clflg                 Closed Loop Flag. 1 = closed loop. 0 = fuel mixture taken from Tables and functions without feedback and trim from the HEGOs
# 211 Vbat                  Battery Voltage Level [divided by 16]
# 212 Vcutout              
# 213 Acbtmr                Time since brake went on.(BIFLG)
# 214 Acwtmr                A/C Clutch Wide Open Throttle Time (Secs)
# 215 Wcotmr                A/C Clutch WOT Cutout Timer (1/8 Sec)
# 216 Acctmr                A/C Clutch Transition Timer (1/8 Sec)
# 218 Acitmr                Time since Idle Speed Control system was warned of impending increase in load (ACIFLG)
# 21C Aeload                Averaged (filtered) Load
# 21E Tsladv                Time since the spark was last advanced by the KNOCK Strategy(KNOCK ENABLED) mSec.
# 220 Nwotmr                Not at WOT (Wide Open Throttle) Timer. (sec)
# 222 Egrper               
# 224 Egrprf               
# 226 Htime_beta           
# 228 Htime_delta          
# 22a Tbart                
# 22b Spkadv               
# 22c Spkad0               
# 22d Spkad1               
# 22e Spkad2               
# 22f Spkad3               
# 230 Spkad4                
# 231 Spkad5               
# 232 Spkad6               
# 233 Spkad7               
# 234 Fuelflow1             
# 236 Fuelflow2             
# 238 Pipacl               
# 23a Dwlbst                
# 23c Dwell                 
# 23e Dwlbse                Base amount of DWELL as a function of VBAT and TEMDWL, sec. Initial value = 0.005.
# 240 Dwellms               
# 242 Post_image            
# 244 Ppereng               
# 246 Poffeng               
# 248 Spout_low_time       
# 24a Fuel_sum_l            
# 24c Fuel_sum_h           
# 24d Sparebyte1           
# 24e Vmaf                   
# 250 Maf                   The current measured mass air flow in Kg/Hr
# 252 Archg                
# 254 Archli               
# 256 Archi                
# 258 Archfg               
# 25A Filrc1                
# 25C Load                  engine LOAD (= VE?)
# 25E Peak_load            
# 260 Perload               PERCENT LOAD Volumetric Efficiency in percent
# 262 Debyma_fm            
# 264 Tsegre                Accumulated time EGR is enabled (sec)
# 266 Lestmr1               Seconds since EGO1 noswitch (Lestmr1_On = 1) i.e.lack of switching ?
# 267 Lestmr2               Seconds since EGO2 noswitch (Lestmr2_On = 1) i.e.lack of switching ?
# 27C RPM_Filt2             Filtered RPM B
# 288 Em                    EM - EGR Mass Flow
# 29A Saftot                Total advance in crank degress before TDC( )[divide by 4]
# 29E Tar                   scaled and translated TAR ?
# 2A8 Debtmr                VSCCS Debounce timer, sec.
# 2AC Mph_FiltA             filtered vehicle speed B  (MPH)
# 2B2 Mph_Raw               vehicle speed (MPH) unfiltered
# 2BB Tslmph                timer time since last VSS click
# 2BC Mph_Filt              filtered vehicle speed A  (MPH)
# 2BE Mphtiml1             
# 2C0 Mphtim1H             

##################################################################
# 2C5 HSOQ                  RAM based table for SPOUT, 8 injects and KTS?  (2c5-327)
# Format is 10 byte entries (5 bytes on, 5 bytes off)
# 0       link field.  FF if not in use (index to another 2C5 entry)
# 1       0 here to stop? (2C61) or index of corresponding 2284 table entry
# 2,3,4   24 bit IO time for HSO event
# 5       link field index to another 2C5 entry
# 6       index to corresponding 2284 Table entry
# 7,8,9   HSO Event time
##################################################################

# 2C5 = 3 (->2c8) to start chain ?
# 2C6 SvStack               Saved stack pointer - alternate stack used for interrupts and some tests
# 2C8 Q0                    First HSO queue entry - SPOUT  FF if inactive
# 2C9                      
# 2CA                      
# 2CB                      
# 2CE Prev_PIP_time         Last PIP time (24 Bit)
# 2D0 Prev_PIP_timeH        
#
# 2D1 Inj1_LAST             24 bit time  ( FROM L27EB, cylinder offset 0)
# 2D2                       
# 2D4 Q1                    (offset 0F) cylinder 1 HSO ch 6
# 2D5                       byte offset into 2C5 ?
# 2D6                       byte offset into 2284 Table?
# 2D7-2D9  HSO execution time for this channel
# 2D9                       (offset 14) +5
# 2D9                       offset link
# 2DA Next_spout_beta       offset into 2284 Table 5C[R74]
# 2DB
# 2DC
#
# 2DD Inj2_last             time hi 8 FROM L27EB (cylinder offset 1)
# 2DE                       time lo 16 FROM L27EB  THIS "LINK"24a7 TREATS THIS AS AN OFFSET 1 LINK ?
# 2DF
# 2E0 Q2                    cylinder 2 HSO 7
# 2e6 Spr264               
# 2e7 Inj3_last            
# 2EA Q3                    cylinder 3 HSO 0
# 2f0 Spare_26E            
# 2f1 Inj4_last            
# 2F4 Q4                    cylinder 4 HSO 1
# 2fb Inj5_last            
# 2FE Q5                    cylinder 5 HSO 4
# 305 Inj6_last            
# 208 Q6                    cylinder 6 HSO 2
# 309                       offset into 2284 Table
# 30f Inj7_last            
# 312 Q7                    cylinder 7 HSO 3
# 319 Inj8_last            
# 31C Q8                    cylinder 8 HSO 8
# 322 Q9                    9TH - KTS ?
# 323 Egrcnt2               
# 324 Egrper2               
# 325                       
# 326                       
#
#
# 328 Maf_time             
# 32a Amint                
# 32c Amint_temp           
# 32e Maf_ptr              
# 33a Sigkal                Signature PIP ratio / multiplier - for narrow slot (cyl 1) 
# 342 Serv_code_tab         base of Hard Trouble Code Error Table
# 3A8 A3CTMR                timer?
# 3AA Hwtmr                 timer?
# 3b4 Slice_0               8 values for time slice SPOUT (0.6ms ?)
# 3bc Sparek1              
# 3bd Mapsav               
# 3be Piplim               
# 3c0 Min_pip_dly          
# 3c2 Sim_min              
### End of RAM variables ?

# PWM Tables
# 7B4 Kamrf1                KAMRF1( )[divide by 256]
# 7B6 Kamrf2                Adaptive fuel strategy correction for bank1 - larger values ADD fuel
# 7EE KEptzer               filtered EVP saved in KAM

####################### Analog Inputs:
# 28A7                       and 2D29  MAF - reads AD h/w at saves to 124 = A4[R72]
# 2DC7                       calibrate for voltage? at in var D0[R74] = 2E4
# ACT - Air Charge Temperature - raw counts? MSB in 115, degrees Farenheit in RB1
# Important functions:
# 384E Update_AD             reads raw AD values and updates values
# 68FE Update_timers         timers - incr/decr Table of timer pointers
# 7BAE SaveTCode1            trouble code (BrkPt at 7BB8 and look at R1A)
# 827D HW_Check              8061 CPU and RAM test routines
# 8434 Sub119                change mode resets IO and starts run mode? (self test to run? )

# Important addresses:
# 786B Chkbase               set to zero to skip ROM checksum
# 780D Do_KOEO               Key On Engine Off (KOEO) Self -Tests
# 57FC                       code section to retard timing if overspeed (via VSS)
# 980D HSS_retard            table (mph).
#
##############################################################################

2000: ff                  nop                    
2001: fa                  di                     disable ints;
2002: 21,45               sjmp  2149             goto Initialise;


2004: 00,00,ff,df,00,ff,de,ec ??                                                   # FIXSUM to get to zero sum
 # Checksum Fix
200c: 00,a0               ??                                                       # End of ROM ?

200e: 5d,00               word     5d                                              # I/O times between console executions (->84c2)

2010: 51,27               vect  2751,            I_HSO_2                           # HSO Port Output 2
2012: 3d,27               vect  273d,            I_Timer_OVF                       # I/O Timer Overflow
2014: 50,27               vect  2750,            I_Ignore                          # A/D End of Conversion
2016: 50,27               vect  2750,            I_Ignore                          # HSI Port Input Data Available
2018: 50,27               vect  2750,            I_Ignore                          # External Interrupt Vector
201a: b9,25               vect  25b9,            I_HSO_1                           # HSO Port Output  1
201c: 50,27               vect  2750,            I_Ignore                          # HSI 1 Interrupt Vector
201e: 2b,27               vect  272b,            I_HSI_0                           # HSI 0 Interrupt Vector

################# 'Base + offset' (Rbase) register setup - used throughout -> Rf0 - Rfe

2020: 08                  byte    8                                                # no of regs
2021: 01                  byte    1

2022: 00,8c               word   8c00                                              # Rf0
2024: 5a,8e               word   8e5a
2026: d6,8f               word   8fd6
2028: a8,93               word   93a8
202a: 30,94               word   9430
202c: a8,97               word   97a8
202e: 7e,9a               word   9a7e
2030: 5a,9e               word   9e5a                                              # Rfe

#############################################################
# Master Reset Subroutine
#############################################################


  Reset_All:
2032: fa                  di                     disable ints;
2033: ff                  nop                    
2034: 11,0c               clrb  Rc               HSI_Mask = 0;                     # stop interrupts
2036: b0,2a,12            ldb   R12,R2a          Tmr_OVF_cnt = VIP_flags;          # save VIP mode
2039: a1,16,00,14         ldw   R14,16           R14 = 16;
203d: c6,15,00            stb   R0,[R14++]       [R14++] = 0;
2040: 17,05               incb  R5               WDG_Timer++;
2042: 89,8a,04,14         cmpw  R14,48a          
2046: d3,f5               jnc   203d             if ((uns) R14 < 48a) goto 203d;
2048: 51,60,12,14         an3b  R14,R12,60       R14 = Tmr_OVF_cnt & 60;
204c: d7,05               jne   2053             if (R14 = 0)  {
204e: 91,01,ef            orb   Ref,1            Power_up = 1;
2051: 20,03               sjmp  2056             goto 2056; }
2053: c4,2a,12            stb   R12,R2a          VIP_flags = Tmr_OVF_cnt;          # restore VIP mode
2056: 01,12               clrw  R12              Tmr_OVF_cnt = 0;
2058: a1,80,01,72         ldw   R72,180          Rp = Injdly;
205c: a1,7e,02,74         ldw   R74,27e          Rp2 = Tcf;                        # R72,R74,R76 RAM base ptrs
2060: a1,7a,03,76         ldw   R76,37a          Rp3 = 37a;

###########################
# Initialise various locations in memory, lists start at 862a
# 3 lists linked together
# each list has an address 'base' which is added to each address entry
# update is done with an OR, which allows checking
###########################

2064: a1,2a,86,14         ldw   R14,862a         R14 = 862a;
2068: 89,ff,ff,14         cmpw  R14,ffff                                           # outer loop
206c: df,20               je    208e             if (R14 = ffff) goto 208e;        # -1 = list processing done
206e: a2,15,1a            ldw   R1a,[R14++]      R1a = [R14++];                    # 'Base' address, in top byte (R1b)
2071: a2,15,16            ldw   R16,[R14++]      R16 = [R14++];                    # end of list (address of next list)
2074: 88,16,14            cmpw  R14,R16          
2077: db,0e               jc    2087             if (R14 > R16)  {
2079: b2,15,1a            ldb   R1a,[R14++]      R1a = [R14++];                    # get low byte of addr to init
207c: b2,1a,1c            ldb   R1c,[R1a]        R1c = [R1a];                      # get current contents
207f: 92,15,1c            orb   R1c,[R14++]      R1c |= [R14++];                   # OR byte from list
2082: c6,1a,1c            stb   R1c,[R1a]        [R1a] = R1c;                      # save new value
2085: 27,ed               sjmp  2074             goto 2074; }
2087: d9,a9               jgtu  2032             if ((uns) R1c > 0 ) goto Reset_All; # Error, try again
2089: a2,16,14            ldw   R14,[R16]        R14 = [R16];                      # Address of next list
208c: 27,da               sjmp  2068             goto 2068;

#####################now do rest of checks

208e: 91,10,24            orb   R24,10           Console_flag = 1;                 # engineering console 
2091: ef,1e,64            call  84b2             Check_console();                  # Init console if found
2094: ef,0c,65            call  85a3             Check_Kam_1();                    # verify KAM Table 1 (702-7AF)
2097: ef,5b,65            call  85f5             Check_Kam_2();                    # verify KAM Table 2 (7E4-7EC)
209a: a3,74,de,42         ldw   R42,[R74+de]     R42 = Load;                       # engine load (VE)
209e: c3,74,9e,42         stw   R42,[R74+9e]     Aeload = R42;                     # Averaged Load
20a2: 45,e2,01,f0,42      ad3w  R42,Rf0,1e2      R42 = Maf_tfr;
20a7: c3,76,b4,42         stw   R42,[R76+b4]     Maf_ptr = R42;                    # Save ptr to MAF tfr func
20ab: a3,f0,02,42         ldw   R42,[Rf0+2]      R42 = [8c02];
20af: c3,72,80,42         stw   R42,[R72+80]     TP_Filt = R42;                    # filtered TP to start value
20b3: b3,fc,53,b3         ldb   Rb3,[Rfc+53]     Ppctr = Pipnum;
20b7: b3,fa,31,42         ldb   R42,[Rfa+31]     R42 = Egr_type;                   # EGR Type (0=sonic, 1=PFE, 2=none)
20bb: 30,42,03            jnb   B0,R42,20c1      if (B0_R42 = 1)  {
20be: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # PFE EGR is present
20c1: a1,db,b6,42         ldw   R42,b6db         R42 = b6db;                       # = 1.428 for 8 cyl
20c5: b3,fe,07,30         ldb   R30,[Rfe+7]      R30 = PIPsC;                      # = 8 (PIPs per cycle)
20c9: 3b,30,04            jb    B3,R30,20d0      if (B3_R30 = 0)  {
20cc: a1,55,d5,42         ldw   R42,d555         R42 = d555; }                     # = 1.666 for 6 and 4 cyl
20d0: c3,76,c0,42         stw   R42,[R76+c0]     Sigkal = R42;                     # ratio for Signature PIP (cyl 1)
20d4: a3,01,ee,07,30      ldw   R30,[R0+7ee]     R30 = KEptzer;                    # get EVP from KAM
20d9: 8b,f3,38,01,30      cmpw  R30,[Rf2+138]    
20de: d1,07               jleu  20e7             if ((uns) R30 <= Veptll) goto 20e7;
20e0: 8b,f3,3a,01,30      cmpw  R30,[Rf2+13a]    
20e5: d3,09               jnc   20f0             if ((uns) R30 >= Vepthl)  {
20e7: a1,80,a2,30         ldw   R30,a280         R30 = a280;                       # default EVP if outside limits
20eb: c3,01,ee,07,30      stw   R30,[R0+7ee]     KEptzer = R30; }                  # filtered EVP saved in KAM
20f0: 11,09               clrb  R9               INT_Pend = 0;
20f2: 32,0a,06            jnb   B2,Ra,20fb       if (HSI_Ready = 1)  {
20f5: b0,0d,00            ldb   R0,Rd            R0 = HSI_Data;                    # Clear any pending HSI input data
20f8: ff                  nop                    
20f9: 27,f7               sjmp  20f2             goto 20f2; }
20fb: b0,0b,90            ldb   R90,Rb           Last_HSI = HSI_Sample;
20fe: b1,a1,08            ldb   R8,a1            INT_Mask = a1;                    # HSI0, HSO 1, HSO 2
2101: b1,87,0c            ldb   Rc,87            HSI_Mask = 87;                    # HSI line select
2104: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]      
2108: d7,03               jne   210d             if (0 = Kihp)  {
210a: b1,85,0c            ldb   Rc,85            HSI_Mask = 85; }                  # Drop chan 1 - No knock sensor 
210d: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
2111: df,03               je    2116             if (0 != Hpcid)  {
2113: 91,20,0c            orb   Rc,20            HSI_Mask |= 20; }                 # Add chan 5 - CID sensor 
2116: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
211a: df,03               je    211f             if (0 != Vstype)  {
211c: 91,40,0c            orb   Rc,40            HSI_Mask |= 40; }                 # Add chan 6 - VSS sensor

######## set up HSO event to tickle console every 5mS

211f: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
2124: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a;                     # Software Interrupt (ch 10) in 3 state times
2127: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
212b: df,0a               je    2137             if (0 != Tfi_dwell)  {
212d: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # not TFI controlled dwell, do SPOUT ?
2131: 91,08,4c            orb   R4c,8            Immediate = 1;                    # address in data Table - SPOUT(channel 5)?
2134: ef,86,02            call  23bd             Send_HSO_Cmd(); }
2137: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
213b: df,0a               je    2147             if (0 != Hphidres)  {
213d: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # High Data Rate Electronic Spark H/W 
2141: 91,08,4c            orb   R4c,8            Immediate = 1;                    # address in data Table - SPOUT(channel 5)?
2144: ef,76,02            call  23bd             Send_HSO_Cmd(); }
2147: fb                  ei                     enable ints;
2148: f0                  ret                    return;

#############################################################
# EEC main (background) loop - cycles thru these routines
# R9A (Bg_point) is current routine offset
# Runs subroutines in Table starting at index 0
## Jump here from RESET
#############################################################


  Initialise:
2149: 11,2a               clrb  R2a              VIP_flags = 0;                    # clear all VIP mode flags
214b: a1,8c,04,10         ldw   R10,48c          STACK = 48c;                      # set stack pointer
214f: 2e,e1               scall 2032             Reset_All();

  Backg_loop:
2151: 99,a4,9a            cmpb  R9a,a4           
2154: db,1c               jc    2172             if (Bg_point > a4)  {             # goto loopstop (DEAD) if too big
2156: ac,9a,30            ldzbw R30,R9a          R30 = (uns)Bg_point;              # routine num
2159: 65,8a,21,30         ad2w  R30,218a         R30 += 218a;                      # address of subroutine from list
215d: c9,51,21            push  2151             push(Backg_loop);                 # push return address
2160: ca,30               push  [R30]            push([R30]);                      # push subroutine address to stack
2162: a1,80,01,72         ldw   R72,180          Rp = Injdly;
2166: a1,7e,02,74         ldw   R74,27e          Rp2 = Tcf;
216a: a1,7a,03,76         ldw   R76,37a          Rp3 = 37a;                        # Reset RAM pointers every time through
216e: 75,02,9a            ad2b  R9a,2            Bg_point += 2;                    # next subroutine
2171: f0                  ret                    return; }                         # execute routine

2172: 27,fe               sjmp  2172             goto 2172;                        # LOOPSTOP - DEAD

#################################################################
# Update loop selection and restart loop
# from task list routine at 2151, do each of 3 loops
# LIST A - Normal Operation
# List B - KEOE Engine off self tests (and engine on cruise controls self test? )
# List C - KEOR Engine running self tests
#################################################################

  Set_Tasklist:
2174: 3e,2a,03            jb    B6,R2a,217a      if (No_start = 1) goto 217a;
2177: 31,2a,04            jnb   B1,R2a,217e      if (Vscst = 1)  {                 # Vehicle Speed Control Self Test ?
217a: b1,52,9a            ldb   R9a,52           Bg_point = 52;                    # set List B
217d: f0                  ret                    return; }

217e: 35,2a,04            jnb   B5,R2a,2185      if (Self_test = 1)  {
2181: b1,74,9a            ldb   R9a,74           Bg_point = 74;                    # set List C
2184: f0                  ret                    return; }

2185: b1,00,9a            ldb   R9a,0            Bg_point = 0;                     # set List A
2188: f0                  ret                    return;



2189: ff                        

####### Tasklist Subroutine Lists
####### List A - normal operation - no self tests

218a: b1,84               vect  84b1,            Check_ConsoleD#                    # Check console, init RF0 regs
218c: 5d,23               vect  235d,            check_KAM#                         # Validate/initialise KAM
218e: 52,58               vect  5852,            Update_dwell                      # Update Dwell
2190: 86,37               vect  3786,            set_rpm_flgs#                      # Set RPM Flags
2192: 2e,22               vect  222e,            Read_AD#                           # Read AD channels
2194: 4e,38               vect  384e,            Update_AD#                         # Read/update raw AD vals
2196: f3,37               vect  37f3,            Update_WOT#                        # Update WOT flag
2198: f4,4e               vect  4ef4,            Do_accelpump#
219a: 5a,3d               vect  3d5a,            Update_HWND                       # Update heated windshield flag
219c: e4,3c               vect  3ce4,            Update_MPH#                        # Update (MPH) vehicle speed values
219e: ac,3d               vect  3dac,            Update_rpm#                        # Update RPM?
21a0: dd,63               vect  63dd,            Update_AC#                         # Update A/C cutout and idle flags
21a2: d4,65               vect  65d4,            Set_Timers#
21a4: fe,68               vect  68fe,            Update_timers#                     # Update Timers
21a6: 8f,84               vect  848f,            Set_ign_timers#
21a8: ca,4c               vect  4cca,            Update_flDOL                      # Update fuel comsumption for DOL
21aa: 7c,3e               vect  3e7c,            Load_Calc
21ac: 30,85               vect  8530,            Evp_?                             # EVP something
21ae: ba,40               vect  40ba,            Update_Egr#                        # Update EGR stuff?
21b0: 41,41               vect  4141,            Check_spd_lim                     # Check for RPM and Speed limiters
21b2: a1,41               vect  41a1,            Update_clolp                      # Update closed loop flags
21b4: 00,47               vect  4700,            Adapt?                            # Adaptive something
21b6: d7,4a               vect  4ad7,            Calc_Fuel#
21b8: ee,50               vect  50ee,            Update_fpump#                      # Update fuel pump enable
21ba: 36,51               vect  5136,            Calc_EVP                          # EVP something - large function
21bc: d9,54               vect  54d9,            Calc_EGR#                          # EGR stuff
21be: c3,55               vect  55c3,            Update_advance#                    # Update spark advance
21c0: 17,6d               vect  6d17,            UPd_KnkRet#
21c2: 8c,64               vect  648c,            Update_fans#                       # Update ect cooling fans
21c4: 91,61               vect  6191,            Upd_air_mgt#
21c6: b5,62               vect  62b5,            Upd_HiFan
21c8: 35,63               vect  6335,            Upd_canpTm                        # Update Canister Purge timing
21ca: 66,65               vect  6566,            Upd_Thermactor1
21cc: b0,58               vect  58b0,            Update_Idle#                       # Update idle speed
21ce: c4,5e               vect  5ec4,            Upd_VSC#                           # SCCS stuff checks VBAT
21d0: 7b,6a               vect  6a7b,            Upd_ShiftL#                        # Update shift light
21d2: dd,6a               vect  6add,            Upd_Thermactor#
21d4: a1,65               vect  65a1,            Upd_Air_mgmnt#                     # Update Air Management
21d6: 2e,73               vect  732e,            Chk_Sensors#
21d8: 49,6e               vect  6e49,            Do_SelfTest#                       # diagnostic Self Tests
21da: 74,21               vect  2174,            Set_Tasklist#                      # recheck list A

################# List B - engine off self tests (and engine on cruise controls self test? )

21dc: b1,84               vect  84b1,            Check_ConsoleD                    # check console, init RF0 regs
21de: 86,37               vect  3786,            set_rpm_flgs                      # Set RPM Flags
21e0: 2e,22               vect  222e,            Read_AD                           # Read AD channels to Table
21e2: 4e,38               vect  384e,            Update_AD                         # Read/update raw AD vals
21e4: e4,3c               vect  3ce4,            Update_MPH                        # Update vehicle speed vals
21e6: ac,3d               vect  3dac,            Update_rpm                        # Update RPM
21e8: d4,65               vect  65d4,            Set_Timers
21ea: fe,68               vect  68fe,            Update_timers                     # Update Timers
21ec: 8f,84               vect  848f,            Set_ign_timers
21ee: ba,40               vect  40ba,            Update_Egr                        # Update EGR stuff?
21f0: d7,4a               vect  4ad7,            Calc_Fuel
21f2: ee,50               vect  50ee,            Update_fpump                      # Update fuel pump enable
21f4: e7,5e               vect  5ee7,            Upd_SCCS                          # Update Vehicle Speed Control
21f6: 49,6e               vect  6e49,            Do_SelfTest                       # Diagnostic Self Tests
21f8: 87,55               vect  5587,            Update_EGR2                       # Update EGR stuff
21fa: ca,63               vect  63ca,            Upd_canP                          # Update Canister Purge
21fc: 74,21               vect  2174,            Set_Tasklist                      # Recheck list B

######### List C - engine running self tests

21fe: b1,84               vect  84b1,            Check_ConsoleD                    # Check console, init RF0 regs
2200: 2e,22               vect  222e,            Read_AD                           # Read AD channels
2202: 4e,38               vect  384e,            Update_AD                         # Read/update raw AD vals
2204: f3,37               vect  37f3,            Update_WOT                        # Update WOT flag
2206: e4,3c               vect  3ce4,            Update_MPH                        # Update vehicle speed values
2208: 52,58               vect  5852,            Update_dwell                      # Update Dwell
220a: ac,3d               vect  3dac,            Update_rpm                        # Update RPM
220c: d4,65               vect  65d4,            Set_Timers
220e: fe,68               vect  68fe,            Update_timers                     # Update Timers
2210: 8f,84               vect  848f,            Set_ign_timers
2212: ca,4c               vect  4cca,            Update_flDOL                      # Update fuel comsumption for DOL
2214: 7c,3e               vect  3e7c,            Load_Calc
2216: ba,40               vect  40ba,            Update_Egr                        # Update EGR stuff?
2218: 5b,4b               vect  4b5b,            Sub19                             # Something Injection ?
221a: f4,4e               vect  4ef4,            Do_accelpump
221c: ee,50               vect  50ee,            Update_fpump                      # Update fuel pump enable
221e: b0,58               vect  58b0,            Update_Idle                       # Ccheck idle speed?
2220: c4,5e               vect  5ec4,            Upd_VSC                           # SCCS stuff checks VBAT
2222: 3f,82               vect  823f,            CHk_HEGO                          # Check HEGO sensors
2224: 28,82               vect  8228,            Sub115                            # Check brake and PS flags
2226: 49,6e               vect  6e49,            Do_SelfTest                       # Ddiagnostic Self Tests
2228: 87,55               vect  5587,            Update_EGR2                       # Update EGR stuff
222a: ca,63               vect  63ca,            Upd_canP                          # Update Canister Purge
222c: 74,21               vect  2174,            Set_Tasklist                      # List C (rechecks List)

#################################################################
# Save A to D values.  Definitons in Structure at 225f
#################################################################


  Read_AD:
222e: a1,5f,22,30         ldw   R30,225f         R30 = 225f;                       # A/D Lookup Structure
2232: fb                  ei                     enable ints;
2233: 56,30,00,04         ad3b  R4,R0,[R30]      AD_Cmd = [R30];                   # get, and set, AD channel reqd
2237: de,22               jlt   225b             if (AD_Cmd < 0) goto 225b;        # exit if no more channels
2239: 33,0a,fd            jnb   B3,Ra,2239       if (AD_Ready = 0) goto 2239;      # wait for AD ready
223c: fa                  di                     disable ints;
223d: ff                  nop                    
223e: 51,0f,04,34         an3b  R34,R4,f         R34 = AD_Low & f;                 # get channel returned
2242: 9a,30,34            cmpb  R34,[R30]                                          # check correct channel
2245: d7,eb               jne   2232             if (R34 != [R30]) goto 2232;      # No, try read again
2247: 51,f0,04,34         an3b  R34,R4,f0        R34 = AD_Low & f0;                # AD Low value
224b: b0,05,35            ldb   R35,R5           R35 = AD_High;                    # AD High value
224e: 07,30               incw  R30              R30++;                            # incr ptr to save address
2250: b2,31,32            ldb   R32,[R30++]      R32 = [R30++];
2253: b2,31,33            ldb   R33,[R30++]      R33 = [R30++];                    # get destination address (hi+lo)
2256: c2,32,34            stw   R34,[R32]        [R32] = R34;                      # save AD value to destination.
2259: 27,d7               sjmp  2232             goto 2232;                        # next AD
225b: 91,40,29            orb   R29,40           Evpout = 1;
225e: f0                  ret                    return;

#############################################################
# A/D Definition.  3 byte entries
# byte 1   = A/D channel no (0-12) 
# byte 2&3 = destination address
# NB AD Ch 6 (MAF) is read and saved elsewhere, to 0x124
#############################################################



225f: 00,20,01   struct           0,TAR_Raw                                        # Throttle position sensor rate
2262: 01,10,01   struct           1,VSS_Raw                                        # Voltage Calibration Level
2265: 02,0c,01   struct           2,Key_Pwr                                        # Voltage level (->793d)
2268: 03,0e,01   struct           3,OCC_Raw                                        # Open Circuit Check
226b: 04,18,01   struct           4,Vsc_Raw                                        # Speed control system
226e: 05,1e,01   struct           5,EGO2_Raw                                       # Exhaust Gas Oxygen sensor 2
2271: 07,22,01   struct           7,TPS_Raw                                        # Throttle position sensor (->794d)
2274: 08,12,01   struct           8,ECT_Raw                                        # Engine Coolant Temperature
2277: 09,14,01   struct           9,ACT_Raw                                        # Air charge temperature
227a: 0a,1a,01   struct           a,NDS_Raw                                        # Auto shift posn (neutral/drive) NDS
227d: 0b,1c,01   struct           b,EGO1_Raw                                       # Exhaust Gas Oxygen sensor 1
2280: 0c,16,01   struct           c,EVP_Raw                                        # EGR Valve position
2283: ff         byte           ##  terminator                                     # end of Table

##########################
# Table used for High Speed Output (HSO).  Called from several places
# 8 byte entries are - 
# Offset  Description
# 0,1  Subroutine call address
# 3  HSO command to send, plus bits 6&7
#    B6 = 1 Don't keep o/p state in HSOut_Flags   
#    B7 = 1 Do extra subroutine at [ptr+6] if set (only in Do_CmdP)   
# 4  Max count of Queued HSO events (hardware is 12 max) skip if higher
# 5  Offset for this entry into RAM table at 2C5
# 6,7  Subroutine call address
# commands entries are therefore 
# 2286  ch 9 (KTS)    ON, no int, don't keep state, call Do_CmdN  ? don't call Add_H_Delta
# 228e  ch 9 (KTS)   OFF, int  , no ON, clear bit 9  call Do_CmdP then calls Add_H_Beta
# 2296  ch 5 (SPOUT)  ON, no int, don't keep state, call Do_CmdN  ? don't call Add_SpoutLo
# 229e  ch 5 (SPOUT) OFF, int  , no ON, clear bit 5  call Do_CmdP then calls upd_Htime_pend
############################################


  HSOTable:
2284: 58,23               vect  2358,            Clr_cell

2286: f9,24,00,59,0b,5d,11,6d   struct Do_CmdN,  0, 59,  b,Q9,Add_H_Delta
228e: 0d,25,00,c9,0b,5d,d8,6c   struct Do_CmdP,  0, c9,  b,Q9,Add_H_Beta
2296: f9,24,00,55,0c,03,88,2c   struct Do_CmdN,  0, 55,  c,Q0,Add_SpoutLo
229e: 0d,25,00,c5,0c,03,61,2c   struct Do_CmdP,  0, c5,  c,Q0,upd_Htime_pend

##################################################################
# Injector timing Table. 22 bytes per cyl (12 ON, 10 OFF ?) 
# (Offset, Size, Purpose)
# 0  subroutine call - 325a is 'Send HSO' command
# 2  ?
# 3  byte HSO (ON) command to send
# 4  byte 10  = count of or max for HSO queue ?
# 5  byte offset into 2C5 scheduling Table
# 6  byte bit mask for setting
# 7  byte bit mask for clearing
# 8  word injector cyl no (port no)
# A  word bit mask
# #######################
# C  (0) Subroutine call - 3273 is 'Send HSO' Command 
# F  (3) byte HSO (OFF) command to send
# 10 (4) byte 12 = count of or max for HSO queue ?
# 11 (5) byte offset into 2C5 scheduling Table
# 12 (6) byte bit mask for setting
# 13 (7) byte bit mask for clearing
# 14 (8) word injector cyl no (port no)

##################################################################


  InjTTab:
22a6: 5a,32,00,16,0a,0f,01,fe,01,00,40,00   struct Sub6,  0, 16,  a,Q1,  1, fe,1,   40,
22b2: 73,32,00,06,0c,0f,01,fe,01,00         struct Sub7,  0,  6,  c,Q1,  1, fe,1
22bc: 5a,32,00,17,0a,1b,02,fd,02,00,80,00   struct Sub6,  0, 17,  a,Q2,  2, fd,2,   80,
22c8: 73,32,00,07,0c,1b,02,fd,02,00         struct Sub7,  0,  7,  c,Q2,  2, fd,2
22d2: 5a,32,00,10,0a,25,04,fb,03,00,01,00   struct Sub6,  0, 10,  a,Q3,  4, fb,3,    1,
22de: 73,32,00,00,0c,25,04,fb,03,00         struct Sub7,  0,  0,  c,Q3,  4, fb,3
22e8: 5a,32,00,11,0a,2f,08,f7,04,00,02,00   struct Sub6,  0, 11,  a,Q4,  8, f7,4,    2,
22f4: 73,32,00,01,0c,2f,08,f7,04,00         struct Sub7,  0,  1,  c,Q4,  8, f7,4
22fe: 5a,32,00,14,0a,39,10,ef,05,00,10,00   struct Sub6,  0, 14,  a,Q5, 10, ef,5,   10,
230a: 73,32,00,04,0c,39,10,ef,05,00         struct Sub7,  0,  4,  c,Q5, 10, ef,5
2314: 5a,32,00,12,0a,43,20,df,06,00,04,00   struct Sub6,  0, 12,  a,Q6, 20, df,6,    4,
2320: 73,32,00,02,0c,43,20,df,06,00         struct Sub7,  0,  2,  c,Q6, 20, df,6
232a: 5a,32,00,13,0a,4d,40,bf,07,00,08,00   struct Sub6,  0, 13,  a,Q7, 40, bf,7,    8,
2336: 73,32,00,03,0c,4d,40,bf,07,00         struct Sub7,  0,  3,  c,Q7, 40, bf,7
2340: 5a,32,00,18,0a,57,80,7f,08,00,00,01   struct Sub6,  0, 18,  a,Q8, 80, 7f,8,  100,
234c: 73,32,00,08,0c,57,80,7f,08,00         struct Sub7,  0,  8,  c,Q8, 80, 7f,8

2356: 07,00               word      7

##################################################################
# called from HSOTable
##################################################################


  Clr_cell:
2358: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
235c: f0                  ret                    return;

#################################################################
# Validate KAM signature and initialize if invalid
##################################################################


  check_KAM:
235d: a1,5a,07,22         ldw   R22,75a          R22 = Ktmtb200;
2361: 71,7f,28            an2b  R28,7f           Kam_error = 0;
2364: b1,aa,42            ldb   R42,aa           R42 = aa;                         # to check KAM signature
2367: b1,c6,30            ldb   R30,c6           R30 = c6;
236a: b1,75,32            ldb   R32,75           R32 = 75;
236d: 9b,22,a6,42         cmpb  R42,[R22+a6]     
2371: d7,0f               jne   2382             if (R42 = [R22-5a])  {
2373: 9b,22,56,30         cmpb  R30,[R22+56]     
2377: d7,09               jne   2382             if (R30 = [R22+56])  {
2379: 9b,23,88,00,32      cmpb  R32,[R22+88]     
237e: d7,02               jne   2382             if (R32 != [R22+88]) goto 2382;
2380: 20,3a               sjmp  23bc             return; } }                       # KAM valid
2382: 91,80,28            orb   R28,80           Kam_error = 1;                    # KAM invalid
2385: c7,22,a6,42         stb   R42,[R22+a6]     [R22-5a] = R42;                   # 700 = 0xAA
2389: c7,22,56,30         stb   R30,[R22+56]     [R22+56] = R30;                   # 7b0 = 0xC6
238d: c7,23,88,00,32      stb   R32,[R22+88]     [R22+88] = R32;                   # 7e2 = 0x75
2392: 91,40,d8            orb   Rd8,40           Vip_kam = 1;
2395: ef,08,54            call  77a0             clear_KAM();
2398: a1,80,a2,38         ldw   R38,a280         R38 = a280;                       # default EVP value
239c: c3,01,ee,07,38      stw   R38,[R0+7ee]     KEptzer = R38;                    # Rolling avg of EPT sensor at Idle (counts)
23a1: ef,2f,62            call  85d3             Sub121();                         # Init tables at 703 and 759
23a4: a1,04,00,32         ldw   R32,4            R32 = 4;
23a8: a1,e4,07,30         ldw   R30,7e4          R30 = KIsckam0L;
23ac: c2,31,00            stw   R0,[R30++]       [R30++] = 0;                      # clear Idle Speed KAM IPSIBR cells
23af: e0,32,fa            djnz  R32,23ac         R32--;
                                                 if (R32 != 0) goto 23ac;
23b2: c3,01,ec,07,00      stw   R0,[R0+7ec]      KIsksum = 0;
23b7: c7,22,66,00         stb   R0,[R22+66]      [R22+66] = 0;                     # Clear KAM Flags (7C0)
23bb: f0                  ret                    return;

23bc: f0                  ret                    return;

###############################################################
# Send command to HSO, does actual output
# Input Parameter Registers:
# R80,1,2 = 24 bit time to fire event
# [R92 + 3] = HSO Command to send
# R92 points to one of 2284 entries
# Updates state in HSOut_Flags if B6 of HSO Command is NOT set
# sends injector pulses via HSO outputs
# NOTE - this proc short cuts the caller, forcing its exit, if no queue flag is set
###############################################################



  Send_HSO_Cmd:
23bd: b3,92,03,7d         ldb   R7d,[R92+3]      Cmd = [TPtr+3];                   # HSO command to send 
23c1: 71,8f,4c            an2b  R4c,8f           No_service = 0;
                                                 Late_output = 0;
                                                 Queued = 0;
23c4: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;
23c8: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
23cb: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                   # Add Delta to master time (24 bit)
23ce: 3b,4c,34            jb    B3,R4c,2405      if (Immediate = 1) goto 2405;
23d1: 39,4c,26            jb    B1,R4c,23fa      if (Bypass_time = 1) goto 23fa;
23d4: 48,8c,80,84         sb3w  R84,R80,R8c      R84 = HSO_time - Reftime;
23d8: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
23db: b8,8e,86            sbbb  R86,R8e          R86 -= ReftimeH - CY;             # time until event needs to fire (24 bit)
23de: 3f,86,24            jb    B7,R86,2405      if (B7_R86 = 1) goto 2405;        # Event time has passed - do immediately?
23e1: d7,0c               jne   23ef             if (R86 != 0) goto 23ef;          # time delta > 65535 IO times
23e3: 89,0c,00,84         cmpw  R84,c            
23e7: d3,1c               jnc   2405             if ((uns) R84 < c) goto 2405;     # time < 29 uS - do immediately
23e9: 89,46,04,84         cmpw  R84,446          
23ed: d3,0b               jnc   23fa             if ((uns) R84 < 446) goto 23fa;
23ef: 3f,4c,65            jb    B7,R4c,2457      if (No_queue = 1) goto 2457;      # time > 2.625 mS  - skip
23f2: 71,20,4c            an2b  R4c,20           B0_Flags_4C = 0;
                                                 Bypass_time = 0;
                                                 Bypass_limit = 0;
                                                 Immediate = 0;
                                                 No_service = 0;
                                                 Queued = 0;
                                                 No_queue = 0;
23f5: 91,40,4c            orb   R4c,40           Queued = 1;
23f8: 20,63               sjmp  245d             goto Sched_HSO;                   # schedule command execution (via 2284/2C5 Table)
23fa: 3a,4c,16            jb    B2,R4c,2413      if (Bypass_limit = 1) goto 2413;
23fd: 9b,92,04,cf         cmpb  Rcf,[R92+4]                                        # compare to [Table+4] - count?
2401: d3,10               jnc   2413             if ((uns) HQcnt < [TPtr+4]) goto 2413;
2403: 27,ea               sjmp  23ef             goto 23ef;                        # jmp back to schedule a task
2405: 91,28,4c            orb   R4c,28           Immediate = 1;
                                                 Late_output = 1;
2408: b0,8e,82            ldb   R82,R8e          HSO_timeH = ReftimeH;
240b: 45,0d,00,8c,80      ad3w  R80,R8c,d        HSO_time = Reftime + d;
2410: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
2413: 30,0a,05            jnb   B0,Ra,241b       if (HSO_OVF = 1)  {               # HSO output overflow
2416: b1,0c,cf            ldb   Rcf,c            HQcnt = c;
2419: 27,d4               sjmp  23ef             goto 23ef; }                      # jmp back to schedule a task

########### Set up HSO entry in h/w
241b: 49,01,00,80,0e      sb3w  Re,R80,1         HSO_Time = HSO_time - 1;          # set output change time
2420: b0,7d,0d            ldb   Rd,R7d           HSO_Cmd = Cmd;                    # command to send - from R92 entry[3]
2423: 3b,4c,17            jb    B3,R4c,243d      if (Immediate = 0)  {
2426: 3a,4c,14            jb    B2,R4c,243d      if (Bypass_limit = 0)  {
2429: 01,84               clrw  R84              R84 = 0;
242b: 51,07,81,84         an3b  R84,R81,7        R84 = R81 & 7;                    # = (timelo/256) & 7
242f: b3,85,b4,03,86      ldb   R86,[R84+3b4]    R86 = [R84+Slice_0];              # each slice is event count, in 614uS (0.6mS) slots ?
2434: 17,86               incb  R86              R86++;
2436: c7,85,b4,03,86      stb   R86,[R84+3b4]    [R84+Slice_0] = R86;              # increment relevent slice
243b: 17,cf               incb  Rcf              HQcnt++; } }
243d: 71,71,4c            an2b  R4c,71           Bypass_time = 0;
                                                 Bypass_limit = 0;
                                                 Immediate = 0;
                                                 No_queue = 0;
2440: 3e,7d,13            jb    B6,R7d,2456      if (B6_Cmd = 1) return;
2443: 51,0f,7d,86         an3b  R86,R7d,f        R86 = Cmd & f;
2447: ad,01,84            ldzbw R84,1            R84 = (uns)1;
244a: 09,86,84            shlw  R84,R86          R84 <<= R86;
244d: 80,84,44            orw   R44,R84          HSOut_Flags |= R84;
2450: 3c,7d,03            jb    B4,R7d,2456      if (B4_Cmd = 1) return;
2453: 84,84,44            xrw   R44,R84          HSOut_Flags ^= R84; }             # keep state (on or off)
2456: f0                  ret                    return;

2457: b1,10,4c            ldb   R4c,10           Flags_4C = 10;                    # flags = No_service =1 others 0
245a: cc,00               pop   R0               R0 = pop();                       # SHORT CUT, return to GRANDcaller
245c: f0                  ret                    return;

##############################################################
# This proc defines a PWM ON or OFF event.
# The volatile info (time etc) are saved in the 2C5 Table in spots from
# 2284 Table  2286(ON), 228E(OFF), 2296(ON), 229E(OFF)
# R80/81/82 24 bit time for event to execute (call events execute proc)
# R92 - pointer to one of the two sides (on or off) of the event pairs in 2284 Table
# 22A6 Table is valid too (ie 22B6)
# check if this functions entry is currently scheduled
# reserved for each ROM Table entry ( ROM offset 5 points to 2C5 Table entry)
# schedule subroutine for timed execution
#
# link (2c5) first byte is status ? jmps to activate if N=1, FF = NOT  scheduled
##############################################################


  Sched_HSO:
245d: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];             # = 2C5 RAM Table offset for this entry
2461: 57,7f,c5,02,00,88   ad3b  R88,R0,[R7e+2c5] R88 = [Rtab+HSOQ];                # = 1st byte(link) of 2C5 entry
2467: de,1a               jlt   2483             if (R88 >= 0)  {
2469: b1,ff,8a            ldb   R8a,ff           R8a = ff;                         # FF = out of service
246c: c7,7f,c5,02,8a      stb   R8a,[R7e+2c5]    [Rtab+HSOQ] = R8a;                # = link deactivated
2471: 57,7f,ca,02,00,8a   ad3b  R8a,R0,[R7e+2ca] R8a = [Rtab+2ca];                 # +5, link to next entry (OFF?)
2477: c7,89,c5,02,8a      stb   R8a,[R88+2c5]    [R88+HSOQ] = R8a;                 # = link deactivated
247c: da,05               jle   2483             if ((uns) R8a < 0)  {             # jump if end (no next entry)
247e: c7,8b,c5,02,88      stb   R88,[R8a+2c5]    [R8a+HSOQ] = R88; } }             # entry is valid so update link?

### populate entry - 2284 offset and new 24 bit activation time

2483: 49,84,22,92,88      sb3w  R88,R92,2284     R88 = TPtr - HSOTable;            # convert to Table offset
2488: c7,7f,c6,02,88      stb   R88,[R7e+2c6]    [Rtab+SvStack] = R88;             # save *ROM* OFFSET in this 2C5 Table entry [1]
248d: c3,7f,c7,02,80      stw   R80,[R7e+2c7]    [Rtab+2c7] = HSO_time;            # save TimeLo16
2492: c7,7f,c9,02,82      stb   R82,[R7e+2c9]    [Rtab+2c9] = HSO_timeH;           # save TimeHi8
2497: af,92,02,88         ldzbw R88,[R92+2]      R88 = (uns)[TPtr+2];              # load offset (2C5) to list head (?) from 2284 Table pointer
249b: 57,89,c5,02,00,8a   ad3b  R8a,R0,[R88+2c5] R8a = [R88+HSOQ];                 # R8A is link from R88 entry
24a1: 20,0a               sjmp  24ad             goto 24ad;                        # insert into list by activation time

#### insert entry in 2C5 list by activation time
24a3: 55,05,8a,88         ad3b  R88,R8a,5        R88 = R8a + 5;                    # flip to other 'side' of entry ?
24a7: 57,8b,ca,02,00,8a   ad3b  R8a,R0,[R8a+2ca] R8a = [R8a+2ca];                  # traverse link + 5
24ad: d2,12               jgt   24c1             if (R8a <= 0)  {                  # jmp if valid 'link' to next entry - if N==0 && Z==0 then jmp to next entry

### end of list - insert at end of list

24af: c7,7f,ca,02,8a      stb   R8a,[R7e+2ca]    [Rtab+2ca] = R8a;                 # save in other 'side' link?
24b4: c7,89,c5,02,7e      stb   R7e,[R88+2c5]    [R88+HSOQ] = Rtab;
24b9: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;                     # convert 2C5 offset to address
24bd: c6,7e,88            stb   R88,[R7e]        [Rtab] = R88;
24c0: f0                  ret                    return; }

24c1: 9b,8b,c6,02,00      cmpb  R0,[R8a+2c6]                                       # (ROM offset? )offset 1 (0 value means time/entry not valid/active? )
24c6: df,db               je    24a3             if (0 = [R8a+SvStack]) goto 24a3; # jmp if offset link = 0

### this is an active entry - compare event times

24c8: 8b,8b,c7,02,80      cmpw  R80,[R8a+2c7]                                      # execute time Lo 16 bits
24cd: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
24d0: bb,8b,c9,02,86      sbbb  R86,[R8a+2c9]    R86 -= [R8a+2c9] - CY;            # execute time Hi 8 bits
24d5: 37,86,cb            jnb   B7,R86,24a3      if (B7_R86 = 0) goto 24a3;        # if new event time is after this entry time then jump

### insert in list before R8A entry

24d8: a0,8a,88            ldw   R88,R8a          R88 = R8a;
24db: af,89,c5,02,8a      ldzbw R8a,[R88+2c5]    R8a = (uns)[R88+HSOQ];
24e0: c7,8b,c5,02,7e      stb   R7e,[R8a+2c5]    [R8a+HSOQ] = Rtab;
24e5: 75,05,7e            ad2b  R7e,5            Rtab += 5;                        # index to flip side of entry
24e8: c7,89,c5,02,7e      stb   R7e,[R88+2c5]    [R88+HSOQ] = Rtab;
24ed: 65,c0,02,7e         ad2w  R7e,2c0          Rtab += Mphtim1H;                 # pointer to base side of entry
24f1: c6,7e,8a            stb   R8a,[R7e]        [Rtab] = R8a;
24f4: c7,7e,05,88         stb   R88,[R7e+5]      [Rtab+5] = R88;
24f8: f0                  ret                    return;

#############################################################
# subroutine called from .
# send command from Tptr+3, then change TPtr to next entry (+8)
# and execute subroutine at [Tptr-2]  ([Tptr+6] from orig locn)
#############################################################


  Do_CmdN:
24f9: 2e,c2               scall 23bd             Send_HSO_Cmd();                   # send HSO command and other stuff
24fb: 3e,4c,2a            jb    B6,R4c,2528      if (Queued = 1) return;
24fe: 65,08,00,92         ad2w  R92,8            TPtr += 8;                        # move to next entry
2502: c9,09,25            push  2509             push(Sub1);                       # push return address
2505: cb,92,fe            push  [R92+fe]         push([TPtr-2]);
2508: f0                  ret                    return;                           # call subroutine from -2 of next entry


  Sub1:
2509: db,25               jc    2530             if ((uns) TPtr >= 0) goto 2530;   # must reschedule the event
250b: 20,00               sjmp  250d             goto Do_CmdP;                     # drop through if reschedule

#############################################################
# subroutine called from .
# send command from Tptr+3,
# IF B7 Cmd SET - change TPtr to prev entry (-8)
# and execute subroutine at [Tptr-14]  ([Tptr+6] from orig locn)
#############################################################

  Do_CmdP:
250d: 2e,ae               scall 23bd             Send_HSO_Cmd();                   # send HSO command and other stuff
250f: 3e,4c,16            jb    B6,R4c,2528      if (Queued = 1) return;
2512: 37,7d,0f            jnb   B7,R7d,2524      if (B7_Cmd = 0) goto 2524;
2515: 69,08,00,92         sb2w  R92,8            TPtr -= 8;                        # R92 pointer to Previous entry
2519: c9,20,25            push  2520             push(Sub2);                       # push return address
251c: cb,92,0e            push  [R92+e]          push([TPtr+e]);                   # get subroutine address from ON entry
251f: f0                  ret                    return;                           # call subroutine


  Sub2:
2520: db,0e               jc    2530             if ((uns) TPtr >= 0) goto 2530;   # must reschedule event
2522: 27,d5               sjmp  24f9             goto Do_CmdN;                     # go to ON event execution
2524: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;                     # processed ?
2528: f0                  ret                    return;



2529: c9,30,25,cb,92,04,f0 ??                                                      # ? Never gets to here ?

2530: 2f,2b               scall 245d             Sched_HSO();                      # schedule a routine for execution in 2284/2C5 Table
2532: f0                  ret                    return;

###########################################################
# Read HSI data
# The opening arithmetic converts the 16 bit IO TIMER (o/flow every 0.157 secs)into 24 bit value
# (with overflow every 40.2 secs). 
# R7a,b,c is the EVENT time for the HSI Interrupt
# HSI data is then processed and reqd handlers called
###########################################################


  Read_hsi:
2533: 34,d8,01            jnb   B4,Rd8,2537      if (Sto_pending = 1)  {
2536: f0                  ret                    return; }

2537: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # time diff
253b: 64,84,8c            ad2w  R8c,R84          Reftime += R84;                   # add diff (24 bits)
253e: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;
2541: b0,8e,7c            ldb   R7c,R8e          Event_timeH = ReftimeH;           # set event time Hi
2544: 48,0e,8c,84         sb3w  R84,R8c,Re       R84 = Reftime - HSI_Time;         # time diff since event (Lo)
2548: 65,02,00,84         ad2w  R84,2            R84 += 2;                         # add propogation delay ?
254c: 48,84,8c,7a         sb3w  R7a,R8c,R84      Event_time = Reftime - R84;       # corrected event time
2550: b8,00,7c            sbbb  R7c,R0           Event_timeH -= CY;                # (24 bit)
2553: b0,0d,83            ldb   R83,Rd           HSI_State = HSI_Data;             # read HSI data
2556: b0,90,87            ldb   R87,R90          New_irqs = Last_HSI;              # current state
2559: 94,83,87            xorb  R87,R83          New_irqs ^= HSI_State;            # get changed bits
255c: 70,0c,87            an2b  R87,Rc           New_irqs &= HSI_Mask;             # mask for valid inputs
255f: b0,83,90            ldb   R90,R83          Last_HSI = HSI_State;             # New state
2562: 11,4c               clrb  R4c              Flags_4C = 0;
2564: 98,87,00            cmpb  R0,R87           
2567: df,4a               je    25b3             if (0 != New_irqs)  {
2569: 37,87,03            jnb   B7,R87,256f      if (Idm_irq = 1)  {
256c: ef,16,5f            call  8485             Idm_inth(); }                     # handle Ign Diag Mon
256f: 36,87,03            jnb   B6,R87,2575      if (Mph_irq = 1)  {
2572: ef,a0,04            call  2a15             Vss_inth(); }                     # handle VSS counts
2575: 35,87,03            jnb   B5,R87,257b      if (Cid_irq = 1)  {
2578: ef,53,04            call  29ce             Cid_inth(); }                     # handle CID
257b: 32,87,03            jnb   B2,R87,2581      if (Bap_irq = 1)  {
257e: ef,0f,10            call  3590             Bap_inth(); }                     # handle BP/MAP
2581: 31,87,03            jnb   B1,R87,2587      if (Knk_irq = 1)  {
2584: ef,08,47            call  6c8f             Knk_inth(); }                     # handle KNK
2587: 30,87,03            jnb   B0,R87,258d      if (Pip_irq = 1)  {
258a: ef,3d,02            call  27ca             Pip_inth(); }                     # handle PIP
258d: 98,00,87            cmpb  R87,R0           
2590: df,21               je    25b3             if (New_irqs != 0)  {             # any more events ?
2592: b1,87,0c            ldb   Rc,87            HSI_Mask = 87;
2595: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]      
2599: d7,03               jne   259e             if (0 = Kihp)  {                  # knock sensor fitted ?
259b: b1,85,0c            ldb   Rc,85            HSI_Mask = 85; }                  # No, mask int
259e: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
25a2: df,03               je    25a7             if (0 != Hpcid)  {                # CID sensor fitted ?
25a4: 91,20,0c            orb   Rc,20            HSI_Mask |= 20; }                 # Yes, allow int
25a7: 9b,f2,47,00         cmpb  R0,[Rf2+47]                                        # VSS sensor fitted ?
25ab: df,03               je    25b0             if (0 != Vstype)  {
25ad: 91,40,0c            orb   Rc,40            HSI_Mask |= 40; }                 # Yes, allow int
25b0: 91,01,4e            orb   R4e,1            Hsi_error = 1; } }                # flag extra events
25b3: 32,0a,02            jnb   B2,Ra,25b8       if (HSI_Ready = 0) return;
25b6: 27,7b               sjmp  2533             goto Read_hsi;                    # loop back until HSI stack empty
25b8: f0                  ret                    return;

#############################################################
# High Speed Output Port Output Interrupt Routine
# Software interrupt every 1 msec
# Input : R91 is flags?
# Slice ptr is changed every 614uS? (0.6 mS) and is 0-8 (3b4-3bb)
# This base s/w clock int is used to drive a large Table of s/w routines
# This may be only for creating PWM output signals ?
##############################################################


  I_HSO_1:
25b9: f2                  pushp                  push(PSW);
25ba: 38,d8,08            jb    B0,Rd8,25c5      if (Sto_holdoff = 0)  {
25bd: 45,a1,01,06,0e      ad3w  Re,R6,1a1        HSO_Time = IO_Timer + 1a1;        # = 1msec at 15Mhz
25c2: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a; }                   # int enabled, level low, channel 10
25c5: c3,74,06,06         stw   R6,[R74+6]       Last_HSO = IO_Timer;              # save current IO time
25c9: c3,74,48,10         stw   R10,[R74+48]     SvStack = STACK;                  # save stack pointer
25cd: ad,72,10            ldzbw R10,72           STACK = (uns)72;                  # temp stack
25d0: ac,91,50            ldzbw R50,R91          R50 = (uns)Slice_ptr;
25d3: 51,07,8d,91         an3b  R91,R8d,7        Slice_ptr = R8d & 7;              # HSI time/256 & 7 ?

### loop around entries 0-7
25d7: 98,50,91            cmpb  R91,R50          
25da: df,15               je    25f1             if (Slice_ptr != R50)  {          # New time slice ?
25dc: 7b,51,b4,03,cf      sb2b  Rcf,[R50+3b4]    HQcnt -= [R50+Slice_0];
25e1: db,02               jc    25e5             if (HQcnt > 0)  {
25e3: 11,cf               clrb  Rcf              HQcnt = 0; }
25e5: c7,51,b4,03,00      stb   R0,[R50+3b4]     [R50+Slice_0] = 0;                # clear table entry
25ea: 17,50               incb  R50              R50++;
25ec: 71,07,50            an2b  R50,7            R50 &= 7;                         # cheap reset for loop 0-7
25ef: 27,e6               sjmp  25d7             goto 25d7; }                      # loop back, next slice
25f1: e7,ed,0d            jump  33e1             goto HSO_continued;

 ##### Code segment 33e1 to 358d executed here and returns #####
 
25f4: 91,01,47            orb   R47,1            B0_Flags_47 = 1;                  # BIDI O/P line 0 to ON
25f7: a0,46,50            ldw   R50,R46          R50 = IO_Port_State;              # R50 = (new ?) LSO and BIDI OP values
25fa: 85,00,00,50         xrw   R50,0            R50 ^= 0;
25fe: b0,50,02            ldb   R2,R50           LSO_Port = R50;
2601: b0,51,03            ldb   R3,R51           LIO_Port = R51;                   # write OUTPUTS
2604: 18,02,51            shrb  R51,2            R51 /= 4;                         # drop bottom 3 BIDI O/Ps - why ?
2607: c7,01,2f,09,51      stb   R51,[R0+92f]     [92f] = R51;                      # Odd address ? save bits for ?

#### traverse the 2C5 queue, execute subroutine for each entry whose time is up
#### does not remove or add any queue entries
260c: 01,94               clrw  R94              R94 = 0;
260e: 01,96               clrw  R96              R96 = 0;
2610: b1,80,4c            ldb   R4c,80           Flags_4C = 80;
2613: 57,95,c5,02,00,7e   ad3b  R7e,R0,[R94+2c5] Rtab = [R94+HSOQ];
# Init to top of loop
2619: d7,02               jne   261d             if (Rtab != 0) goto 261d;
261b: 20,84               sjmp  26a1             goto 26a1;                        # exit when 2C5[R94] == 0
261d: 11,7f               clrb  R7f              R7f = 0;
261f: 57,7f,c6,02,00,92   ad3b  R92,R0,[R7e+2c6] TPtr = [Rtab+SvStack];            # map to 2284 Table entry
2625: d7,1c               jne   2643             if (TPtr != 0) goto 2643;         # valid entry
2627: b1,ff,50            ldb   R50,ff           R50 = ff;
262a: c7,7f,c5,02,50      stb   R50,[R7e+2c5]    [Rtab+HSOQ] = R50;
262f: 57,7f,ca,02,00,96   ad3b  R96,R0,[R7e+2ca] R96 = [Rtab+2ca];                 # calc next entry
2635: c7,95,c5,02,96      stb   R96,[R94+2c5]    [R94+HSOQ] = R96;
263a: df,65               je    26a1             if (R96 = 0) goto 26a1;           # loop exit when R96 == 0
263c: c7,97,c5,02,94      stb   R94,[R96+2c5]    [R96+HSOQ] = R94;
2641: 27,d0               sjmp  2613             goto 2613;                        # loop back for next time slice
2643: 11,93               clrb  R93              R93 = 0;                          # process valid entry
2645: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;
2649: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
264c: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                   # update master ref time
264f: a3,7f,c7,02,80      ldw   R80,[R7e+2c7]    HSO_time = [Rtab+2c7];            # event time for this entry
2654: b3,7f,c9,02,82      ldb   R82,[R7e+2c9]    HSO_timeH = [Rtab+2c9];
2659: 48,8c,80,84         sb3w  R84,R80,R8c      R84 = HSO_time - Reftime;         # time left to event
265d: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
2660: b8,8e,86            sbbb  R86,R8e          R86 -= ReftimeH - CY;
2663: 3f,86,0a            jb    B7,R86,2670      if (B7_R86 = 1) goto 2670;        # -ve, time passed, do immediately
2666: d7,39               jne   26a1             if (R86 = 0)  {                   # still time left 
2668: 89,46,04,84         cmpw  R84,446          
266c: d1,05               jleu  2673             if ((uns) R84 <= 446) goto 2673;  # < 2mS to go, process it ?
266e: 20,31               sjmp  26a1             goto 26a1;                        # skip until later ?
2670: 91,08,4c            orb   R4c,8            Immediate = 1;                    # late event, flag immediate
2673: 89,42,00,84         cmpw  R84,42           
2677: d1,03               jleu  267c             if ((uns) R84 > 42 )  {
2679: 91,02,4c            orb   R4c,2            Bypass_time = 1; }                # event time > 158 uS
267c: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;                     # map to 2C5 Table pointer
2680: 65,84,22,92         ad2w  R92,2284         TPtr += HSOTable;                 # map to 2284 Table entry
2684: c9,8a,26            push  268a             push(Sub3);                       # return address for call
2687: ca,92               push  [R92]            push([TPtr]);
2689: f0                  ret                    return;                           # call subroutine from 2284 Table


  Sub3:
268a: 34,4c,0c            jnb   B4,R4c,2699      if (No_service = 0) goto 2699;
268d: 57,95,c5,02,00,94   ad3b  R94,R0,[R94+2c5] R94 = [R94+HSOQ];
2693: df,0c               je    26a1             if (R94 != 0)  {
2695: 65,05,00,94         ad2w  R94,5            R94 += 5;                         # next 2C5 Table entry
2699: 32,0a,03            jnb   B2,Ra,269f       if (HSI_Ready = 1)  {
269c: ef,94,fe            call  2533             Read_hsi(); }
269f: 27,6f               sjmp  2610             goto 2610; } }                    # back for next entry
26a1: 32,0a,02            jnb   B2,Ra,26a6       if (HSI_Ready = 1)  {
26a4: 2e,8d               scall 2533             Read_hsi(); }
26a6: 11,4c               clrb  R4c              Flags_4C = 0;
26a8: 88,48,00            cmpw  R0,R48           
26ab: df,10               je    26bd             if (0 != R48)  {
26ad: 37,48,03            jnb   B7,R48,26b3      if (Change_fuelpw = 1)  {
26b0: ef,8b,0c            call  333e             Sub9(); }
26b3: 35,48,02            jnb   B5,R48,26b8      if (B5_R48 = 1)  {
26b6: 28,ee               scall 27a6             Set_SW_intp(); }
26b8: 32,0a,02            jnb   B2,Ra,26bd       if (HSI_Ready = 1)  {
26bb: 2e,76               scall 2533             Read_hsi(); } }
26bd: b3,01,30,09,51      ldb   R51,[R0+930]     R51 = [930];                      # Prev Low Speed digital inputs?
26c2: 19,02,51            shlb  R51,2            R51 *= 4;
26c5: b0,03,52            ldb   R52,R3           R52 = LIO_Port;                   # read bidirectional port
26c8: 71,03,52            an2b  R52,3            R52 &= 3;                         # keep bits 0 and 1
26cb: 90,52,51            orb   R51,R52          R51 |= R52;
26ce: b0,0b,50            ldb   R50,Rb           R50 = HSI_Sample;                 # HSI sample
26d1: 85,00,00,50         xrw   R50,0            R50 ^= 0;                         # Redundant ?
26d5: c8,50               push  R50              push(R50);                        # save HSI AND Low speed sample
26d7: a3,74,c4,94         ldw   R94,[R74+c4]     R94 = Post_image;                 # last time HSI+ LS Sample
26db: 84,94,50            xrw   R50,R94          R50 ^= R94;                       # bits changed since last read
26de: 02,50               cplw  R50              R50 = ~R50;                       # swop bits back ?
26e0: a0,de,96            ldw   R96,Rde          R96 = Input_image;                # Last sample
26e3: 84,94,96            xrw   R96,R94          R96 ^= R94;                       # compare for changes
26e6: 60,96,50            an2w  R50,R96          R50 &= R96;
26e9: 84,50,de            xrw   Rde,R50          Input_image ^= R50;               # HSI and LS changes
26ec: cf,74,c4            pop   [R74+c4]         Post_image = pop();               # save this sample for next time
26ef: a0,06,58            ldw   R58,R6           R58 = IO_Timer;
26f2: 58,8f,59,50         sb3b  R50,R59,R8f      R50 = R59 - Wd_time;              # IO time difference for Watchdog
26f6: 99,02,50            cmpb  R50,2            
26f9: d3,1f               jnc   271a             if ((uns) R50 >= 2)  {
26fb: 95,40,02            xorb  R2,40            CPU_OK ^= 1;                      # keep alive
26fe: b0,59,8f            ldb   R8f,R59          Wd_time = R59;                    # update wdog time
2701: 17,05               incb  R5               WDG_Timer++;                      # keep the watchdog at bay
2703: 95,40,02            xorb  R2,40            CPU_OK ^= 1;                      # toggle line 6 (LOS)
2706: ad,09,50            ldzbw R50,9            R50 = (uns)9;                     # no of byte locations to add up
2709: 01,54               clrw  R54              R54 = 0;                          # init sum
270b: e0,50,05            djnz  R50,2713         R50--;
                                                 if (R50 != 0) goto 2713;          # test for done adding
270e: b0,54,cf            ldb   Rcf,R54          HQcnt = R54;                      # move sum to RCF
2711: 20,07               sjmp  271a             goto 271a; }                      # exit loop
2713: 77,51,b3,03,54      ad2b  R54,[R50+3b3]    R54 += [R50+Archcor];             # add 9 bytes of ? save to ?
2718: 27,f1               sjmp  270b             goto 270b; }
271a: 31,09,03            jnb   B1,R9,2720       if (B1_INT_Pend = 1)  {           # IO timer overflow pending?
271d: b1,02,08            ldb   R8,2             INT_Mask = 2; }                   # allow only IO timer OVF interrupts
2720: a3,74,48,10         ldw   R10,[R74+48]     STACK = SvStack;                  # restore saved stack pointer
2724: ff                  nop                    
2725: ff                  nop                    
2726: ff                  nop                    
2727: ff                  nop                                                      # safety delay ?
2728: fa                  di                     disable ints;
2729: f3                  popp                   PSW = pop();
272a: f1                  reti                   return;

#############################################################
## High Speed Input # 0 Interrupt Routine (read HSI data)
#############################################################


  I_HSI_0:
272b: f2                  pushp                  push(PSW);
272c: 91,00,02            orb   R2,0             LSO_Port |= 0;
272f: c3,74,48,10         stw   R10,[R74+48]     SvStack = STACK;                  # save stack pointer
2733: ad,72,10            ldzbw R10,72           STACK = (uns)72;                  # temp stack pointer
2736: 32,0a,02            jnb   B2,Ra,273b       if (HSI_Ready = 1)  {
2739: 2d,f8               scall 2533             Read_hsi(); }                     # read HSI data if avail
273b: 27,e3               sjmp  2720             goto 2720;                        # restore old stack ptr and return

#############################################################
# Master I/O Timer Overflow Interrupt Routine
# neatly uses overflow to increment 32 bit counter.
#############################################################

  I_Timer_OVF:
273d: f2                  pushp                  push(PSW);
273e: 07,12               incw  R12              Tmr_OVF_cnt++;                    # increment I/O Timer overflow
2740: d7,03               jne   2745             if (Tmr_OVF_cnt = 0)  {
2742: 91,04,4f            orb   R4f,4            Clkext_ovr = 1; }                 # flag Tmr overflow
2745: b0,12,8e            ldb   R8e,R12          ReftimeH = Tmr_OVF_cnt;
2748: a0,06,8c            ldw   R8c,R6           Reftime = IO_Timer;               # save 32 bit time
274b: fa                  di                     disable ints;
274c: b1,a1,08            ldb   R8,a1            INT_Mask = a1;                    # reset int mask
274f: f3                  popp                   PSW = pop();

  I_Ignore:
2750: f1                  reti                   return;

#############################################################
# Software Interrupt Handler ?
# Reset S/W interrupt every 5 ms, (2083 IOTimer ticks = 5 mS)
# and check Cal Console status and enter [console] routine if required
# effectively gives console a timeslice every 5mS
#############################################################


  I_HSO_2:
2751: f2                  pushp                  push(PSW);
2752: fa                  di                     disable ints;
2753: ff                  nop                    
2754: 47,74,1a,00,50      ad3w  R50,R0,[R74+1a]  R50 = LastSWtime;                 # THIS interrupt time
2759: df,21               je    277c             if (R50 != 0)  {                  # zero means set no more SW ints
275b: 48,06,50,52         sb3w  R52,R50,R6       R52 = R50 - IO_Timer;
275f: 37,53,1a            jnb   B7,R53,277c      if (B7_R53 = 1)  {                # interrupt earlier than time requested
2762: 30,0a,05            jnb   B0,Ra,276a       if (HSO_OVF = 1)  {
2765: 91,20,48            orb   R48,20           B5_R48 = 1;                       # remember int overflow ? 
2768: 20,12               sjmp  277c             goto 277c; }                      # skip creating new int
276a: 65,23,08,50         ad2w  R50,823          R50 += 823;                       # Next s/w interrupt in 5 Ms
276e: d7,02               jne   2772             if (R50 = 0)  {
2770: 07,50               incw  R50              R50++; }                          # avoid zero which means s/w ints are off
2772: c3,74,1a,50         stw   R50,[R74+1a]     LastSWtime = R50;                 # save NEXT s/w int time
2776: a0,50,0e            ldw   Re,R50           HSO_Time = R50;
2779: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f; } }                  # set new software interrupt
277c: a3,01,00,0d,50      ldw   R50,[R0+d00]     R50 = [d00];                      # CONSOLE STATUS check
2781: 47,01,1a,c1,00,52   ad3w  R52,R0,[R0+c11a] R52 = R52+c11a;                   # Console address ? IO time for next console call
2787: df,19               je    27a2             if (R52 != 0)  {
2789: 99,2a,51            cmpb  R51,2a           
278c: d7,14               jne   27a2             if (R51 = 2a)  {                  # exit if no console
278e: 8b,01,1a,c1,00      cmpw  R0,[R0+c11a]     
2793: df,0d               je    27a2             if (0 != [c11a])  {
2795: 68,06,52            sb2w  R52,R6           R52 -= IO_Timer;
2798: 37,53,07            jnb   B7,R53,27a2      if (B7_R53 = 1)  {                # if time has passed ?
279b: fa                  di                     disable ints;
279c: ff                  nop                    
279d: f3                  popp                   PSW = pop();
279e: c9,09,d0            push  d009             push(d009);                       # console entry ?
27a1: f1                  reti                   return; } } } }

27a2: fa                  di                     disable ints;
27a3: ff                  nop                    
27a4: f3                  popp                   PSW = pop();
27a5: f1                  reti                   return;

##############################################################
# Reschedule (or start) software interrupt
# sets next software interrupt 5 millisecs after time in LastSWtime
# Ignores if HSO overflow
############################################################### 



  Set_SW_intp:
27a6: 38,0a,19            jb    B0,Ra,27c2       if (HSO_OVF = 0)  {
27a9: a3,74,1a,50         ldw   R50,[R74+1a]     R50 = LastSWtime;                 # time of last s/w int
27ad: 65,23,08,50         ad2w  R50,823          R50 += 823;                       # last int + 5msec
27b1: d7,02               jne   27b5             if (R50 = 0)  {
27b3: 07,50               incw  R50              R50++; }                          # avoid zero
27b5: c3,74,1a,50         stw   R50,[R74+1a]     LastSWtime = R50;                 # save NEXT time
27b9: a0,50,0e            ldw   Re,R50           HSO_Time = R50;
27bc: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f;                      # set interrupt
27bf: 71,df,48            an2b  R48,df           B5_R48 = 0; }                     # clear ints overflowed flag ?
27c2: f0                  ret                    return;

###############################################################
# Table 4,6,8 cyls - used at 3E5D lookup for Sim_min.  Minimum PIP period for cyl 1 marker ?
###############################################################



27c3: ff                        

27c4: 00,19               word   1900
27c6: ab,10               word   10ab
27c8: 80,0c               word    c80

###############################################################
# handle HSI line 0 data (PIP)
# R7a,b,c = last HSI event time 24 bits
# R50,1,2 = time delta (time since last PIP event)
###############################################################


  Pip_inth:
27ca: b1,06,04            ldb   R4,6             AD_Cmd = 6;                       # read MAF (AD ch 6)
27cd: 71,fe,87            an2b  R87,fe           Pip_irq = 0;                      # clear Pip flag
27d0: a3,76,46,54         ldw   R54,[R76+46]     R54 = Min_pip_dly;                # min PIP time to update RPM ?
27d4: 4b,74,50,7a,50      sb3w  R50,R7a,[R74+50] R50 = Event_time - Prev_PIP_time;
27d9: b0,7c,52            ldb   R52,R7c          R52 = Event_timeH;                # new PIP time in 24 bits
27dc: bb,74,52,52         sbbb  R52,[R74+52]     R52 -= Prev_PIP_timeH - CY;
27e0: 38,90,02            jb    B0,R90,27e5      if (B0_Last_HSI = 1) goto 27e5;
27e3: 21,35               sjmp  291a             goto 291a;

##### PIP High handler (Initialise if First_pip = 1)
##### Initialise the 8 entry RAM table (2c5) from InjTab table (22a6) 
27e5: 3c,2d,23            jb    B4,R2d,280b      if (First_pip = 0)  {
27e8: 91,10,2d            orb   R2d,10           First_pip = 1;
27eb: a1,a6,22,56         ldw   R56,22a6         R56 = InjTTab;                    # Base of Table
27ef: 89,56,23,56         cmpw  R56,2356         
27f3: db,14               jc    2809             if (R56 > 2356)  {                # done - exit loop
27f5: af,56,05,58         ldzbw R58,[R56+5]      R58 = (uns)[R56+5];               # index into 2C5 Table (-3 ?)
27f9: c7,59,c2,02,7c      stb   R7c,[R58+2c2]    [R58+Mphtim2H] = Event_timeH;     # 24 bit PIP event time
27fe: c3,59,c3,02,7a      stw   R7a,[R58+2c3]    [R58+Mphtim2] = Event_time;
2803: 65,16,00,56         ad2w  R56,16           R56 += 16;                        # next InjTab entry (22 bytes)
2807: 27,e6               sjmp  27ef             goto 27ef; }                      # end of init loop
2809: 20,2c               sjmp  2837             goto 2837; }

##### PIP High handler (Run)
280b: 98,52,00            cmpb  R0,R52           
280e: d7,09               jne   2819             if (0 = R52)  {
2810: 88,50,54            cmpw  R54,R50          
2813: d1,04               jleu  2819             if ((uns) R54 > R50 )  {
2815: 71,fe,90            an2b  R90,fe           Last_HSI &= fe;                   # time too small - ignore it
2818: f0                  ret                    return; } }

2819: 91,0c,4e            orb   R4e,c            New_Bpv = 1;
                                                 New_rpm = 1;
281c: 91,02,28            orb   R28,2            Ptpflg = 1;
281f: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
2823: d7,09               jne   282e             if (0 = Hpcid)  {                 # CID sensor present ?
2825: 3e,2e,06            jb    B6,R2e,282e      if (Synflg = 0)  {                # AE fuel - sync = 1, async = 0. Init to 0
2828: 3a,25,03            jb    B2,R25,282e      if (Mhpfd_neg = 0)  {
282b: 71,fb,2d            an2b  R2d,fb           Double_edge = 0; } } }
282e: 71,fe,4f            an2b  R4f,fe           Pip_double = 0;
2831: 32,2d,03            jnb   B2,R2d,2837      if (Double_edge = 1)  {
2834: 91,01,4f            orb   R4f,1            Pip_double = 1; }
2837: 91,80,4e            orb   R4e,80           New_pip = 1;
283a: c3,76,ba,ba         stw   Rba,[R76+ba]     Prev_PIP_ETime = PIPHi_ETime;     # Previous PIP period
283e: a0,50,ba            ldw   Rba,R50          PIPHi_ETime = R50;                # new PIP period 24 bits
2841: b0,52,bc            ldb   Rbc,R52          PIPHi_ETimeH = R52;               # period = time since last PIP Hi
2844: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2848: d7,03               jne   284d             if (0 = Hphidres)  {              # High Data Rate Electronic Spark Present ?
284a: ef,44,04            call  2c91             Calc_dwell(); }
284d: 98,00,bc            cmpb  Rbc,R0                                             # PIP time hi 8 bits
2850: d7,10               jne   2862             if (PIPHi_ETimeH = 0)  {
2852: 8b,76,48,ba         cmpw  Rba,[R76+48]                                       # PIP time lo 16 bits
2856: d9,0a               jgtu  2862             if ((uns) PIPHi_ETime <= Sim_min)  {
2858: b3,fc,33,50         ldb   R50,[Rfc+33]     R50 = Outinj;                     # Sequential (1) or simultaneous (2) inject
285c: 39,50,03            jb    B1,R50,2862      if (B1_R50 = 0)  {
285f: 71,f7,2e            an2b  R2e,f7           Simultaneous = 0; } } }
2862: c3,74,50,7a         stw   R7a,[R74+50]     Prev_PIP_time = Event_time;       # PIP HSI event time lo 16 bits
2866: c7,74,52,7c         stb   R7c,[R74+52]     Prev_PIP_timeH = Event_timeH;     # PIP HSI event time hi 8 bits
286a: 39,ca,0c            jb    B1,Rca,2879      if (Declflg = 0)  {
286d: 17,b3               incb  Rb3              Ppctr++;
286f: 9b,fc,53,b3         cmpb  Rb3,[Rfc+53]                                       # No of steps to Ramp Fuel, unitless
2873: d1,04               jleu  2879             if ((uns) Ppctr > Pipnum )  {
2875: b3,fc,53,b3         ldb   Rb3,[Rfc+53]     Ppctr = Pipnum; } }               # No of steps to Ramp Fuel, unitless
2879: 17,b4               incb  Rb4              Pipcnt++;
287b: d7,02               jne   287f             if (Pipcnt = 0)  {
287d: 15,b4               decb  Rb4              Pipcnt--; }                       # No of PIPs which have occurred
287f: 17,9c               incb  R9c              Anpip1++;
2881: d7,02               jne   2885             if (Anpip1 = 0)  {
2883: 15,9c               decb  R9c              Anpip1--; }
2885: 17,9d               incb  R9d              Anpip2++;
2887: d7,02               jne   288b             if (Anpip2 = 0)  {
2889: 15,9d               decb  R9d              Anpip2--; }
288b: 35,2a,0a            jnb   B5,R2a,2898      if (Self_test = 1)  {
288e: a3,72,76,50         ldw   R50,[R72+76]     R50 = Vcb_pip_cnt;
2892: 07,50               incw  R50              R50++;
2894: c3,72,76,50         stw   R50,[R72+76]     Vcb_pip_cnt = R50; }
2898: 75,20,d1            ad2b  Rd1,20           Synctr += 20;
289b: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
289f: d7,03               jne   28a4             if (0 = Hphidres)  {
28a1: ef,65,42            call  6b09             Sub36(); }                        # High Data Rate Electronic Spark present ?
28a4: 33,0a,fd            jnb   B3,Ra,28a4       if (AD_Ready = 0) goto 28a4;      # wait for A -D complete
28a7: 51,f0,04,50         an3b  R50,R4,f0        R50 = AD_Low & f0;                # mask out channel no
28ab: b0,05,51            ldb   R51,R5           R51 = AD_High;
28ae: c3,72,a4,50         stw   R50,[R72+a4]     MAF_Raw = R50;                    # save (raw MAF counts ?) 124
28b2: 30,4f,03            jnb   B0,R4f,28b8      if (Pip_double = 1)  {
28b5: ef,5c,43            call  6c14             Sub37(); }
28b8: 71,7f,4f            an2b  R4f,7f           Knock_occurred = 0;
28bb: 33,4f,09            jnb   B3,R4f,28c7      if (Knock_detected = 1)  {
28be: 91,80,4f            orb   R4f,80           Knock_occurred = 1;
28c1: 39,90,03            jb    B1,R90,28c7      if (B1_Last_HSI = 0)  {
28c4: 71,f7,4f            an2b  R4f,f7           Knock_detected = 0; } }
28c7: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # routine in 2284 Table
28cb: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
28cf: df,07               je    28d8             if (0 = Hphidres) goto 28d8;
28d1: 3a,a1,2e            jb    B2,Ra1,2902      if (Undsp = 0)  {                 # Underspeed Flag
28d4: 29,76               scall 2a4c             Knock_chk();
28d6: 20,2a               sjmp  2902             goto 2902;
28d8: 32,a1,16            jnb   B2,Ra1,28f1      if (Undsp = 1)  {
28db: 39,2d,06            jb    B1,R2d,28e4      if (Undsp_trans = 0)  {
28de: 91,08,4c            orb   R4c,8            Immediate = 1;
28e1: ef,d9,fa            call  23bd             Send_HSO_Cmd(); }                 # send HSO command and other stuff R92=2296
28e4: 71,fb,2d            an2b  R2d,fb           Double_edge = 0;
28e7: a1,00,80,50         ldw   R50,8000         R50 = 8000;
28eb: c3,74,04,50         stw   R50,[R74+4]      Old_beta = R50;
28ef: 20,11               sjmp  2902             goto 2902; }
28f1: 38,4f,0e            jb    B0,R4f,2902      if (Pip_double = 0)  {
28f4: 31,2d,09            jnb   B1,R2d,2900      if (Undsp_trans = 1)  {
28f7: 91,08,4c            orb   R4c,8            Immediate = 1;
28fa: ef,fc,fb            call  24f9             Do_CmdN();
28fd: 71,fd,2d            an2b  R2d,fd           Undsp_trans = 0; }
2900: 29,4a               scall 2a4c             Knock_chk(); } }
2902: b1,ff,50            ldb   R50,ff           R50 = ff;
2905: c7,72,11,50         stb   R50,[R72+11]     Inj_pip = R50;
2909: 91,20,2f            orb   R2f,20           Maf_pip = 1;
290c: a0,7a,52            ldw   R52,R7a          R52 = Event_time;
290f: ef,25,04            call  2d37             MAF_calc();
2912: ef,46,05            call  2e5b             Sub4();
2915: ef,b0,06            call  2fc8             Sub5();
2918: 20,b3               sjmp  29cd             return;

######## PIP Low handler ####### 
291a: 34,2d,0c            jnb   B4,R2d,2929      if (First_pip = 1)  {
291d: 08,02,54            shrw  R54,2            R54 /= 4;
2920: 88,50,54            cmpw  R54,R50          
2923: d1,04               jleu  2929             if ((uns) R54 > R50 )  {
2925: 91,01,90            orb   R90,1            Last_HSI |= 1;
2928: f0                  ret                    return; } }

2929: a0,ba,58            ldw   R58,Rba          R58 = PIPHi_ETime;                # PIP Elapsed time
292c: 08,01,58            shrw  R58,1            R58 /= 2;                         # half (for equal Hi/Lo)
292f: c3,76,bc,be         stw   Rbe,[R76+bc]     Prev_PIPH_PW = PIPH_PW;
2933: a0,50,be            ldw   Rbe,R50          PIPH_PW = R50;                    # PIP hi-lo time delta (Pulsewidth)
2936: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       

###### skip this section for narrow blade (cyl 1) if CID fitted,
####### because then don't need to do all this work...

293a: d7,62               jne   299e             if (0 = Hpcid)  {                 # No Cyl ID sensor 
293c: 71,fd,eb            an2b  Reb,fd           Sigpip = 0;
293f: 3a,a1,57            jb    B2,Ra1,2999      if (Undsp = 1) goto 2999;
2942: 48,be,58,52         sb3w  R52,R58,Rbe      R52 = R58 - PIPH_PW;              # = PIP Hi-Hi time/2 - Pip Hi-lo time
2946: da,48               jle   2990             if (R52 <= 0) goto 2990;          # should be zero at steady state
2948: 01,50               clrw  R50              R50 = 0;
294a: 8c,58,50            divw  R50,R58          R50 /= R58;                       # top byte PIPHi-Hi/Pip Hi-Lo
294d: 8b,fe,0e,50         cmpw  R50,[Rfe+e]      
2951: d1,3d               jleu  2990             if ((uns) R50 <= MHPFD) goto 2990; # 9e68 is 20% of 65536
2953: 91,02,eb            orb   Reb,2            Sigpip = 1;                       # This is Cyl 1 - narrow blade/slot
2956: 9b,fc,2a,d1         cmpb  Rd1,[Rfc+2a]     
295a: df,02               je    295e             if (Synctr = [9aa8]) goto 295e;
295c: 20,3b               sjmp  2999             goto 2999;
295e: 91,50,2e            orb   R2e,50           Sync_up_fuel = 1;
                                                 Synflg = 1;                       # OK - cyl 1 expected do/keep SYNC 
2961: a3,76,c2,52         ldw   R52,[R76+c2]     R52 = Sigdlt;
2965: c3,76,c4,52         stw   R52,[R76+c4]     Psgdlt = R52;
2969: c3,76,c2,be         stw   Rbe,[R76+c2]     Sigdlt = PIPH_PW;
296d: a3,76,c0,50         ldw   R50,[R76+c0]     R50 = Sigkal;
2971: 6c,be,50            ml2w  R50,Rbe          R50 *= PIPH_PW;
2974: 8c,c0,50            divw  R50,Rc0          R50 /= Mkay;
2977: dd,05               jv    297e             if (OVF = 0)  {
2979: c0,be,50            stw   R50,Rbe          PIPH_PW = R50;
297c: 20,03               sjmp  2981             goto 2981; }
297e: a0,58,be            ldw   Rbe,R58          PIPH_PW = R58;
2981: a3,fc,2e,50         ldw   R50,[Rfc+2e]     R50 = [9aac];                     # 9aac = 256
2985: 8b,fc,2a,50         cmpw  R50,[Rfc+2a]     
2989: df,03               je    298e             if (R50 != [9aa8])  {             # 9aa8 = 256
298b: 71,ef,2e            an2b  R2e,ef           Sync_up_fuel = 0; }
298e: 11,d1               clrb  Rd1              Synctr = 0;
2990: ac,d1,58            ldzbw R58,Rd1          R58 = (uns)Synctr;
2993: 8b,fc,2a,58         cmpw  R58,[Rfc+2a]     
2997: d3,05               jnc   299e             if ((uns) R58 >= [9aa8])  {
2999: 11,d1               clrb  Rd1              Synctr = 0;
299b: 71,2f,2e            an2b  R2e,2f           Sync_up_fuel = 0;
                                                 Synflg = 0;
                                                 Fuel_in_sync = 0; } }             # UNSYNC  
#### end of narrow blade processing

299e: c9,9f,6c            push  6c9f             push(Sub38);
29a1: c9,c8,2f            push  2fc8             push(Sub5);
29a4: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
29a8: df,01               je    29ab             if (0 != Hphidres)  {
29aa: f0                  ret                    return; }

29ab: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # Spout Off command ?
29af: 32,a1,0d            jnb   B2,Ra1,29bf      if (Undsp = 1)  {
29b2: 31,2d,04            jnb   B1,R2d,29b9      if (Undsp_trans = 1)  {
29b5: 71,fd,2d            an2b  R2d,fd           Undsp_trans = 0;
29b8: f0                  ret                    return; }

29b9: 91,08,4c            orb   R4c,8            Immediate = 1;
29bc: e7,fe,f9            jump  23bd             goto Send_HSO_Cmd; }              # send HSO command and other stuff
29bf: 30,4f,08            jnb   B0,R4f,29ca      if (Pip_double = 1)  {
29c2: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # Spout On command ?
29c6: 28,84               scall 2a4c             Knock_chk();
29c8: 27,eb               sjmp  29b5             goto 29b5; }
29ca: 39,2d,ec            jb    B1,R2d,29b9      if (Undsp_trans = 1) goto 29b9;
29cd: f0                  ret                    return;

########################################################
# handle CID (cylinder ident) Interrupt  - sync to cyl no 1
# Synctr (byte) is incremented by 32 (->2898) in PIPHi handler, so wraps 
# each 8 sparks.  Synctr = 0 for cyl 1. Compares with 9aa8
# are done as byte AND word, so the 256 word value is probably a flag marker
# for newly synched ?  The 128 use may show that CID changes state at cyl 4,
# which would be a state switch for each crank revolution ?
########################################################


  Cid_inth:
29ce: 71,df,87            an2b  R87,df           Cid_irq = 0;
29d1: 9b,fe,0d,00         cmpb  R0,[Rfe+d]       
29d5: d7,16               jne   29ed             if (0 != Hp_cidsel) goto 29ed;
29d7: 3d,90,17            jb    B5,R90,29f1      if (B5_Last_HSI = 0)  {

####### CID High handler #####

29da: b3,fe,07,50         ldb   R50,[Rfe+7]      R50 = PIPsC;
29de: 19,04,50            shlb  R50,4            R50 *= 10;                        # = 128
29e1: 98,50,d1            cmpb  Rd1,R50          
29e4: df,06               je    29ec             if (Synctr != R50)  {             # not = 128
29e6: b0,50,d1            ldb   Rd1,R50          Synctr = R50;                     UNSYNC cyls, set 128 for next rev & return
29e9: 71,2f,2e            an2b  R2e,2f           Sync_up_fuel = 0;
                                                 Synflg = 0;
                                                 Fuel_in_sync = 0; }
29ec: f0                  ret                    return;

29ed: 35,90,01            jnb   B5,R90,29f1      if (B5_Last_HSI = 1)  {
29f0: f0                  ret                    return; } }

####### CID Low handler #####

29f1: b0,d1,50            ldb   R50,Rd1          R50 = Synctr;
29f4: 11,d1               clrb  Rd1              Synctr = 0;
29f6: 3a,a1,06            jb    B2,Ra1,29ff      if (Undsp = 1) goto 29ff;         # UNSYNC if underspeed
29f9: 9b,fc,2a,50         cmpb  R50,[Rfc+2a]     
29fd: df,04               je    2a03             if (R50 != [9aa8])  {
29ff: 71,2f,2e            an2b  R2e,2f           Sync_up_fuel = 0;
                                                 Synflg = 0;
                                                 Fuel_in_sync = 0;                 # not = 0 so UNSYNC cyls & return
2a02: f0                  ret                    return; }

2a03: 91,50,2e            orb   R2e,50           Sync_up_fuel = 1;
                                                 Synflg = 1;                       # OK - SYNC Cyl no 
2a06: a3,fc,2e,50         ldw   R50,[Rfc+2e]     R50 = [9aac];                     # 9aac = 256 
2a0a: 8b,fc,2a,50         cmpw  R50,[Rfc+2a]     
2a0e: d7,01               jne   2a11             if (R50 = [9aa8])  {              # 9aa8 = 256
2a10: f0                  ret                    return; }

2a11: 71,ef,2e            an2b  R2e,ef           Sync_up_fuel = 0;
2a14: f0                  ret                    return;
#######################################################
# Vehicle Speed sensor counts
# handle VSS
#######################################################


  Vss_inth:
2a15: 71,bf,87            an2b  R87,bf           Mph_irq = 0;                      # masked input line data
2a18: 36,90,16            jnb   B6,R90,2a31      if (B6_Last_HSI = 1)  {           # rising edge only
2a1b: 17,b2               incb  Rb2              Mphcnt++;                         # count of VSS ring clicks
2a1d: c7,74,3d,00         stb   R0,[R74+3d]      Tslmph = 0;                       # timer - time since last click
2a21: 3a,c4,05            jb    B2,Rc4,2a29      if (First_mph = 0)  {
2a24: 91,04,c4            orb   Rc4,4            First_mph = 1;                    # set interval start
2a27: 11,b2               clrb  Rb2              Mphcnt = 0; }                     # clear click count
2a29: c3,74,40,7a         stw   R7a,[R74+40]     Mphtiml1 = Event_time;
2a2d: c7,74,42,7c         stb   R7c,[R74+42]     Mphtim1H = Event_timeH; }         # save event time 32 bit 
2a31: f0                  ret                    return;

#######################################################
# data, first 3 entries are cyl/spark angle degrees (*4) = 180,120,90
# last 3 entries are also ratio 1, 1.5, 2 
# matching 4,6,8 cyls - delay time for bank fired injection ?
#######################################################



2a32: d0,02               word    2d0
2a34: e0,01               word    1e0
2a36: 68,01               word    168
2a38: ab,2a               word   2aab
2a3a: 00,40               word   4000
2a3c: 55,55               word   5555

#################################
# start with R50 = pip counter.  KNKCYL =4
# If R50 > 4, Decrement R50 until it equals 4.
# if R50 < 4 then return unchanged Why go to all this trouble with a loop ?
#################################


  knck4:
2a3e: e0,50,04            djnz  R50,2a45         R50--;
                                                 if (R50 != 0) goto 2a45;
2a41: af,f8,48,50         ldzbw R50,[Rf8+48]     R50 = (uns)KNKCYL; }
2a45: 9b,f8,48,50         cmpb  R50,[Rf8+48]     
2a49: d9,f6               jgtu  2a41             if ((uns) R50 > KNKCYL ) goto 2a41;
2a4b: f0                  ret                    return;


  Knock_chk:
2a4c: ac,dc,50            ldzbw R50,Rdc          R50 = (uns)Pip_counter;
2a4f: 36,4f,21            jnb   B6,R4f,2a73      if (Knock_enabled = 1)  {
2a52: 37,4f,1e            jnb   B7,R4f,2a73      if (Knock_occurred = 1)  {
2a55: 98,e1,00            cmpb  R0,Re1           
2a58: d7,19               jne   2a73             if (0 = Tipret)  {
2a5a: b3,51,2b,02,52      ldb   R52,[R50+22b]    R52 = [R50+Spkadv];               # SparkAdvance[ cyl 1 -8 ]
2a5f: 78,e2,52            sb2b  R52,Re2          R52 -= Retinc;
2a62: dd,06               jv    2a6a             if (OVF = 1) goto 2a6a;
2a64: 9b,f8,30,52         cmpb  R52,[Rf8+30]                                       # Max degrees retard
2a68: d6,04               jge   2a6e             if (R52 < Retlim)  {
2a6a: b3,f8,30,52         ldb   R52,[Rf8+30]     R52 = Retlim; }
2a6e: c7,51,2b,02,52      stb   R52,[R50+22b]    [R50+Spkadv] = R52; } } }         # SparkAdvance[ cyl 1 -8 ]
2a73: 2f,c9               scall 2a3e             knck4();
2a75: c4,dc,50            stb   R50,Rdc          Pip_counter = R50;
2a78: 36,4f,0c            jnb   B6,R4f,2a87      if (Knock_enabled = 0) goto 2a87;
2a7b: 37,4f,09            jnb   B7,R4f,2a87      if (Knock_occurred = 0) goto 2a87;
2a7e: b3,f8,48,54         ldb   R54,[Rf8+48]     R54 = KNKCYL;
2a82: 99,01,54            cmpb  R54,1            
2a85: d7,03               jne   2a8a             if (R54 != 1) goto 2a8a;
2a87: 35,2d,12            jnb   B5,R2d,2a9c      if (Ctflg = 1)  {
2a8a: 98,00,e1            cmpb  Re1,R0           
2a8d: d7,0d               jne   2a9c             if (Tipret = 0)  {
2a8f: 36,2d,0a            jnb   B6,R2d,2a9c      if (Tipflg = 1)  {
2a92: b3,f8,32,e1         ldb   Re1,[Rf8+32]     Tipret = Tipinret;                # tip in retard max = 0
2a96: c3,74,ac,aa         stw   Raa,[R74+ac]     Tbart = TP;                       # Throttle position
2a9a: 20,11               sjmp  2aad             goto 2aad; } } }
2a9c: b0,e1,52            ldb   R52,Re1          R52 = Tipret;
2a9f: 77,f8,33,52         ad2b  R52,[Rf8+33]     R52 += TIPINC;                    # (degrees)
2aa3: da,02               jle   2aa7             if ((uns) R52 < 0)  {
2aa5: 11,52               clrb  R52              R52 = 0; }
2aa7: c4,e1,52            stb   R52,Re1          Tipret = R52;
2aaa: 36,4f,15            jnb   B6,R4f,2ac2      if (Knock_enabled = 1)  {
2aad: 2f,8f               scall 2a3e             knck4();
2aaf: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2ab3: df,02               je    2ab7             if (0 != Hphidres)  {
2ab5: 2f,87               scall 2a3e             knck4(); }
2ab7: 57,51,2b,02,e1,52   ad3b  R52,Re1,[R50+22b] R52 = Tipret + [R50+Spkadv];     # SparkAdvance[ cyl 1 -8 ]
2abd: d5,03               jnv   2ac2             if (OVF = 1)  {
2abf: b1,80,52            ldb   R52,80           R52 = 80; } }
2ac2: 16,52               sexb  R52              R52 = (int)R52;
2ac4: 44,c2,52,54         ad3w  R54,R52,Rc2      R54 = R52 + Saf;
2ac8: c3,74,1c,54         stw   R54,[R74+1c]     Saftot = R54;
2acc: bf,f8,0c,52         ldsbw R52,[Rf8+c]      R52 = (int)Splclp;                # Lower limit spark clip
2ad0: 88,52,54            cmpw  R54,R52          
2ad3: d6,05               jge   2ada             if (R54 < R52)  {
2ad5: a0,52,54            ldw   R54,R52          R54 = R52;
2ad8: 20,0c               sjmp  2ae6             goto 2ae6; }
2ada: af,f8,0d,52         ldzbw R52,[Rf8+d]      R52 = (uns)Spuclp;                # Upper limit spark clip
2ade: 88,52,54            cmpw  R54,R52          
2ae1: da,03               jle   2ae6             if ((uns) R54 < R52)  {
2ae3: a0,52,54            ldw   R54,R52          R54 = R52; }
2ae6: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2aea: df,62               je    2b4e             if (0 != Hphidres)  {
2aec: fe,6d,c0,ff,54      sml2w R54,ffc0         R54 *= ffc0;
2af1: 11,52               clrb  R52              R52 = 0;
2af3: 37,57,09            jnb   B7,R57,2aff      if (B7_R57 = 1)  {
2af6: 17,52               incb  R52              R52++;
2af8: 03,54               negw  R54              R54 = -R54;
2afa: a4,00,56            adcw  R56,R0           R56 += CY;
2afd: 02,56               cplw  R56              R56 = ~R56; }
2aff: 8d,0a,00,54         divw  R54,a            R54 /= a;
2b03: 30,52,02            jnb   B0,R52,2b08      if (B0_R52 = 1)  {
2b06: 03,54               negw  R54              R54 = -R54; }
2b08: 65,04,06,54         ad2w  R54,604          R54 += 604;
2b0c: 89,44,00,54         cmpw  R54,44           
2b10: db,06               jc    2b18             if (R54 > 44)  {
2b12: a1,44,00,54         ldw   R54,44           R54 = 44;
2b16: 20,0a               sjmp  2b22             goto 2b22; }
2b18: 89,04,07,54         cmpw  R54,704          
2b1c: d1,04               jleu  2b22             if ((uns) R54 > 704 )  {
2b1e: a1,04,07,54         ldw   R54,704          R54 = Ktmtb100; }
2b22: c3,74,1e,54         stw   R54,[R74+1e]     Sapw = R54;                       # Spark Angle Pulse Width, msec.
2b26: 6d,ab,6a,54         ml2w  R54,6aab         R54 *= 6aab;
2b2a: 75,80,55            ad2b  R55,80           R55 += 80;
2b2d: a4,00,56            adcw  R56,R0           R56 += CY;
2b30: c3,74,ca,56         stw   R56,[R74+ca]     Spout_low_time = R56;
2b34: af,fe,07,50         ldzbw R50,[Rfe+7]      R50 = (uns)PIPsC;                 # or no of PIPs per engine revolution
2b38: a3,51,34,2a,50      ldw   R50,[R50+2a34]   R50 = [R50+2a34];
2b3d: 6c,ba,50            ml2w  R50,Rba          R50 *= PIPHi_ETime;               # PIP time lo 16 bits
2b40: a3,74,50,54         ldw   R54,[R74+50]     R54 = Prev_PIP_time;
2b44: b3,74,52,56         ldb   R56,[R74+52]     R56 = Prev_PIP_timeH;
2b48: 91,04,28            orb   R28,4            Newsa = 1;
2b4b: e7,e6,00            jump  2c34             goto 2c34; }
2b4e: af,fe,07,56         ldzbw R56,[Rfe+7]      R56 = (uns)PIPsC;                 # or no of PIPs per engine revolution
2b52: a3,57,2e,2a,56      ldw   R56,[R56+2a2e]   R56 = [R56+2a2e];
2b57: 45,28,00,56,52      ad3w  R52,R56,28       R52 = R56 + 28;
2b5c: 68,54,52            sb2w  R52,R54          R52 -= R54;
2b5f: 01,50               clrw  R50              R50 = 0;
2b61: 09,01,56            shlw  R56,1            R56 *= 2;
2b64: 8c,56,50            divw  R50,R56          R50 /= R56;
2b67: d5,06               jnv   2b6f             if (OVF = 1)  {
2b69: a3,74,04,58         ldw   R58,[R74+4]      R58 = Old_beta;
2b6d: 20,17               sjmp  2b86             goto 2b86; }
2b6f: c0,58,50            stw   R50,R58          R58 = R50;
2b72: a3,74,04,50         ldw   R50,[R74+4]      R50 = Old_beta;
2b76: 6b,f8,46,50         sb2w  R50,[Rf8+46]     R50 -= Spklim;                    # Max allowed advance in spark timing between spout outputs
2b7a: 88,58,50            cmpw  R50,R58          
2b7d: d1,03               jleu  2b82             if ((uns) R50 > R58 )  {
2b7f: a0,50,58            ldw   R58,R50          R58 = R50; }
2b82: c3,74,04,58         stw   R58,[R74+4]      Old_beta = R58;
2b86: 38,4f,0e            jb    B0,R4f,2b97      if (Pip_double = 0)  {
2b89: 4c,58,ba,50         ml3w  R50,Rba,R58      R50 = PIPHi_ETime * R58;          # PIP time lo 16 bits
2b8d: a3,74,50,54         ldw   R54,[R74+50]     R54 = Prev_PIP_time;
2b91: b3,74,52,56         ldb   R56,[R74+52]     R56 = Prev_PIP_timeH;
2b95: 20,6a               sjmp  2c01             goto 2c01; }
2b97: 49,00,40,58,50      sb3w  R50,R58,4000     R50 = R58 - 4000;
2b9c: 09,01,50            shlw  R50,1            R50 *= 2;
2b9f: b3,76,be,52         ldb   R52,[R76+be]     R52 = Tl0FLG;
2ba3: 37,52,36            jnb   B7,R52,2bdc      if (B7_R52 = 0) goto 2bdc;
2ba6: a3,fe,10,52         ldw   R52,[Rfe+10]     R52 = Trsrpm;                     # Min RPM to enable transient spark routine
2baa: 88,52,ae            cmpw  Rae,R52          
2bad: d9,11               jgtu  2bc0             if ((uns) Rpmx4 > R52 ) goto 2bc0;
2baf: 6b,fe,12,52         sb2w  R52,[Rfe+12]     R52 -= Trsrph;                    # Hysteresis for TRSRPM
2bb3: d3,08               jnc   2bbd             if ((uns) R52 >= 0)  {
2bb5: 88,52,ae            cmpw  Rae,R52          
2bb8: db,03               jc    2bbd             if (Rpmx4 > R52)  {
2bba: 71,ef,26            an2b  R26,ef           Trsprpml = 0; } }
2bbd: 34,26,1c            jnb   B4,R26,2bdc      if (Trsprpml = 0) goto 2bdc;
2bc0: 91,10,26            orb   R26,10           Trsprpml = 1;                     # MAF input range error?
2bc3: a3,76,bc,54         ldw   R54,[R76+bc]     R54 = Prev_PIPH_PW;
2bc7: 6c,c0,54            ml2w  R54,Rc0          R54 *= Mkay;
2bca: 0d,01,54            shldw R54,1            R54 *= 2;
2bcd: 48,56,ba,56         sb3w  R56,Rba,R56      R56 = PIPHi_ETime - R56;          # PIP time lo 16 bits
2bd1: 01,54               clrw  R54              R54 = 0;
2bd3: 0c,01,54            shrdw R54,1            R54 /= 2;
2bd6: 8f,76,bc,54         divw  R54,[R76+bc]     R54 /= Prev_PIPH_PW;
2bda: d5,03               jnv   2bdf             if (OVF = 1)  {
2bdc: a0,c0,54            ldw   R54,Rc0          R54 = Mkay; }
2bdf: 6c,54,50            ml2w  R50,R54          R50 *= R54;
2be2: a0,c0,50            ldw   R50,Rc0          R50 = Mkay;
2be5: 08,01,50            shrw  R50,1            R50 /= 2;
2be8: 64,50,52            ad2w  R52,R50          R52 += R50;
2beb: 69,00,40,52         sb2w  R52,4000         R52 -= 4000;
2bef: 09,01,52            shlw  R52,1            R52 *= 2;
2bf2: 4c,be,52,50         ml3w  R50,R52,Rbe      R50 = R52 * PIPH_PW;
2bf6: 11,56               clrb  R56              R56 = 0;
2bf8: 47,74,50,be,54      ad3w  R54,Rbe,[R74+50] R54 = PIPH_PW + Prev_PIP_time;
2bfd: b7,74,52,56         adcb  R56,[R74+52]     R56 += Prev_PIP_timeH + CY;
2c01: 0d,01,50            shldw R50,1            R50 *= 2;
2c04: 75,80,51            ad2b  R51,80           R51 += 80;
2c07: a4,00,52            adcw  R52,R0           R52 += CY;
2c0a: 91,04,28            orb   R28,4            Newsa = 1;
2c0d: 32,2d,11            jnb   B2,R2d,2c21      if (Double_edge = 1)  {
2c10: 89,a1,01,52         cmpw  R52,1a1          
2c14: d3,06               jnc   2c1c             if ((uns) R52 < 1a1) goto 2c1c;
2c16: 8b,f8,16,ba         cmpw  Rba,[Rf8+16]     
2c1a: db,03               jc    2c1f             if (PIPHi_ETime > PIP_Tlow)  {
2c1c: 71,fb,2d            an2b  R2d,fb           Double_edge = 0; }
2c1f: 20,13               sjmp  2c34             goto 2c34; }
2c21: 48,be,52,50         sb3w  R50,R52,Rbe      R50 = R52 - PIPH_PW;
2c25: 89,f4,01,50         cmpw  R50,1f4          
2c29: da,09               jle   2c34             if ((uns) R50 < 1f4)  {
2c2b: 8b,f8,14,ba         cmpw  Rba,[Rf8+14]     
2c2f: d1,03               jleu  2c34             if ((uns) PIPHi_ETime > SPKSWL )  {
2c31: 91,04,2d            orb   R2d,4            Double_edge = 1; } }
2c34: c3,74,5c,52         stw   R52,[R74+5c]     Next_spout_beta = R52;            # 27E+5C=02DA = 2C5 -15 right in the middle of our Table
2c38: 28,34               scall 2c6e             Upd_Htime_Prev();
2c3a: a1,c8,02,7e         ldw   R7e,2c8          Rtab = Q0;
2c3e: 9b,7e,01,00         cmpb  R0,[R7e+1]       
2c42: d6,19               jge   2c5d             if (0 < [Rtab+1])  {
2c44: 91,01,2d            orb   R2d,1            Spout_pending = 1;
2c47: 4b,7e,02,80,50      sb3w  R50,R80,[R7e+2]  R50 = HSO_time - [Rtab+2];
2c4c: 37,51,0d            jnb   B7,R51,2c5c      if (B7_R51 = 0) return;
2c4f: 91,08,4c            orb   R4c,8            Immediate = 1;
2c52: af,7e,01,92         ldzbw R92,[R7e+1]      TPtr = (uns)[Rtab+1];             # odd 2284 Table offset
2c56: 65,84,22,92         ad2w  R92,2284         TPtr += HSOTable;
2c5a: ca,92               push  [R92]            push([TPtr]); }
2c5c: f0                  ret                    return; }                         # jump with existing return

2c5d: ef,99,f8            call  24f9             Do_CmdN();
2c60: f0                  ret                    return;


  upd_Htime_pend:
2c61: 38,2d,07            jb    B0,R2d,2c6b      if (Spout_pending = 0)  {

# 22a0 proc - save zero flag in 2C5 entry or add PIP & ? time to R80/81/82
2c64: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
2c68: cc,00               pop   R0               R0 = pop();
2c6a: f0                  ret                    return; }

2c6b: 71,fe,2d            an2b  R2d,fe           Spout_pending = 0;

  Upd_Htime_Prev:
2c6e: a3,74,50,80         ldw   R80,[R74+50]     HSO_time = Prev_PIP_time;
2c72: b3,74,52,82         ldb   R82,[R74+52]     HSO_timeH = Prev_PIP_timeH;
2c76: 67,74,5c,80         ad2w  R80,[R74+5c]     HSO_time += Next_spout_beta;
2c7a: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
2c7d: 30,4f,0f            jnb   B0,R4f,2c8f      if (Pip_double = 1)  {
2c80: 64,be,80            ad2w  R80,Rbe          HSO_time += PIPH_PW;
2c83: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
2c86: 20,07               sjmp  2c8f             goto 2c8f;

  Add_SpoutLo:
2c88: 67,74,ca,80         ad2w  R80,[R74+ca]     HSO_time += Spout_low_time;       # 2284 entry proc 
2c8c: b4,00,82            adcb  R82,R0           HSO_timeH += CY; }
2c8f: f8                  clc                    CY = 0
2c90: f0                  ret                    return;


  Calc_dwell:
2c91: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]                                        # 0 = TFI Controlled Dwell
2c95: d7,05               jne   2c9c             if (0 = Tfi_dwell)  {
2c97: a0,be,52            ldw   R52,Rbe          R52 = PIPH_PW;
2c9a: 20,80               sjmp  2d1c             goto 2d1c; }
2c9c: 4d,44,28,ba,54      ml3w  R54,Rba,2844     R54 = PIPHi_ETime * 2844;
2ca1: a0,56,58            ldw   R58,R56          R58 = R56;
2ca4: 8b,74,c6,56         cmpw  R56,[R74+c6]     
2ca8: d3,22               jnc   2ccc             if ((uns) R56 >= Ppereng)  {
2caa: a3,f8,20,50         ldw   R50,[Rf8+20]     R50 = Pacslo;                     # Slope for PIP acceleration
2cae: 6c,56,50            ml2w  R50,R56          R50 *= R56;
2cb1: 0c,04,50            shrdw R50,4            R50 /= 10;
2cb4: 88,52,00            cmpw  R0,R52           
2cb7: d7,0f               jne   2cc8             if (0 != R52) goto 2cc8;
2cb9: 4b,74,c8,50,58      sb3w  R58,R50,[R74+c8] R58 = R50 - Poffeng;
2cbe: db,02               jc    2cc2             if (R58 > 0)  {
2cc0: 01,58               clrw  R58              R58 = 0; }
2cc2: 8b,f8,22,58         cmpw  R58,[Rf8+22]     
2cc6: d1,04               jleu  2ccc             if ((uns) R58 > Paclim )  {
2cc8: a3,f8,22,58         ldw   R58,[Rf8+22]     R58 = Paclim; } }                 # Limit of PIP acceleration
2ccc: c3,74,ba,58         stw   R58,[R74+ba]     Pipacl = R58;
2cd0: a1,00,80,50         ldw   R50,8000         R50 = 8000;
2cd4: 6b,f8,24,50         sb2w  R50,[Rf8+24]     R50 -= SPTADV;
2cd8: 68,58,50            sb2w  R50,R58          R50 -= R58;
2cdb: 6c,ba,50            ml2w  R50,Rba          R50 *= PIPHi_ETime;
2cde: 0d,01,50            shldw R50,1            R50 *= 2;
2ce1: 6b,74,bc,52         sb2w  R52,[R74+bc]     R52 -= Dwlbst;
2ce5: db,02               jc    2ce9             if (R52 > 0)  {
2ce7: 01,52               clrw  R52              R52 = 0; }
2ce9: a0,52,58            ldw   R58,R52          R58 = R52;
2cec: 01,50               clrw  R50              R50 = 0;
2cee: 8c,ba,50            divw  R50,Rba          R50 /= PIPHi_ETime;
2cf1: d5,03               jnv   2cf6             if (OVF = 1)  {
2cf3: bd,ff,50            ldsbw R50,ff           R50 = (int)ff; }
2cf6: a0,50,54            ldw   R54,R50          R54 = R50;
2cf9: 8b,f8,2c,56         cmpw  R56,[Rf8+2c]                                       # Dwell Switch point
2cfd: d1,0d               jleu  2d0c             if ((uns) R56 <= dwLTSW) goto 2d0c;
2cff: a3,f8,26,50         ldw   R50,[Rf8+26]     R50 = Lowdwell;                   # max low speed dwell
2d03: 6c,ba,50            ml2w  R50,Rba          R50 *= PIPHi_ETime;
2d06: 8b,f8,26,54         cmpw  R54,[Rf8+26]     
2d0a: d1,10               jleu  2d1c             if ((uns) R54 > Lowdwell )  {
2d0c: a3,f8,28,50         ldw   R50,[Rf8+28]     R50 = Hidwell;                    # max high speed dwell
2d10: 6c,ba,50            ml2w  R50,Rba          R50 *= PIPHi_ETime;
2d13: 8b,f8,28,54         cmpw  R54,[Rf8+28]     
2d17: d1,03               jleu  2d1c             if ((uns) R54 > Hidwell )  {
2d19: a0,58,52            ldw   R52,R58          R52 = R58; } }
2d1c: c3,74,ca,52         stw   R52,[R74+ca]     Spout_low_time = R52;
2d20: 48,52,ba,52         sb3w  R52,Rba,R52      R52 = PIPHi_ETime - R52;
2d24: c3,74,be,52         stw   R52,[R74+be]     Dwell = R52;
2d28: f0                  ret                    return;

################################################################


  MAF_rd_calc:
2d29: 33,0a,fd            jnb   B3,Ra,2d29       if (AD_Ready = 0) goto 2d29;      # wait for A -D complete
2d2c: 51,f0,04,54         an3b  R54,R4,f0        R54 = AD_Low & f0;                # mask off low bits
2d30: b0,05,55            ldb   R55,R5           R55 = AD_High;
2d33: c3,72,a4,54         stw   R54,[R72+a4]     MAF_Raw = R54;                    # save Raw MAF A/D reading

  MAF_calc:
2d37: 4b,76,ae,52,50      sb3w  R50,R52,[R76+ae] R50 = R52 - Maf_time;
2d3c: c3,76,ae,52         stw   R52,[R76+ae]     Maf_time = R52;
2d40: c3,76,b8,50         stw   R50,[R76+b8]     Intm = R50;
2d44: ef,80,00            call  2dc7             Do_MAF();                         # MAF calibrate/lookup 
2d47: 35,2f,7c            jnb   B5,R2f,2dc6      if (Maf_pip = 0) return;
2d4a: c3,76,36,00         stw   R0,[R76+36]      Runsum = 0;
2d4e: a3,76,b0,50         ldw   R50,[R76+b0]     R50 = Amint;
2d52: c3,76,b6,50         stw   R50,[R76+b6]     Rawairchg = R50;
2d56: af,76,39,52         ldzbw R52,[R76+39]     R52 = (uns)Archcor;
2d5a: 6c,52,50            ml2w  R50,R52          R50 *= R52;
2d5d: 0c,07,50            shrdw R50,7            R50 /= 80;
2d60: 67,74,d6,50         ad2w  R50,[R74+d6]     R50 += Archli;
2d64: db,06               jc    2d6c             if ((uns) R50 >= 0) goto 2d6c;
2d66: 8b,76,2c,50         cmpw  R50,[R76+2c]     
2d6a: d1,04               jleu  2d70             if ((uns) R50 > Air37 )  {
2d6c: a3,76,2c,50         ldw   R50,[R76+2c]     R50 = Air37; }
2d70: c3,74,d8,50         stw   R50,[R74+d8]     Archi = R50;
2d74: a0,50,54            ldw   R54,R50          R54 = R50;
2d77: 31,26,44            jnb   B1,R26,2dbe      if (Archflg = 1)  {
2d7a: 01,52               clrw  R52              R52 = 0;
2d7c: 0d,08,50            shldw R50,8            R50 *= 100;
2d7f: a3,74,da,58         ldw   R58,[R74+da]     R58 = Archfg;
2d83: 8c,58,50            divw  R50,R58          R50 /= R58;
2d86: dd,0a               jv    2d92             if (OVF = 1) goto 2d92;
2d88: a3,f6,02,52         ldw   R52,[Rf6+2]      R52 = Fkarch;                     # Manifold filling - slow filter
2d8c: 8b,f6,06,50         cmpw  R50,[Rf6+6]                                        # Fraction - slow vs fast filter
2d90: d1,04               jleu  2d96             if ((uns) R50 > Filfrc )  {
2d92: a3,f6,04,52         ldw   R52,[Rf6+4]      R52 = Fkarc1; }                   # Manifold filling - fast filter
2d96: 11,5a               clrb  R5a              R5a = 0;
2d98: 68,58,54            sb2w  R54,R58          R54 -= R58;
2d9b: db,04               jc    2da1             if (R54 > 0)  {
2d9d: 17,5a               incb  R5a              R5a++;
2d9f: 03,54               negw  R54              R54 = -R54; }
2da1: 89,01,00,54         cmpw  R54,1            
2da5: d9,05               jgtu  2dac             if ((uns) R54 <= 1)  {
2da7: a0,58,50            ldw   R50,R58          R50 = R58;
2daa: 20,12               sjmp  2dbe             goto 2dbe; }
2dac: 6c,52,54            ml2w  R54,R52          R54 *= R52;
2daf: 03,56               negw  R56              R56 = -R56;
2db1: d7,02               jne   2db5             if (R56 = 0)  {
2db3: 05,56               decw  R56              R56--; }
2db5: 38,5a,02            jb    B0,R5a,2dba      if (B0_R5a = 0)  {
2db8: 03,56               negw  R56              R56 = -R56; }
2dba: 44,58,56,50         ad3w  R50,R56,R58      R50 = R56 + R58; }
2dbe: c3,74,da,50         stw   R50,[R74+da]     Archfg = R50;
2dc2: c3,76,b0,00         stw   R0,[R76+b0]      Amint = 0; }
2dc6: f0                  ret                    return;

################################################################
# MAF/calibrate/lookup in transfer function
# This seems to use its own code for func lookup for some reason
#######################################################################


  Do_MAF:
2dc7: a3,72,a4,50         ldw   R50,[R72+a4]     R50 = MAF_Raw;
2dcb: 6d,00,28,50         ml2w  R50,2800         R50 *= 2800;                      # Scale raw MAF value
2dcf: 8f,72,90,50         divw  R50,[R72+90]     R50 /= VSS_Raw;                   # Scale via Batt Ref Voltage
2dd3: d5,03               jnv   2dd8             if (OVF = 1)  {
2dd5: bd,ff,50            ldsbw R50,ff           R50 = (int)ff; }                  # clamp max MAF voltage
2dd8: c3,74,d0,50         stw   R50,[R74+d0]     Vmaf = R50;                       # save value
2ddc: a3,76,b4,52         ldw   R52,[R76+b4]     R52 = Maf_ptr;                    # MAF transfer function pointer
2de0: 8a,52,50            cmpw  R50,[R52]                                          # Table max MAF voltage
2de3: d7,06               jne   2deb             if (R50 = [R52])  {
2de5: a3,52,02,54         ldw   R54,[R52+2]      R54 = [R52+2];                    # shortcut if max value/Air flow
2de9: 20,36               sjmp  2e21             goto 2e21; }                      # end Table look up
2deb: d3,0b               jnc   2df8             if ((uns) R50 >= [R52])  {
2ded: 69,04,00,52         sb2w  R52,4            R52 -= 4;                         # back up in MAF transfer function Table to the right value
2df1: 8a,52,50            cmpw  R50,[R52]        
2df4: d9,f7               jgtu  2ded             if ((uns) R50 > [R52] ) goto 2ded; # loop
2df6: 20,0d               sjmp  2e05             goto 2e05; }
2df8: 65,04,00,52         ad2w  R52,4            R52 += 4;                         # jmp ahead in the MAF transfer function to the right value
2dfc: 8a,52,50            cmpw  R50,[R52]        
2dff: d3,f7               jnc   2df8             if ((uns) R50 < [R52]) goto 2df8; # loop
2e01: 69,04,00,52         sb2w  R52,4            R52 -= 4;
2e05: a2,53,58            ldw   R58,[R52++]      R58 = [R52++];                    # interpolate larger MAF
2e08: a2,53,54            ldw   R54,[R52++]      R54 = [R52++];                    # larger air flow
2e0b: 6a,52,58            sb2w  R58,[R52]        R58 -= [R52];                     # MAF difference
2e0e: 6a,53,50            sb2w  R50,[R52++]      R50 -= [R52++];                   # MAF delta to interpolate
2e11: 6a,52,54            sb2w  R54,[R52]        R54 -= [R52];                     # air flow difference
2e14: 6c,50,54            ml2w  R54,R50          R54 *= R50;
2e17: 8c,58,54            divw  R54,R58          R54 /= R58;
2e1a: 66,53,54            ad2w  R54,[R52++]      R54 += [R52++];                   # interpolated air flow
2e1d: 69,04,00,52         sb2w  R52,4            R52 -= 4;
2e21: c3,76,b4,52         stw   R52,[R76+b4]     Maf_ptr = R52;                    # Save last MAF tfr func ptr - for speed?
2e25: a3,74,d2,50         ldw   R50,[R74+d2]     R50 = Maf;                        # old MAF value
2e29: c3,74,d2,54         stw   R54,[R74+d2]     Maf = R54;                        # MAF not in Kg/Hr
2e2d: 01,52               clrw  R52              R52 = 0;
2e2f: 64,54,50            ad2w  R50,R54          R50 += R54;                       # add old and new MAF values
2e32: a5,00,00,52         adcw  R52,0            R52 += CY;
2e36: 0c,01,50            shrdw R50,1            R50 /= 2;                         # avg/2
2e39: 6f,76,b8,50         ml2w  R50,[R76+b8]     R50 *= Intm;
2e3d: 0d,09,50            shldw R50,9            R50 *= 200;
2e40: 67,01,b0,03,50      ad2w  R50,[R0+3b0]     R50 += Runsum;
2e45: c3,01,b0,03,50      stw   R50,[R0+3b0]     Runsum = R50;                     # Running Total ?
2e4a: a4,00,52            adcw  R52,R0           R52 += CY;
2e4d: 67,76,b0,52         ad2w  R52,[R76+b0]     R52 += Amint;
2e51: d3,03               jnc   2e56             if ((uns) R52 >= 0)  {
2e53: bd,ff,52            ldsbw R52,ff           R52 = (int)ff; }
2e56: c3,76,b0,52         stw   R52,[R76+b0]     Amint = R52;
2e5a: f0                  ret                    return;
##########################################################


  Sub4:
2e5b: 01,52               clrw  R52              R52 = 0;                          # start port = 0
2e5d: a3,53,94,03,54      ldw   R54,[R52+394]    R54 = [R52+Bgful1];
2e62: 35,e7,2d            jnb   B5,Re7,2e92      if (Ffulflg = 1)  {
2e65: a3,74,da,54         ldw   R54,[R74+da]     R54 = Archfg;
2e69: 6f,53,98,03,54      ml2w  R54,[R52+398]    R54 *= [R52+Ffulm1];
2e6e: 8f,76,26,54         divw  R54,[R76+26]     R54 /= Archg_bg;
2e72: d5,03               jnv   2e77             if (OVF = 1)  {
2e74: bd,ff,54            ldsbw R54,ff           R54 = (int)ff; }
2e77: a3,53,9c,03,56      ldw   R56,[R52+39c]    R56 = [R52+Ffulc1];
2e7c: 37,57,0b            jnb   B7,R57,2e8a      if (B7_R57 = 0) goto 2e8a;
2e7f: 03,56               negw  R56              R56 = -R56;
2e81: 68,56,54            sb2w  R54,R56          R54 -= R56;
2e84: db,0c               jc    2e92             if (R54 > 0)  {
2e86: 01,54               clrw  R54              R54 = 0;
2e88: 20,08               sjmp  2e92             goto 2e92;
2e8a: 64,56,54            ad2w  R54,R56          R54 += R56;
2e8d: d3,03               jnc   2e92             if ((uns) R54 >= 0)  {
2e8f: bd,ff,54            ldsbw R54,ff           R54 = (int)ff; } } }
2e92: 6d,73,cb,54         ml2w  R54,cb73         R54 *= cb73;
2e96: a0,56,50            ldw   R50,R56          R50 = R56;
2e99: 01,5a               clrw  R5a              R5a = 0;
2e9b: 98,bc,00            cmpb  R0,Rbc           
2e9e: d7,31               jne   2ed1             if (0 = PIPHi_ETimeH)  {
2ea0: 0c,0a,54            shrdw R54,a            R54 /= 400;
2ea3: 8c,ba,54            divw  R54,Rba          R54 /= PIPHi_ETime;
2ea6: 8b,fc,2e,54         cmpw  R54,[Rfc+2e]     
2eaa: d3,10               jnc   2ebc             if ((uns) R54 >= [9aac])  {
2eac: a3,fc,2e,54         ldw   R54,[Rfc+2e]     R54 = [9aac];
2eb0: 05,54               decw  R54              R54--;
2eb2: 4c,ba,54,58         ml3w  R58,R54,Rba      R58 = R54 * PIPHi_ETime;
2eb6: 0c,06,58            shrdw R58,6            R58 /= 40;
2eb9: a0,58,50            ldw   R50,R58          R50 = R58; }
2ebc: 01,5a               clrw  R5a              R5a = 0;
2ebe: a3,72,0e,58         ldw   R58,[R72+e]      R58 = Pwoff;
2ec2: 0d,05,58            shldw R58,5            R58 *= 20;
2ec5: 8c,ba,58            divw  R58,Rba          R58 /= PIPHi_ETime;
2ec8: 44,58,54,5a         ad3w  R5a,R54,R58      R5a = R54 + R58;
2ecc: d3,03               jnc   2ed1             if ((uns) R5a >= 0)  {
2ece: ad,ff,5a            ldzbw R5a,ff           R5a = (uns)ff; } }
2ed1: 01,54               clrw  R54              R54 = 0;
2ed3: 4b,53,06,02,50,56   sb3w  R56,R50,[R52+206] R56 = R50 - [R52+Fuelpw1];       # Injector Pulse Width 
2ed9: db,02               jc    2edd             if (R56 > 0)  {
2edb: 03,56               negw  R56              R56 = -R56; }
2edd: 8f,53,06,02,54      divw  R54,[R52+206]    R54 /= [R52+Fuelpw1];
2ee2: 89,99,19,54         cmpw  R54,1999         
2ee6: d1,03               jleu  2eeb             if ((uns) R54 > 1999 )  {
2ee8: 91,80,48            orb   R48,80           Change_fuelpw = 1; }
2eeb: c3,53,06,02,50      stw   R50,[R52+206]    [R52+Fuelpw1] = R50;
2ef0: 37,2e,13            jnb   B7,R2e,2f06      if (Fuel_in_sync = 0) goto 2f06;
2ef3: 31,52,0a            jnb   B1,R52,2f00      if (B1_R52 = 0) goto 2f00;
2ef6: 3e,2f,02            jb    B6,R2f,2efb      if (New_idelay2 = 1) goto 2efb;
2ef9: 20,9e               sjmp  2f99             goto 2f99;
2efb: 71,bf,2f            an2b  R2f,bf           New_idelay2 = 0;
2efe: 20,06               sjmp  2f06             goto 2f06;
2f00: 37,2f,f6            jnb   B7,R2f,2ef9      if (New_idelay1 = 0) goto 2ef9;
2f03: 71,7f,2f            an2b  R2f,7f           New_idelay1 = 0;
2f06: a3,f4,24,54         ldw   R54,[Rf4+24]     R54 = Injref;                     # which edge for fuel pulse
2f0a: 6c,5a,54            ml2w  R54,R5a          R54 *= R5a;
2f0d: 01,5a               clrw  R5a              R5a = 0;
2f0f: a3,72,00,58         ldw   R58,[R72+0]      R58 = Injdly;
2f13: 31,52,02            jnb   B1,R52,2f18      if (B1_R52 = 1)  {
2f16: 15,52               decb  R52              R52--; }
2f18: 65,80,02,58         ad2w  R58,280          R58 += Last_bap;
2f1c: 0d,01,58            shldw R58,1            R58 *= 2;
2f1f: 8f,fc,2c,58         divw  R58,[Rfc+2c]     R58 /= [9aaa];                    # 180 = 4 cyl
2f23: 68,54,58            sb2w  R58,R54          R58 -= R54;
2f26: db,04               jc    2f2c             if (R58 > 0)  {
2f28: 67,fc,2a,58         ad2w  R58,[Rfc+2a]     R58 += [9aa8]; }
2f2c: 37,2e,5c            jnb   B7,R2e,2f8b      if (Fuel_in_sync = 1)  {
2f2f: 3b,2f,57            jb    B3,R2f,2f89      if (Nlmt_flg = 0)  {
2f32: af,53,6e,02,54      ldzbw R54,[R52+26e]    R54 = (uns)[R52+Total_delay1];
2f37: af,fe,07,50         ldzbw R50,[Rfe+7]      R50 = (uns)PIPsC;                 # PIPs per engine revolution
2f3b: 6f,51,be,2f,54      ml2w  R54,[R50+2fbe]   R54 *= [R50+2fbe];
2f40: 6f,51,be,2f,58      ml2w  R58,[R50+2fbe]   R58 *= [R50+2fbe];
2f45: 0c,06,54            shrdw R54,6            R54 /= 40;
2f48: 0c,06,58            shrdw R58,6            R58 /= 40;
2f4b: 68,54,58            sb2w  R58,R54          R58 -= R54;
2f4e: b8,00,56            sbbb  R56,R0           R56 -= CY;
2f51: d6,02               jge   2f55             if (R56 < 0)  {
2f53: 03,58               negw  R58              R58 = -R58; }
2f55: a3,fc,2a,5a         ldw   R5a,[Rfc+2a]     R5a = [9aa8];
2f59: 09,07,5a            shlw  R5a,7            R5a *= 80;
2f5c: 88,58,5a            cmpw  R5a,R58          
2f5f: db,04               jc    2f65             if (R5a > R58)  {
2f61: 03,58               negw  R58              R58 = -R58;
2f63: 15,56               decb  R56              R56--; }
2f65: 89,00,10,58         cmpw  R58,1000         
2f69: d1,04               jleu  2f6f             if ((uns) R58 > 1000 )  {
2f6b: a1,00,10,58         ldw   R58,1000         R58 = 1000; }
2f6f: 30,56,02            jnb   B0,R56,2f74      if (B0_R56 = 1)  {
2f72: 03,58               negw  R58              R58 = -R58; }
2f74: 64,54,58            ad2w  R58,R54          R58 += R54;
2f77: a3,51,be,2f,50      ldw   R50,[R50+2fbe]   R50 = [R50+2fbe];
2f7c: 08,06,50            shrw  R50,6            R50 /= 40;
2f7f: 01,5a               clrw  R5a              R5a = 0;
2f81: 8c,50,58            divw  R58,R50          R58 /= R50;
2f84: c7,53,6e,02,58      stb   R58,[R52+26e]    [R52+Total_delay1] = R58; }
2f89: 20,0e               sjmp  2f99             goto 2f99; }
2f8b: 34,2e,0b            jnb   B4,R2e,2f99      if (Sync_up_fuel = 1)  {
2f8e: c7,74,f0,58         stb   R58,[R74+f0]     Total_delay1 = R58;
2f92: c7,74,f1,58         stb   R58,[R74+f1]     Total_delay2 = R58;
2f96: 91,80,2e            orb   R2e,80           Fuel_in_sync = 1; }
2f99: 71,f7,2e            an2b  R2e,f7           Simultaneous = 0;
2f9c: b1,02,5a            ldb   R5a,2            R5a = 2;                          # sequential (=1) or simultaneous (=2) injections
2f9f: 9b,fc,33,5a         cmpb  R5a,[Rfc+33]     
2fa3: df,03               je    2fa8             if (R5a = Outinj) goto 2fa8;
2fa5: 37,a1,0b            jnb   B7,Ra1,2fb3      if (Cranking = 1)  {
2fa8: 91,08,2e            orb   R2e,8            Simultaneous = 1;
2fab: c7,74,ee,00         stb   R0,[R74+ee]      Inj_bank1 = 0;
2faf: c7,74,ef,00         stb   R0,[R74+ef]      Inj_bank2 = 0; }
2fb3: 88,00,52            cmpw  R52,R0           
2fb6: d7,09               jne   2fc1             if (R52 != 0) return;
2fb8: af,fe,16,52         ldzbw R52,[Rfe+16]     R52 = (uns)No_hegos;
2fbc: 31,52,02            jnb   B1,R52,2fc1      if (B1_R52 = 0) return;
2fbf: 26,9c               sjmp  2e5d             goto 2e5d; }
2fc1: f0                  ret                    return;

 ########## something to do with injection and no of cyls called from 2f3b



2fc2: 00,80               word   8000                                              # 4 cyl
2fc4: 80,55               word   5580                                              # 6 cyl
2fc6: 00,40               word   4000                                              # 8 cyl


  Sub5:
2fc8: bd,ff,56            ldsbw R56,ff           R56 = (int)ff;
2fcb: 07,56               incw  R56              R56++;
2fcd: b3,57,6a,02,54      ldb   R54,[R56+26a]    R54 = [R56+Inj_pip_cnt1];
2fd2: 15,54               decb  R54              R54--;
2fd4: df,02               je    2fd8             if (R54 = 0) goto 2fd8;
2fd6: 20,e2               sjmp  30ba             goto 30ba;
2fd8: 91,20,2e            orb   R2e,20           Base_fuel = 1;
2fdb: b3,01,be,03,54      ldb   R54,[R0+3be]     R54 = Piplim;
2fe0: 37,a1,19            jnb   B7,Ra1,2ffc      if (Cranking = 1)  {
2fe3: 9b,fc,34,00         cmpb  R0,[Rfc+34]      
2fe7: d7,05               jne   2fee             if (0 != [9ab2]) goto 2fee;
2fe9: 30,90,05            jnb   B0,R90,2ff1      if (B0_Last_HSI = 0) goto 2ff1;
2fec: 20,09               sjmp  2ff7             goto 2ff7;
2fee: 30,90,06            jnb   B0,R90,2ff7      if (B0_Last_HSI = 1)  {
2ff1: b3,fc,30,54         ldb   R54,[Rfc+30]     R54 = [9aae];
2ff5: 20,05               sjmp  2ffc             goto 2ffc; }
2ff7: b1,01,54            ldb   R54,1            R54 = 1;
2ffa: 20,be               sjmp  30ba             goto 30ba; }
2ffc: 3b,2e,35            jb    B3,R2e,3034      if (Simultaneous = 1) goto 3034;
2fff: af,57,6c,02,52      ldzbw R52,[R56+26c]    R52 = (uns)[R56+Inj_bank1];
3004: 17,52               incb  R52              R52++;
3006: 9b,fc,32,52         cmpb  R52,[Rfc+32]                                       # 8 - no of cyls
300a: d3,02               jnc   300e             if ((uns) R52 >= Cyl_wrap)  {
300c: 11,52               clrb  R52              R52 = 0; }
300e: c7,57,6c,02,52      stb   R52,[R56+26c]    [R56+Inj_bank1] = R52;            # R52 is cyl sequence ?
3013: 45,e3,01,f4,5a      ad3w  R5a,Rf4,1e3      R5a = Inj_order;                  # Load Injector firing order
3018: 64,52,5a            ad2w  R5a,R52          R5a += R52;                       # ROM ptr to injector to fire from sequence no
301b: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # R50 is cyl no
301e: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = Inj_opport;                 # Injector Output Port
3023: 64,50,5a            ad2w  R5a,R50          R5a += R50;                       # Ptr to port from cyl no
3026: b2,5a,50            ldb   R50,[R5a]        R50 = [R5a];                      # port to fire (0 or 2)
3029: 38,56,05            jb    B0,R56,3031      if (B0_R56 = 1) goto 3031;
302c: 31,50,05            jnb   B1,R50,3034      if (B1_R50 = 0) goto 3034;        # test port - jmp on port = 0
302f: 20,89               sjmp  30ba             goto 30ba;
3031: 31,50,fb            jnb   B1,R50,302f      if (B1_R50 = 0) goto 302f;
3034: 01,52               clrw  R52              R52 = 0;
3036: 34,2e,6c            jnb   B4,R2e,30a5      if (Sync_up_fuel = 1)  {
3039: af,57,6c,02,52      ldzbw R52,[R56+26c]    R52 = (uns)[R56+Inj_bank1];
303e: b3,fc,32,5a         ldb   R5a,[Rfc+32]     R5a = Cyl_wrap;                   # 8 - no of cyls
3042: 99,02,5a            cmpb  R5a,2            
3045: d7,0a               jne   3051             if (R5a = 2)  {
3047: 30,52,07            jnb   B0,R52,3051      if (B0_R52 = 1)  {
304a: af,fe,07,52         ldzbw R52,[Rfe+7]      R52 = (uns)PIPsC;
304e: 08,01,52            shrw  R52,1            R52 /= 2; } }
3051: 09,05,52            shlw  R52,5            R52 *= 20;
3054: ac,d1,50            ldzbw R50,Rd1          R50 = (uns)Synctr;
3057: 68,52,50            sb2w  R50,R52          R50 -= R52;
305a: db,04               jc    3060             if (R50 > 0)  {
305c: 67,fc,2a,50         ad2w  R50,[Rfc+2a]     R50 += [9aa8]; }
3060: af,57,6e,02,52      ldzbw R52,[R56+26e]    R52 = (uns)[R56+Total_delay1];
3065: 68,50,52            sb2w  R52,R50          R52 -= R50;
3068: db,04               jc    306e             if (R52 > 0)  {
306a: 67,fc,2a,52         ad2w  R52,[Rfc+2a]     R52 += [9aa8]; }
306e: 99,30,52            cmpb  R52,30           
3071: d1,08               jleu  307b             if ((uns) R52 > 30 )  {
3073: 75,02,54            ad2b  R54,2            R54 += 2;
3076: b1,18,52            ldb   R52,18           R52 = 18;
3079: 20,2a               sjmp  30a5             goto 30a5; }
307b: 38,56,05            jb    B0,R56,3083      if (B0_R56 = 0)  {
307e: 91,80,2f            orb   R2f,80           New_idelay1 = 1;
3081: 20,03               sjmp  3086             goto 3086; }
3083: 91,40,2f            orb   R2f,40           New_idelay2 = 1;
3086: 99,20,52            cmpb  R52,20           
3089: db,1a               jc    30a5             if (R52 > 20)  {
308b: 38,90,02            jb    B0,R90,3090      if (B0_Last_HSI = 0)  {
308e: 15,54               decb  R54              R54--; }
3090: 99,10,52            cmpb  R52,10           
3093: db,10               jc    30a5             if (R52 > 10)  {
3095: 75,20,52            ad2b  R52,20           R52 += 20;
3098: 15,54               decb  R54              R54--;
309a: 38,56,05            jb    B0,R56,30a2      if (B0_R56 = 0)  {
309d: 71,7f,2f            an2b  R2f,7f           New_idelay1 = 0;
30a0: 20,03               sjmp  30a5             goto 30a5; }
30a2: 71,bf,2f            an2b  R2f,bf           New_idelay2 = 0; } } }
30a5: c4,59,52            stb   R52,R59          R59 = R52;
30a8: 91,04,2e            orb   R2e,4            New_ibeta = 1;
30ab: 98,54,00            cmpb  R0,R54           
30ae: de,03               jlt   30b3             if (0 >= R54)  {
30b0: b1,01,54            ldb   R54,1            R54 = 1; }
30b3: c7,57,6a,02,54      stb   R54,[R56+26a]    [R56+Inj_pip_cnt1] = R54;
30b8: 20,07               sjmp  30c1             goto 30c1;
30ba: c7,57,6a,02,54      stb   R54,[R56+26a]    [R56+Inj_pip_cnt1] = R54;
30bf: 20,a4               sjmp  3165             goto 3165;
30c1: b3,57,6c,02,58      ldb   R58,[R56+26c]    R58 = [R56+Inj_bank1];
30c6: c8,56               push  R56              push(R56);
30c8: af,57,6c,02,54      ldzbw R54,[R56+26c]    R54 = (uns)[R56+Inj_bank1];
30cd: 64,f4,54            ad2w  R54,Rf4          R54 += Rf4;
30d0: b3,55,e3,01,54      ldb   R54,[R54+1e3]    R54 = [R54+1e3];                  # injector firing order ?
30d5: 35,2a,0a            jnb   B5,R2a,30e2      if (Self_test = 1)  {             # not self test

########### get cyl no (in R54)
30d8: 9b,74,94,54         cmpb  R54,[R74+94]     
30dc: d7,04               jne   30e2             if (R54 = Vcutout)  {
30de: cc,56               pop   R56              R56 = pop();
30e0: 20,83               sjmp  3165             goto 3165; } }
30e2: 30,e7,0a            jnb   B0,Re7,30ef      if (Fofflg = 1)  {
30e5: 95,02,e7            xorb  Re7,2            Fgfflg ^= 1;
30e8: 39,e7,04            jb    B1,Re7,30ef      if (Fgfflg = 0)  {
30eb: cc,56               pop   R56              R56 = pop();
30ed: 20,76               sjmp  3165             goto 3165; } }
30ef: 79,01,54            sb2b  R54,1            R54 -= 1;                         # entry no - 1
30f2: 5d,16,54,92         ml3b  R92,R54,16       TPtr = R54 * 16;                  # 2284 Table cell for cyl
30f6: 65,a6,22,92         ad2w  R92,22a6         TPtr += InjTTab;                  # convert cell to table pointer
30fa: 47,92,08,f4,54      ad3w  R54,Rf4,[R92+8]  R54 = Rf4 + [TPtr+8];             # =91B8, Injector Output Port
30ff: af,55,da,01,54      ldzbw R54,[R54+1da]    R54 = (uns)[R54+Code_ones_ex];    # load port from cyl no
3104: 8b,55,06,02,00      cmpw  R0,[R54+206]                                       # PulseWidth? - port 0 or 2
3109: df,17               je    3122             if (0 != [R54+Fuelpw1])  {
310b: 32,a1,08            jnb   B2,Ra1,3116      if (Undsp = 1)  {
310e: a0,8c,80            ldw   R80,R8c          HSO_time = Reftime;
3111: b0,8e,82            ldb   R82,R8e          HSO_timeH = ReftimeH;
3114: 20,08               sjmp  311e             goto 311e; }
3116: 28,82               scall 319a             Set_bank_inj();
3118: a0,50,80            ldw   R80,R50          HSO_time = R50;
311b: b0,52,82            ldb   R82,R52          HSO_timeH = R52;
311e: 28,a4               scall 31c4             Do_inj?();
3120: 20,10               sjmp  3132             goto 3132; }
3122: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];             # 2C5 Table?
3126: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;
312a: c3,7e,fe,8c         stw   R8c,[R7e+fe]     [Rtab-2] = Reftime;               # set time for this injector to fire
312e: c7,7e,fd,8e         stb   R8e,[R7e+fd]     [Rtab-3] = ReftimeH;
3132: cc,56               pop   R56              R56 = pop();
3134: 71,df,2e            an2b  R2e,df           Base_fuel = 0;
3137: 33,2e,2b            jnb   B3,R2e,3165      if (Simultaneous = 1)  {
313a: b3,57,6c,02,54      ldb   R54,[R56+26c]    R54 = [R56+Inj_bank1];            # 2C5 Table?
313f: 17,54               incb  R54              R54++;
3141: 9b,fc,32,54         cmpb  R54,[Rfc+32]                                       # 8 - no of cyls
3145: d3,02               jnc   3149             if ((uns) R54 >= Cyl_wrap)  {
3147: 11,54               clrb  R54              R54 = 0; }                        # wrap cyl count
3149: c7,57,6c,02,54      stb   R54,[R56+26c]    [R56+Inj_bank1] = R54;            # what does this do?
314e: 30,54,0a            jnb   B0,R54,315b      if (B0_R54 = 1)  {
3151: 95,40,02            xorb  R2,40            CPU_OK ^= 1;
3154: 17,05               incb  R5               WDG_Timer++;
3156: 17,05               incb  R5               WDG_Timer++;
3158: 95,40,02            xorb  R2,40            CPU_OK ^= 1; }                    # watchdog and LOS reset
315b: 98,54,58            cmpb  R58,R54          
315e: df,05               je    3165             if (R58 != R54)  {
3160: 91,20,2e            orb   R2e,20           Base_fuel = 1;
3163: 27,61               sjmp  30c6             goto 30c6; } }
3165: 32,2e,05            jnb   B2,R2e,316d      if (New_ibeta = 1)  {
3168: c7,57,70,02,59      stb   R59,[R56+270]    [R56+Ibeta1] = R59; }
316d: 71,db,2e            an2b  R2e,db           New_ibeta = 0;
                                                 Base_fuel = 0;
3170: 3b,2e,0e            jb    B3,R2e,3181      if (Simultaneous = 1) goto 3181;
3173: b3,fe,16,50         ldb   R50,[Rfe+16]     R50 = No_hegos;
3177: 38,50,0f            jb    B0,R50,3189      if (B0_R50 = 1) return;
317a: 38,56,0c            jb    B0,R56,3189      if (B0_R56 = 1) return;
317d: 26,4c               sjmp  2fcb             goto 2fcb;


317f: 20,08               ??                                                       # Not called ?

3181: b3,74,ec,50         ldb   R50,[R74+ec]     R50 = Inj_pip_cnt1;
3185: c7,74,ed,50         stb   R50,[R74+ed]     Inj_pip_cnt2 = R50;
3189: f0                  ret                    return;


  UPd_Inj_pend:
318a: b3,92,07,54         ldb   R54,[R92+7]      R54 = [TPtr+7];                   # 2C5 Table ?
318e: 73,72,12,54         an2b  R54,[R72+12]     R54 &= Inj_pending;
3192: c7,72,12,54         stb   R54,[R72+12]     Inj_pending = R54;
3196: 71,ef,4f            an2b  R4f,ef           Pending = 0;
3199: f0                  ret                    return;

######################################################################
# Bank Injection (unsynced fuel) setup ?
######################################################################


  Set_bank_inj:
319a: a3,92,08,50         ldw   R50,[R92+8]      R50 = [TPtr+8];                   # R50 is scyl no ?
319e: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = Inj_opport;                 # Injector Output Port(Inj port vs cyl)
31a3: 64,50,5a            ad2w  R5a,R50          R5a += R50;                       # add cylno
31a6: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # load port (0 or 2) from ROM Table
31a9: 31,50,02            jnb   B1,R50,31ae      if (B1_R50 = 1)  {                # jmp if port == 0 (not 2)
31ac: 15,50               decb  R50              R50--; }                          # change port 2 into 1
31ae: b3,51,70,02,51      ldb   R51,[R50+270]    R51 = [R50+Ibeta1];               # Table indexed by port 0 or 1
31b3: 11,50               clrb  R50              R50 = 0;
31b5: 6c,ba,50            ml2w  R50,Rba          R50 *= PIPHi_ETime;               # PIP time lo 16 bits
31b8: 0c,0d,50            shrdw R50,d            R50 /= 2000;                      # R50 = R50 * 8192
31bb: 67,74,50,50         ad2w  R50,[R74+50]     R50 += Prev_PIP_time;
31bf: b7,74,52,52         adcb  R52,[R74+52]     R52 += Prev_PIP_timeH + CY;
31c3: f0                  ret                    return;

######################################################################
 Cyl Injection (synced fuel) setup ?
######################################################################


  Do_inj?:
31c4: 71,f7,2d            an2b  R2d,f7           No_fuel_save = 0;
31c7: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];
31cb: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;
31cf: 35,2e,0c            jnb   B5,R2e,31de      if (Base_fuel = 1)  {
31d2: b3,92,06,50         ldb   R50,[R92+6]      R50 = [TPtr+6];
31d6: 93,72,10,50         orb   R50,[R72+10]     R50 |= Inj_base;
31da: c7,72,10,50         stb   R50,[R72+10]     Inj_base = R50; }
31de: b3,92,07,50         ldb   R50,[R92+7]      R50 = [TPtr+7];
31e2: 73,72,11,50         an2b  R50,[R72+11]     R50 &= Inj_pip;
31e6: c7,72,11,50         stb   R50,[R72+11]     Inj_pip = R50;
31ea: a1,2a,00,50         ldw   R50,2a           R50 = 2a;
31ee: 43,92,0a,44,00      an3w  R0,R44,[R92+a]   R0 = HSOut_Flags & [TPtr+a];
31f3: df,42               je    3237             if (R0 = 0) goto 3237;
31f5: 67,7e,02,50         ad2w  R50,[R7e+2]      R50 += [Rtab+2];
31f9: b3,7e,04,52         ldb   R52,[R7e+4]      R52 = [Rtab+4];
31fd: b4,00,52            adcb  R52,R0           R52 += CY;
3200: 88,50,80            cmpw  R80,R50          
3203: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3206: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;
3209: 37,86,1e            jnb   B7,R86,322a      if (B7_R86 = 1)  {
320c: 35,2e,0b            jnb   B5,R2e,321a      if (Base_fuel = 1)  {
320f: 91,08,2d            orb   R2d,8            No_fuel_save = 1;
3212: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;              # schedule event time 
3216: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH; }
321a: a3,7e,02,80         ldw   R80,[R7e+2]      HSO_time = [Rtab+2];
321e: b3,7e,04,82         ldb   R82,[R7e+4]      HSO_timeH = [Rtab+4];
3222: 28,a9               scall 32cd             Sub8();
3224: 71,f7,2d            an2b  R2d,f7           No_fuel_save = 0;
3227: e7,33,f2            jump  245d             goto Sched_HSO; }                 # Add for execution in 2284/2C5 Table
322a: b3,92,06,50         ldb   R50,[R92+6]      R50 = [TPtr+6];
322e: 93,72,12,50         orb   R50,[R72+12]     R50 |= Inj_pending;
3232: c7,72,12,50         stb   R50,[R72+12]     Inj_pending = R50;
3236: f0                  ret                    return;

3237: 67,7e,fe,50         ad2w  R50,[R7e+fe]     R50 += [Rtab-2];
323b: b3,7e,fd,52         ldb   R52,[R7e+fd]     R52 = [Rtab-3];
323f: b4,00,52            adcb  R52,R0           R52 += CY;
3242: 88,50,80            cmpw  R80,R50          
3245: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3248: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;
324b: 37,86,06            jnb   B7,R86,3254      if (B7_R86 = 1)  {
324e: a0,50,80            ldw   R80,R50          HSO_time = R50;
3251: b0,52,82            ldb   R82,R52          HSO_timeH = R52; }
3254: 11,4c               clrb  R4c              Flags_4C = 0;
3256: 73,92,07,e0         an2b  Re0,[R92+7]      Inj_mode &= [TPtr+7];

  Sub6:
325a: ef,60,f1            call  23bd             Send_HSO_Cmd();                   # send HSO cmd and other stuff
325d: 34,4f,02            jnb   B4,R4f,3262      if (Pending = 1)  {
3260: 2f,28               scall 318a             UPd_Inj_pend(); }
3262: 36,4c,01            jnb   B6,R4c,3266      if (Queued = 1)  {
3265: f0                  ret                    return; }

3266: 28,65               scall 32cd             Sub8();
3268: 67,72,0e,80         ad2w  R80,[R72+e]      HSO_time += Pwoff;
326c: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
326f: 65,0c,00,92         ad2w  R92,c            TPtr += c;

  Sub7:
3273: b3,92,06,54         ldb   R54,[R92+6]      R54 = [TPtr+6];
3277: 73,72,12,54         an2b  R54,[R72+12]     R54 &= Inj_pending;
327b: df,29               je    32a6             if (R54 != 0)  {
327d: 91,10,4f            orb   R4f,10           Pending = 1;
3280: 2f,18               scall 319a             Set_bank_inj();
3282: 73,72,11,54         an2b  R54,[R72+11]     R54 &= Inj_pip;
3286: df,06               je    328e             if (R54 != 0)  {
3288: 68,ba,50            sb2w  R50,Rba          R50 -= PIPHi_ETime;
328b: b8,00,52            sbbb  R52,R0           R52 -= CY; }
328e: 45,2a,00,80,84      ad3w  R84,R80,2a       R84 = HSO_time + 2a;
3293: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3296: b4,00,86            adcb  R86,R0           R86 += CY;
3299: 88,50,84            cmpw  R84,R50          
329c: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;
329f: 3f,86,04            jb    B7,R86,32a6      if (B7_R86 = 0)  {
32a2: 28,29               scall 32cd             Sub8();
32a4: 2e,e4               scall 318a             UPd_Inj_pend(); } }
32a6: ef,14,f1            call  23bd             Send_HSO_Cmd();
32a9: 36,4c,04            jnb   B6,R4c,32b0      if (Queued = 1)  {
32ac: 71,ef,4f            an2b  R4f,ef           Pending = 0;
32af: f0                  ret                    return; }

32b0: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;
32b4: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH;
32b8: 34,4f,0c            jnb   B4,R4f,32c7      if (Pending = 1)  {
32bb: a0,50,80            ldw   R80,R50          HSO_time = R50;
32be: b0,52,82            ldb   R82,R52          HSO_timeH = R52;
32c1: 69,0c,00,92         sb2w  R92,c            TPtr -= c;
32c5: 27,93               sjmp  325a             goto Sub6; }
32c7: 07,7e               incw  R7e              Rtab++;
32c9: c6,7e,00            stb   R0,[R7e]         [Rtab] = 0;
32cc: f0                  ret                    return;

######################################################################
 Fuel addition for trip computer ? unsynced 
#########################################################


  Sub8:
32cd: 01,54               clrw  R54              R54 = 0;
32cf: a3,92,08,56         ldw   R56,[R92+8]      R56 = [TPtr+8];                   # Cyl No ?
32d3: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = Inj_opport;                 # Injector Output Port Table
32d8: 64,56,5a            ad2w  R5a,R56          R5a += R56;
32db: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # load port 0 or 2 for this cyl
32de: b3,92,06,56         ldb   R56,[R92+6]      R56 = [TPtr+6];
32e2: 73,72,10,56         an2b  R56,[R72+10]     R56 &= Inj_base;
32e6: df,18               je    3300             if (R56 != 0)  {
32e8: 97,72,10,56         xorb  R56,[R72+10]     R56 ^= Inj_base;
32ec: c7,72,10,56         stb   R56,[R72+10]     Inj_base = R56;
32f0: 3b,2d,08            jb    B3,R2d,32fb      if (No_fuel_save = 0)  {
32f3: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;
32f7: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH; }           # Save time
32fb: a3,51,06,02,54      ldw   R54,[R50+206]    R54 = [R50+Fuelpw1]; }            # Inj Pulse Width ms, R50 - port 0 or 2
3300: 01,56               clrw  R56              R56 = 0;
3302: 0d,01,54            shldw R54,1            R54 *= 2;
3305: 64,54,80            ad2w  R80,R54          HSO_time += R54;
3308: b4,56,82            adcb  R82,R56          HSO_timeH += R56 + CY;
330b: 65,96,01,50         ad2w  R50,196          R50 += Lbmf_inj1;
330f: a2,50,50            ldw   R50,[R50]        R50 = [R50];
3312: a3,92,08,54         ldw   R54,[R92+8]      R54 = [TPtr+8];
3316: 09,01,54            shlw  R54,1            R54 *= 2;
3319: 65,98,01,54         ad2w  R54,198          R54 += Lbmf_inj2;
331d: c2,54,50            stw   R50,[R54]        [R54] = R50;
3320: 01,52               clrw  R52              R52 = 0;
3322: 67,74,cc,50         ad2w  R50,[R74+cc]     R50 += Fuel_sum_l;
3326: b7,74,ce,52         adcb  R52,[R74+ce]     R52 += Fuel_sum_h + CY;
332a: d5,06               jnv   3332             if (OVF = 1)  {
332c: bd,ff,50            ldsbw R50,ff           R50 = (int)ff;
332f: b1,7f,52            ldb   R52,7f           R52 = 7f; }
3332: c3,74,cc,50         stw   R50,[R74+cc]     Fuel_sum_l = R50;
3336: c7,74,ce,52         stb   R52,[R74+ce]     Fuel_sum_h = R52;
333a: 71,7f,4c            an2b  R4c,7f           No_queue = 0;
333d: f0                  ret                    return;

######################################################################
 Fuel addition for trip computer ? synced 
#########################################################


  Sub9:
333e: 71,7f,48            an2b  R48,7f           Change_fuelpw = 0;
3341: 11,56               clrb  R56              R56 = 0;
3343: a1,9c,22,92         ldw   R92,229c         TPtr = 229c;
3347: b3,fc,32,57         ldb   R57,[Rfc+32]     R57 = Cyl_wrap;                   # 8 - no of cyls
334b: 98,56,57            cmpb  R57,R56          
334e: d9,02               jgtu  3352             if ((uns) R57 > R56 ) goto 3352;
3350: 20,8e               sjmp  33e0             return;
3352: 65,16,00,92         ad2w  R92,16           TPtr += 16;
3356: 17,56               incb  R56              R56++;
3358: 43,92,fe,44,00      an3w  R0,R44,[R92+fe]  R0 = HSOut_Flags & [TPtr-2];
335d: df,ec               je    334b             if (R0 = 0) goto 334b;
335f: 53,92,06,e0,50      an3b  R50,Re0,[R92+6]  R50 = Inj_mode & [TPtr+6];
3364: 98,50,00            cmpb  R0,R50           
3367: d7,1b               jne   3384             if (0 = R50)  {
3369: a3,92,08,54         ldw   R54,[R92+8]      R54 = [TPtr+8];                   # entry for a cyl no?
336d: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = Inj_opport;                 # Injector Output Port Table
3372: 64,54,5a            ad2w  R5a,R54          R5a += R54;                       # pointer to the bank for entry R92 cyl ?
3375: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # bank to fire for this cyl
3378: a0,50,54            ldw   R54,R50          R54 = R50;
337b: 65,06,02,50         ad2w  R50,206          R50 += Fuelpw1;                   # Table? pulse width for port 0 (port 2 Fuelpw2)
337f: a2,50,50            ldw   R50,[R50]        R50 = [R50];
3382: 20,02               sjmp  3386             goto 3386; }
3384: 01,50               clrw  R50              R50 = 0;
3386: 01,52               clrw  R52              R52 = 0;
3388: 0d,01,50            shldw R50,1            R50 *= 2;
338b: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];
338f: 67,72,0e,50         ad2w  R50,[R72+e]      R50 += Pwoff;
3393: b4,00,52            adcb  R52,R0           R52 += CY;
3396: 47,7f,c3,02,50,80   ad3w  R80,R50,[R7e+2c3] HSO_time = R50 + [Rtab+Mphtim2];
339c: b3,7f,c2,02,82      ldb   R82,[R7e+2c2]    HSO_timeH = [Rtab+Mphtim2H];      # schedule event time 
33a1: b4,52,82            adcb  R82,R52          HSO_timeH += R52 + CY;
33a4: a3,92,08,50         ldw   R50,[R92+8]      R50 = [TPtr+8];
33a8: 09,01,50            shlw  R50,1            R50 *= 2;
33ab: 65,98,01,50         ad2w  R50,198          R50 += Lbmf_inj2;
33af: 65,96,01,54         ad2w  R54,196          R54 += Lbmf_inj1;
33b3: a2,54,54            ldw   R54,[R54]        R54 = [R54];
33b6: 11,52               clrb  R52              R52 = 0;
33b8: 4a,50,54,5a         sb3w  R5a,R54,[R50]    R5a = R54 - [R50];
33bc: c2,50,54            stw   R54,[R50]        [R50] = R54;
33bf: b8,00,52            sbbb  R52,R0           R52 -= CY;
33c2: 67,74,cc,5a         ad2w  R5a,[R74+cc]     R5a += Fuel_sum_l;
33c6: b7,74,ce,52         adcb  R52,[R74+ce]     R52 += Fuel_sum_h + CY;
33ca: d5,06               jnv   33d2             if (OVF = 1)  {
33cc: b1,7f,52            ldb   R52,7f           R52 = 7f;
33cf: bd,ff,5a            ldsbw R5a,ff           R5a = (int)ff; }
33d2: c3,74,cc,5a         stw   R5a,[R74+cc]     Fuel_sum_l = R5a;
33d6: c7,74,ce,52         stb   R52,[R74+ce]     Fuel_sum_h = R52;
33da: c9,4b,33            push  334b             push(334b);
33dd: e7,7d,f0            jump  245d             goto Sched_HSO;                   # Add for execution in 2284/2C5 Table
33e0: f0                  ret                    return;

################################################################
# update low speed controls - EGR, MIL/STO output, SCCS, CP, Idle Speed(ISC)
# STATIC JUMP from 25f1 (not called as subr) and jumps back to 25f4, so is really part of
# 'HSO Int1' High speed interrupt handler 
################################################################


  HSO_continued:
33e1: b1,06,04            ldb   R4,6             AD_Cmd = 6;                       # get AD chan 6 (MAF)
33e4: 71,fb,46            an2b  R46,fb           Evr = 0;                          # EGR vac regulator OFF
33e7: 98,00,d3            cmpb  Rd3,R0           
33ea: df,2b               je    3417             if (Rd3 != 0)  {                  # EGR stuff done
33ec: b3,74,a6,52         ldb   R52,[R74+a6]     R52 = Egrprf;
33f0: b3,74,a5,54         ldb   R54,[R74+a5]     R54 = Egrctf;
33f4: 99,10,52            cmpb  R52,10           
33f7: db,08               jc    3401             if (R52 > 10)  {
33f9: 77,74,a4,52         ad2b  R52,[R74+a4]     R52 += Egrper;
33fd: b3,74,a3,54         ldb   R54,[R74+a3]     R54 = Egrcnt; }
3401: 98,00,54            cmpb  R54,R0           
3404: df,06               je    340c             if (R54 != 0)  {
3406: 91,04,46            orb   R46,4            Evr = 1;                          # EGR vacuum regulator ON
3409: 79,08,54            sb2b  R54,8            R54 -= 8; }
340c: 79,10,52            sb2b  R52,10           R52 -= 10;
340f: c7,74,a6,52         stb   R52,[R74+a6]     Egrprf = R52;
3413: c7,74,a5,54         stb   R54,[R74+a5]     Egrctf = R54; }

#### Idle speed control ### 

3417: 71,f7,46            an2b  R46,f7           Isc = 0;                          # ISC OFF (bypass air)
341a: 44,00,b8,50         ad3w  R50,Rb8,R0       R50 = Iscdty;                     # ISC Duty Cycle ?
341e: df,0d               je    342d             if (R50 = 0) goto 342d;
3420: 78,51,b7            sb2b  Rb7,R51          Ifreq -= R51;                     # IFREQ - Iscdty/256
3423: db,0a               jc    342f             if (Ifreq > 0)  {
3425: 75,80,b7            ad2b  Rb7,80           Ifreq += 80;                      # -ve, set to min ?
3428: 91,08,46            orb   R46,8            Isc = 1;                          # ISC ON
342b: 20,02               sjmp  342f             goto 342f;
342d: 11,b7               clrb  Rb7              Ifreq = 0; }                      # No ISC reqd ?

### DOL update ###

342f: 89,01,00,c6         cmpw  Rc6,1            
3433: d1,07               jleu  343c             if ((uns) Dol_count > 1 )  {
3435: 05,c6               decw  Rc6              Dol_count--;
3437: 95,02,46            xorb  R46,2            Dol ^= 1;                         # Toggle DOL state
343a: 20,04               sjmp  3440             goto 3440; }
343c: a1,01,00,c6         ldw   Rc6,1            Dol_count = 1;
3440: 33,d6,6e            jnb   B3,Rd6,34b1      if (Sto_working = 0) goto 34b1;
3443: 30,d8,0b            jnb   B0,Rd8,3451      if (Sto_holdoff = 1)  {
3446: 91,10,d8            orb   Rd8,10           Sto_pending = 1;
3449: 71,7f,08            an2b  R8,7f            INT_Mask &= 7f;                   # block PIP interrupts ?
344c: 71,fe,d8            an2b  Rd8,fe           Sto_holdoff = 0;
344f: 20,dd               sjmp  352e             goto 352e; }                      # jump past STO stuff
3451: 34,d8,15            jnb   B4,Rd8,3469      if (Sto_pending = 0) goto 3469;
3454: 71,ef,d8            an2b  Rd8,ef           Sto_pending = 0;
3457: 91,80,08            orb   R8,80            INT_Mask |= 80;                   # Allow PIP interrupts ?
345a: b3,76,10,56         ldb   R56,[R76+10]     R56 = Sto_shift_cnt;              # STO shift count (leftmost 1 bit at start)
345e: e0,56,43            djnz  R56,34a4         R56--;
                                                 if (R56 != 0) goto 34a4;          # loop if bits left to output
3461: 71,f7,d6            an2b  Rd6,f7           Sto_working = 0;
3464: 3a,2b,4d            jb    B2,R2b,34b4      if (Sto_trigger = 1) goto 34b4;   # Self Test Output trigger set - to turn off STO
3467: 20,be               sjmp  3527             goto 3527;
3469: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # Time difference
346d: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
3470: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                   # Update 24 bit master reference time
3473: b0,8e,54            ldb   R54,R8e          R54 = ReftimeH;                   # Hi 8 bits of current time
3476: b3,76,0f,55         ldb   R55,[R76+f]      R55 = Sto_high_time;
347a: b0,55,56            ldb   R56,R55          R56 = R55;
347d: 48,8c,da,50         sb3w  R50,Rda,R8c      R50 = Sto_time - Reftime;         # current master time - RDA(STO time)
3481: b8,54,56            sbbb  R56,R54          R56 -= R54 - CY;                  # R56 = STO time - current time (hi bytes)
3484: d7,1c               jne   34a2             if (R56 = 0)  {
3486: 89,e3,04,50         cmpw  R50,4e3          
348a: d9,16               jgtu  34a2             if ((uns) R50 <= 4e3)  {          # jump if time remaining till STO > 3 mS

### very close to STO bit time end

348c: 44,50,8c,0e         ad3w  Re,R8c,R50       HSO_Time = Reftime + R50;         # set HSO time
3490: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a;                     # set HSO chan 10 off + interrupt
3493: 67,76,0a,da         ad2w  Rda,[R76+a]      Sto_time += Sto_delay;            # IO time for each trouble code bit at selected output speed
3497: b7,76,0e,55         adcb  R55,[R76+e]      R55 += Sto_high_delay + CY;       # IO time for each trouble code bit at selected output speed
349b: c7,76,0f,55         stb   R55,[R76+f]      Sto_high_time = R55;              # STO high 8 bits time
349f: 91,01,d8            orb   Rd8,1            Sto_holdoff = 1; } }              # set bit 0 of RD8 flag STO HOLDOFF (time to change to next bit? )

#### still shifting out error codes

34a2: 20,8a               sjmp  352e             goto 352e;
34a4: c7,76,10,56         stb   R56,[R76+10]     Sto_shift_cnt = R56;              # bits remaining to be output
34a8: a3,76,0c,52         ldw   R52,[R76+c]      R52 = Sto_shift;                  # STO SHIFT - shifted trouble code
34ac: 08,01,52            shrw  R52,1            R52 /= 2;                         # next output bit? RIGHT SHIFT? SB left shift
34af: 20,70               sjmp  3521             goto 3521;                        # set STO hi/lo based on R52 bit 0

# handle STO/MIL lamp trouble codes output
34b1: 32,2b,7a            jnb   B2,R2b,352e      if (Sto_trigger = 1)  {           # jump over STO if Self Test Output trigger clr
34b4: 3d,d6,11            jb    B5,Rd6,34c8      if (Sto_code = 0)  {              # bit to output is set 

##### OFF bit 

34b7: 01,52               clrw  R52              R52 = 0;                          # R52 = 0 - set STO off
34b9: 37,d6,02            jnb   B7,Rd6,34be      if (Sto_on = 1)  {
34bc: 07,52               incw  R52              R52++; }                          # R52 = 1 - set STO on
34be: 36,d6,02            jnb   B6,Rd6,34c3      if (Sto_off = 1)  {
34c1: 01,52               clrw  R52              R52 = 0; }                        # R52 = 0 - set STO off
34c3: 71,3f,d6            an2b  Rd6,3f           Sto_off = 0;
                                                 Sto_on = 0;                       # clear STO on and OFF flags
34c6: 20,56               sjmp  351e             goto 351e; }                      # jmp to set STO line hi/lo

###### ON bit 

34c8: 71,df,d6            an2b  Rd6,df           Sto_code = 0;                     # clear RD6 bit 5 STO CODE
34cb: 91,08,d6            orb   Rd6,8            Sto_working = 1;                  # set RD6 bit 3 working
34ce: a0,d4,52            ldw   R52,Rd4          R52 = Vip_code;                   # Self Test Trouble code
34d1: b1,10,56            ldb   R56,10           R56 = 10;                         # 16 bit trouble code?
34d4: 31,d9,0d            jnb   B1,Rd9,34e4      if (Goose = 1)  {
34d7: 71,fd,d9            an2b  Rd9,fd           Goose = 0;

##### strip off leading zero bits in trouble code RD4

34da: 09,01,d4            shlw  Rd4,1            Vip_code *= 2;                    # RD4 << 1 next bit of trouble code
34dd: db,03               jc    34e2             if ((uns) Vip_code >= 0) goto 34e2; # leftmost 1 bit just shifted out
34df: e0,56,f8            djnz  R56,34da         R56--;
                                                 if (R56 != 0) goto 34da;          # decr 16 bit count of left most 1 bit
34e2: 17,56               incb  R56              R56++; }                          # 'backup' to leftmost one bit
34e4: c7,76,10,56         stb   R56,[R76+10]     Sto_shift_cnt = R56;              # trouble code bit position (bit position of first != 0 bit)

##### select MIL lamp interval time in R50 and R54

34e8: a1,cd,2d,50         ldw   R50,2dcd         R50 = 2dcd;
34ec: b1,03,54            ldb   R54,3            R54 = 3;                          # STO 'slow', 0x32dcd=0.5 secs
34ef: 34,d6,06            jnb   B4,Rd6,34f8      if (Sto_fast = 1)  {
34f2: a1,23,08,50         ldw   R50,823          R50 = 823;
34f6: 11,54               clrb  R54              R54 = 0; }                        # STO 'fast', 0x823=5 millisecs
34f8: 34,2c,06            jnb   B4,R2c,3501      if (Sto_hyper = 1)  {
34fb: a1,41,03,50         ldw   R50,341          R50 = 341;
34ff: 11,54               clrb  R54              R54 = 0; }                        # STO 'hyper', 0x341=2 millisecs
3501: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # master time diff in R84
3505: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
3508: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;
350b: c3,76,0a,50         stw   R50,[R76+a]      Sto_delay = R50;
350f: c7,76,0e,54         stb   R54,[R76+e]      Sto_high_delay = R54;             # STO timer value 

######### compute time to change STO

3513: 44,50,8c,da         ad3w  Rda,R8c,R50      Sto_time = Reftime + R50;         # time for this next bit (lo 16)
3517: b4,8e,54            adcb  R54,R8e          R54 += ReftimeH + CY;
351a: c7,76,0f,54         stb   R54,[R76+f]      Sto_high_time = R54;              # hi 8 time for this next bit
351e: 71,fb,2b            an2b  R2b,fb           Sto_trigger = 0;                  # allow next bit to queue up
3521: 91,20,46            orb   R46,20           Sto_state = 1;                    # MIL ON
3524: 38,52,03            jb    B0,R52,352a      if (B0_R52 = 0)  {                # trouble code flg
3527: 71,df,46            an2b  R46,df           Sto_state = 0; }                  # MIL OFF
352a: c3,76,0c,52         stw   R52,[R76+c]      Sto_shift = R52; }                # STO bit set for R52 time
352e: 71,df,2f            an2b  R2f,df           Maf_pip = 0;
3531: 3f,a1,0d            jb    B7,Ra1,3541      if (Cranking = 0)  {
3534: 37,09,03            jnb   B7,R9,353a       if (B7_INT_Pend = 0) goto 353a;
3537: 38,0b,07            jb    B0,Rb,3541       if (B0_HSI_Sample = 0)  {
353a: a3,74,06,52         ldw   R52,[R74+6]      R52 = Last_HSO;                   # no PIP interrupt pending?
353e: ef,e8,f7            call  2d29             MAF_rd_calc(); } }

##### Speed control system (SCCS) #####

3541: e0,9b,2b            djnz  R9b,356f         Vsc_count--;
                                                 if (Vsc_count != 0) goto 356f;    # SCCS Count
3544: 33,c4,0c            jnb   B3,Rc4,3553      if (Vsc_state = 1)  {
3547: b3,74,3a,9b         ldb   R9b,[R74+3a]     Vsc_count = Vsc_off_count;
354b: 71,fe,46            an2b  R46,fe           Scvac = 0;                        # Speed Control Vacuum Off
354e: 91,10,46            orb   R46,10           Scvnt = 1;                        # Speed Control Vent On
3551: 20,0f               sjmp  3562             goto 3562; }
3553: b3,74,3b,9b         ldb   R9b,[R74+3b]     Vsc_count = Vsc_on_count;
3557: 36,c4,05            jnb   B6,Rc4,355f      if (Vsc_vac_active = 1)  {        # SCCS vacuum active
355a: 95,01,46            xorb  R46,1            Scvac ^= 1;                       # TOGGLE Speed Control Vacuum
355d: 20,03               sjmp  3562             goto 3562; }
355f: 95,10,46            xorb  R46,10           Scvnt ^= 1;                       # TOGGLE Speed Control Vent
3562: 95,08,c4            xorb  Rc4,8            Vsc_state ^= 1;
3565: 98,9b,00            cmpb  R0,R9b           
3568: d7,05               jne   356f             if (0 = Vsc_count)  {
356a: b1,0a,9b            ldb   R9b,a            Vsc_count = a;
356d: 27,e8               sjmp  3557             goto 3557; } }                    # Loop back

##### canister purge timing (CP) #####

356f: 71,fd,47            an2b  R47,fd           Canp = 0;                         # output line 1 OFF (canister purge)
3572: 5b,72,ab,8d,50      sb3b  R50,R8d,[R72+ab] R50 = R8d - Start_purg_per;       # 12B canister purge start period
3577: 9b,72,ad,50         cmpb  R50,[R72+ad]                                       # 12D canister purge on time
357b: d3,0d               jnc   358a             if ((uns) R50 < Purg_on_time) goto 358a;
357d: 9b,72,ae,50         cmpb  R50,[R72+ae]                                       # 12E canister purge period
3581: d3,0a               jnc   358d             if ((uns) R50 >= Purge_period)  {
3583: c7,72,ab,8d         stb   R8d,[R72+ab]     Start_purg_per = R8d;             # 12B canister purge start period
3587: 36,e9,03            jnb   B6,Re9,358d      if (CanPurgeOK = 1)  {            # canister purge enabled clear
358a: 91,02,47            orb   R47,2            Canp = 1; } }                     # output line 1 ON (canister purge)
358d: e7,64,f0            jump  25f4             goto 25f4;

########################################################
# handle HSI line 2 - BAP sensor
########################################################

  Bap_inth:
3590: 71,fb,87            an2b  R87,fb           Bap_irq = 0;
3593: 4b,74,02,7a,50      sb3w  R50,R7a,[R74+2]  R50 = Event_time - Last_bap;      # time of last read
3598: c3,72,8a,50         stw   R50,[R72+8a]     BAP_Intvl = R50;                  # delta time since last BP read
359c: c3,74,02,7a         stw   R7a,[R74+2]      Last_bap = Event_time;            # update last time read
35a0: b0,b6,50            ldb   R50,Rb6          R50 = Bapcnt;
35a3: 17,50               incb  R50              R50++;
35a5: c4,b6,50            stb   R50,Rb6          Bapcnt = R50;                     # why not just incb directly ?
35a8: 91,40,4e            orb   R4e,40           New_bap = 1;                      # new BP calc reqd ?
35ab: f0                  ret                    return;

########################################################
# Byte function lookup with interpolate 
# handles all 4 combinations of signed and unsigned in/out values
# IN R32 func address
# IN R34 input value
# OUT R38 = func(R34) as byte
########################################################



  subyteLU:
35ac: 91,20,ee            orb   Ree,20           Signdslp = 1;                     # signed input, unsigned output
35af: 20,06               sjmp  35b7             goto UUbyteLu;

  SSByteLU:
35b1: 91,20,ee            orb   Ree,20           Signdslp = 1;                     # signed input, signed output

  USByteLU:
35b4: 91,10,ee            orb   Ree,10           Signdy = 1;                       # unsigned input, signed output

  UUbyteLu:
35b7: 9b,32,02,34         cmpb  R34,[R32+2]                                        # unsigned input, unsigned output
35bb: 3d,ee,04            jb    B5,Ree,35c2      if (Signdslp = 1) goto 35c2;      # Signed input
35be: db,0a               jc    35ca             if (R34 > [R32+2])  {
35c0: 20,02               sjmp  35c4             goto 35c4;
35c2: d6,06               jge   35ca             if (R34 < [R32+2])  {
35c4: 65,02,00,32         ad2w  R32,2            R32 += 2;
35c8: 27,ed               sjmp  35b7             goto UUbyteLu; } }
35ca: 71,df,ee            an2b  Ree,df           Signdslp = 0;                     # Use below for result
35cd: b2,33,36            ldb   R36,[R32++]      R36 = [R32++];                    # Get values above and below i/p val
35d0: b2,33,38            ldb   R38,[R32++]      R38 = [R32++];
35d3: 7a,32,36            sb2b  R36,[R32]        R36 -= [R32];
35d6: 7a,33,34            sb2b  R34,[R32++]      R34 -= [R32++];
35d9: 7a,32,38            sb2b  R38,[R32]        R38 -= [R32];
35dc: 3c,ee,04            jb    B4,Ree,35e3      if (Signdy = 1) goto 35e3;
35df: db,09               jc    35ea             if (R38 > 0)  {
35e1: 20,02               sjmp  35e5             goto 35e5;
35e3: d6,05               jge   35ea             if (R38 < 0)  {                   # Negative - remember
35e5: 91,20,ee            orb   Ree,20           Signdslp = 1;
35e8: 13,38               negb  R38              R38 = -R38; } }
35ea: 7c,34,38            ml2b  R38,R34          R38 *= R34;
35ed: 9c,36,38            divb  R38,R36          R38 /= R36;
35f0: 35,ee,02            jnb   B5,Ree,35f5      if (Signdslp = 1)  {              # Negative, fix sign
35f3: 13,38               negb  R38              R38 = -R38; }
35f5: 76,32,38            ad2b  R38,[R32]        R38 += [R32];                     # add interpolated delta
35f8: 11,39               clrb  R39              R39 = 0;
35fa: 71,df,ee            an2b  Ree,df           Signdslp = 0;
35fd: 71,ef,ee            an2b  Ree,ef           Signdy = 0;                       # cleanup
3600: f0                  ret                    return;

#############################################################
# Word function lookup - as byte logic (but word instructions)
# IN R32 func address
# IN R34 input value
# OUT R38 = func(R34) as word
#############################################################


  SUWordLU:
3601: 91,20,ee            orb   Ree,20           Signdslp = 1;
3604: 20,06               sjmp  360c             goto UUWordLu;

  SSWordLU:
3606: 91,20,ee            orb   Ree,20           Signdslp = 1;
3609: 91,10,ee            orb   Ree,10           Signdy = 1;

  UUWordLu:
360c: 8b,32,04,34         cmpw  R34,[R32+4]      
3610: 3d,ee,04            jb    B5,Ree,3617      if (Signdslp = 1) goto 3617;
3613: db,0a               jc    361f             if (R34 > [R32+4])  {
3615: 20,02               sjmp  3619             goto 3619;
3617: d6,06               jge   361f             if (R34 < [R32+4])  {
3619: 65,04,00,32         ad2w  R32,4            R32 += 4;
361d: 27,ed               sjmp  360c             goto UUWordLu; } }
361f: 71,df,ee            an2b  Ree,df           Signdslp = 0;
3622: a2,33,36            ldw   R36,[R32++]      R36 = [R32++];
3625: a2,33,38            ldw   R38,[R32++]      R38 = [R32++];
3628: 6a,32,36            sb2w  R36,[R32]        R36 -= [R32];
362b: 6a,33,34            sb2w  R34,[R32++]      R34 -= [R32++];
362e: 6a,32,38            sb2w  R38,[R32]        R38 -= [R32];
3631: 3c,ee,04            jb    B4,Ree,3638      if (Signdy = 1) goto 3638;
3634: db,09               jc    363f             if (R38 > 0)  {
3636: 20,02               sjmp  363a             goto 363a;
3638: d6,05               jge   363f             if (R38 < 0)  {
363a: 91,20,ee            orb   Ree,20           Signdslp = 1;
363d: 03,38               negw  R38              R38 = -R38; } }
363f: 6c,34,38            ml2w  R38,R34          R38 *= R34;
3642: 8c,36,38            divw  R38,R36          R38 /= R36;
3645: 35,ee,02            jnb   B5,Ree,364a      if (Signdslp = 1)  {
3648: 03,38               negw  R38              R38 = -R38; }
364a: 66,32,38            ad2w  R38,[R32]        R38 += [R32];
364d: 71,df,ee            an2b  Ree,df           Signdslp = 0;
3650: 71,ef,ee            an2b  Ree,ef           Signdy = 0;
3653: f0                  ret                    return;

#############################################################
# Filter (rolling average) routine - signed and unsigned options
# 3654 loads 3 params into R32, 34, 36
# 365e loads 1 param  into R36
# 3663 loads 0 params
# inputs R32 old, R34 New, R36 filter factor (rate)
# output in R3e
#############################################################


  Srolav3T:
3654: 28,3f               scall 3695             Get_par();
3656: a2,3c,32            ldw   R32,[R3c]        R32 = [R3c];                      # OLD sensor value
3659: 28,3a               scall 3695             Get_par();
365b: a2,3c,34            ldw   R34,[R3c]        R34 = [R3c];                      # NEW sensor value

  Srolav1T:
365e: 28,35               scall 3695             Get_par();
3660: a2,3c,36            ldw   R36,[R3c]        R36 = [R3c];                      # filter value

  Urolav:
3663: 28,53               scall 36b8             Calc_FFact();                     # R36 = R3E * 65536 / (R36 + R3E)

  Srolav:
3665: b1,02,42            ldb   R42,2            R42 = 2;                          # flag as signed
3668: 20,04               sjmp  366e             goto 366e;

  FilterX:
366a: 28,4c               scall 36b8             Calc_FFact();                     # R36 = R3E * 65536 / (R36 + R3E)
366c: 11,42               clrb  R42              R42 = 0;                          # flag as unsigned
366e: 48,32,34,3c         sb3w  R3c,R34,R32      R3c = R34 - R32;                  # difference (new -old)
3672: 31,42,04            jnb   B1,R42,3679      if (B1_R42 = 0) goto 3679;        # jump if signed 
3675: db,08               jc    367f             if (R3c > 0)  {                   # effectively +ve result (unsigned)
3677: 20,02               sjmp  367b             goto 367b;                        # effectively -ve result (unsigned)
3679: d6,04               jge   367f             if (R3c < 0)  {                   # jmp if difference is NOT negative
367b: 17,42               incb  R42              R42++;                            # set bit 0 - neg result flag ?
367d: 03,3c               negw  R3c              R3c = -R3c; } }                   # reverse diff, so ABS (diff)
367f: 6c,36,3c            ml2w  R3c,R36          R3c *= R36;                       # ABS(diff ) * R36(filter factor)
3682: 03,3e               negw  R3e              R3e = -R3e;                       # neg scaled diff Hi 16 bits
3684: d7,06               jne   368c             if (R3e != 0) goto 368c;          # jmp if scaled diff > 0000FFFF
3686: 03,3c               negw  R3c              R3c = -R3c;                       # neg scaled diff LO 16 bits
3688: df,07               je    3691             if (R3c != 0)  {                  # jmp - scaled diff is ZERO
368a: 05,3e               decw  R3e              R3e--;                            # any fraction to next whole num
368c: 38,42,02            jb    B0,R42,3691      if (B0_R42 = 0)  {                # negative flag
368f: 03,3e               negw  R3e              R3e = -R3e; } }
3691: 64,32,3e            ad2w  R3e,R32          R3e += R32;                       # add filtered diff to old AD value (in R3E)
3694: f0                  ret                    return;

#############################################################
# Get a caller's WORD param and increment return address
# can be called more than once (see above)
# If positive, returned as is.
# If top bit set, map to ROM.  All calls in this bin are D0nn
# which maps to [f8] + nn as word address to look up 
# Range used is D040 (at 5400) to D060 (at 410c) which gives actual 
# ROM addresses of 97E8-9808
# return R3c with lookup ADDRESS 
#############################################################


  Get_par:
3695: cc,38               pop   R38              R38 = pop();                      # This subroutine's return addr
3697: cc,3a               pop   R3a              R3a = pop();                      # Caller subroutine's return addr
3699: b2,3b,3c            ldb   R3c,[R3a++]      R3c = [R3a++];
369c: b2,3b,3d            ldb   R3d,[R3a++]      R3d = [R3a++];                    # 3C = Word param from caller
369f: c8,3a               push  R3a              push(R3a);                        # restore caller address (+2)
36a1: c8,38               push  R38              push(R38);                        # restore this return address
36a3: 37,3d,11            jnb   B7,R3d,36b7      if (B7_R3d = 0) return;           # return unchanged if top bit clear
36a6: ac,3d,38            ldzbw R38,R3d          R38 = (uns)R3d;                   # = f0 register offset (R3c top byte)
36a9: 71,0f,3d            an2b  R3d,f            R3d &= f;                         # clear reg offset (top nibble) 
36ac: 18,03,38            shrb  R38,3            R38 /= 8;                         # top nibble down 3 (reg offset * 2) 
36af: 71,fe,38            an2b  R38,fe           R38 &= fe;                        # force even for register offset
36b2: 67,39,e0,00,3c      ad2w  R3c,[R38+e0]     R3c += [R38+e0]; }                # return  (param & fff)+[e0+x*2]
36b7: f0                  ret                    return;

##############################################################
# Rolling Average/smoothing Filter calc
# R36 = Timer * 65536 / (R36 + Timer)
# Aspinput flag uses preset value for timer which is
# used only for AM (airflow) filtering,
#  otherwise uses background timer as base param 
# outputs:
## routine scale filtering difference by factor
#############################################################


  Calc_FFact:
36b8: 38,ca,04            jb    B0,Rca,36bf      if (Asp_input = 0)  {
36bb: af,74,5e,3e         ldzbw R3e,[R74+5e]     R3e = (uns)Bg_timer; }            # Background Loop Timer
36bf: 71,fe,ca            an2b  Rca,fe           Asp_input = 0;
36c2: 01,3c               clrw  R3c              R3c = 0;
36c4: 64,3e,36            ad2w  R36,R3e          R36 += R3e;                       # divisor + timer
36c7: d3,03               jnc   36cc             if ((uns) R36 >= 0)  {
36c9: bd,ff,36            ldsbw R36,ff           R36 = (int)ff; }                  # clip to max FF
36cc: 8c,36,3c            divw  R3c,R36          R3c /= R36;
36cf: d5,03               jnv   36d4             if (OVF = 1)  {
36d1: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; }                  # clip to max on overflow?
36d4: a0,3c,36            ldw   R36,R3c          R36 = R3c;
36d7: f0                  ret                    return;

#############################################################
# Table lookup with 3 way interpolate (2 vars X and Y) Signed and unsigned
# R30 = X value. (column)   'whole' in top byte (R31), fraction in lower (R30)
# R32 = Y value  (row       'whole' in top byte (R33), fraction in lower (R32)
# R34 is Table width (no of columns)
# R38 is the Table pointer
# result in R3B
#############################################################



36d8: 91,80,2d            ??                                                       # Signed scaled Table (not used)


  UTabLu16:
36db: 11,31               clrb  R31              R31 = 0;                          # scale up by 16
36dd: 09,04,30            shlw  R30,4            R30 *= 10;                        # Byte param A * 16
36e0: 11,33               clrb  R33              R33 = 0;
36e2: 09,04,32            shlw  R32,4            R32 *= 10;                        # Byte param B * 16
36e5: 20,03               sjmp  36ea             goto UTabLookUp;

  STabLookup:
36e7: 91,80,2d            orb   R2d,80           Tblsflg = 1;                      # Signed Table

  UTabLookUp:
36ea: 5c,33,34,36         ml3b  R36,R34,R33      R36 = R34 * R33;                  # Unsigned Table
36ee: 74,31,36            ad2b  R36,R31          R36 += R31;
36f1: d3,02               jnc   36f5             if ((uns) R36 >= 0)  {
36f3: 17,37               incb  R37              R37++; }
36f5: 64,36,38            ad2w  R38,R36          R38 += R36;
36f8: b2,39,31            ldb   R31,[R38++]      R31 = [R38++];
36fb: b2,38,33            ldb   R33,[R38]        R33 = [R38];
36fe: 28,1f               scall 371f             TabInterp();
3700: 64,34,38            ad2w  R38,R34          R38 += R34;
3703: b2,38,33            ldb   R33,[R38]        R33 = [R38];
3706: 05,38               decw  R38              R38--;
3708: b2,38,31            ldb   R31,[R38]        R31 = [R38];
370b: b0,3b,34            ldb   R34,R3b          R34 = R3b;
370e: 28,0f               scall 371f             TabInterp();
3710: b0,3b,33            ldb   R33,R3b          R33 = R3b;
3713: b0,34,31            ldb   R31,R34          R31 = R34;
3716: b0,32,30            ldb   R30,R32          R30 = R32;
3719: 28,04               scall 371f             TabInterp();
371b: 71,7f,2d            an2b  R2d,7f           Tblsflg = 0;
371e: f0                  ret                    return;

#############################################################
# single dimension interpolate - signed or unsigned
#############################################################


  TabInterp:
371f: 37,2d,1a            jnb   B7,R2d,373c      if (Tblsflg = 0) goto 373c;
3722: bc,33,3a            ldsbw R3a,R33          R3a = (int)R33;                   # SIGNED interpolate calc
3725: bc,31,3c            ldsbw R3c,R31          R3c = (int)R31;
3728: 68,3c,3a            sb2w  R3a,R3c          R3a -= R3c;
372b: ac,30,3c            ldzbw R3c,R30          R3c = (uns)R30;
372e: fe,6c,3a,3c         sml2w R3c,R3a          R3c *= R3a;
3732: c0,3a,3c            stw   R3c,R3a          R3a = R3c;
3735: 74,31,3b            ad2b  R3b,R31          R3b += R31;
3738: 37,3b,0f            jnb   B7,R3b,374a      if (B7_R3b = 1)  {
373b: f0                  ret                    return;

373c: 5c,33,30,3a         ml3b  R3a,R30,R33      R3a = R30 * R33;                  # UNSIGNED interpolate calc
3740: 5c,31,30,36         ml3b  R36,R30,R31      R36 = R30 * R31;
3744: 68,36,3a            sb2w  R3a,R36          R3a -= R36;
3747: 74,31,3b            ad2b  R3b,R31          R3b += R31; }
374a: 65,80,00,3a         ad2w  R3a,80           R3a += 80;
374e: f0                  ret                    return;

#############################################################
# Timer checks against list address supplied in R30.
# Result is carry set/clr.  Looks like (timed) enabler check for several functions
# Closed loop, EVP, CANP etc
#############################################################


  Check_Timers:
374f: 9b,fe,04,ad         cmpb  Rad,[Rfe+4]      
3753: de,07               jlt   375c             if (Tcstrt < CThigh) goto 375c;
3755: 9a,30,c8            cmpb  Rc8,[R30]        
3758: d3,2a               jnc   3784             if ((uns) Atmr1 >= [R30])  {
375a: 20,26               sjmp  3782             goto 3782;
375c: 07,30               incw  R30              R30++;
375e: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]      
3762: da,0e               jle   3772             if (Tcstrt <= CtLow) goto 3772;
3764: 9a,30,c8            cmpb  Rc8,[R30]        
3767: d3,1b               jnc   3784             if ((uns) Atmr1 >= [R30])  {
3769: 07,30               incw  R30              R30++;
376b: 9a,30,c9            cmpb  Rc9,[R30]        
376e: d3,14               jnc   3784             if ((uns) Atmr2 >= [R30])  {
3770: 20,10               sjmp  3782             goto 3782;
3772: 07,30               incw  R30              R30++;
3774: 07,30               incw  R30              R30++;
3776: 9a,30,c8            cmpb  Rc8,[R30]        
3779: d3,09               jnc   3784             if ((uns) Atmr1 >= [R30])  {
377b: 07,30               incw  R30              R30++;
377d: 9a,30,c9            cmpb  Rc9,[R30]        
3780: d3,02               jnc   3784             if ((uns) Atmr2 >= [R30])  {
3782: f8                  clc                    CY = 0
3783: f0                  ret                    return; } } } } }

3784: f9                  stc                    CY = 1
3785: f0                  ret                    return;

#################################################################
# Set RPM Flags mode - cranking, underspeed. run etc
#################################################################


  set_rpm_flgs:
3786: 71,ef,e9            an2b  Re9,ef           Crnk_trans = 0;
3789: 37,a1,21            jnb   B7,Ra1,37ad      if (Cranking = 0) goto 37ad;
378c: 8b,fa,1a,ae         cmpw  Rae,[Rfa+1a]     
3790: d1,14               jleu  37a6             if ((uns) Rpmx4 > 225_RPM )  {    # (225 RPM) 
3792: b1,08,14            ldb   R14,8            R14 = 8;
3795: 9b,74,e7,14         cmpb  R14,[R74+e7]     
3799: d9,09               jgtu  37a4             if ((uns) R14 <= Ectcnt)  {       # ECTCNT <=8 ?
379b: 9b,fa,14,b4         cmpb  Rb4,[Rfa+14]     
379f: d3,03               jnc   37a4             if ((uns) Pipcnt >= [97bc])  {
37a1: 71,7f,a1            an2b  Ra1,7f           Cranking = 0; } }                 # RPM>225, ECTCNT<=8, PIPCNT>8, clear CRANKING
37a4: 20,40               sjmp  37e6             goto 37e6; }
37a6: 11,b4               clrb  Rb4              Pipcnt = 0;                       # RPM > 255
37a8: 71,ef,2f            an2b  R2f,ef           Ptscr = 0;
37ab: 20,39               sjmp  37e6             goto 37e6;                        # set underspeed and exit
37ad: 11,b4               clrb  Rb4              Pipcnt = 0;                       # cranking flag not set
37af: 8b,fa,1c,ae         cmpw  Rae,[Rfa+1c]     
37b3: db,11               jc    37c6             if (Rpmx4 > [97c4])  {
37b5: 91,80,a1            orb   Ra1,80           Cranking = 1;                     # RPM < 50
37b8: 91,10,e9            orb   Re9,10           Crnk_trans = 1;
37bb: c7,74,e7,00         stb   R0,[R74+e7]      Ectcnt = 0;
37bf: 01,ac               clrw  Rac              Tcstrl = 0;
37c1: 71,ef,2f            an2b  R2f,ef           Ptscr = 0;                        # set cranking and other flags
37c4: 20,20               sjmp  37e6             goto 37e6; }
37c6: a3,fa,16,30         ldw   R30,[Rfa+16]     R30 = 200rpm;                     # cranking not set, RPM >= 50
37ca: 88,ae,30            cmpw  R30,Rae          
37cd: d1,02               jleu  37d1             if ((uns) R30 <= Rpmx4) goto 37d1;
37cf: 20,15               sjmp  37e6             goto 37e6;                        # RPM < 200, Underspeed limit low, set underspeed
37d1: 67,fa,18,30         ad2w  R30,[Rfa+18]     R30 += [97c0];                    # R30 = 300RPM
37d5: 88,ae,30            cmpw  R30,Rae          
37d8: db,0a               jc    37e4             if (R30 > Rpmx4)  {               # RPM < 300, Underspeed limit high, exit
37da: fa                  di                     disable ints;
37db: ff                  nop                    
37dc: 32,a1,05            jnb   B2,Ra1,37e4      if (Undsp = 1)  {
37df: 71,fb,a1            an2b  Ra1,fb           Undsp = 0;                        # RPM > 300 clear underspeed if set 
37e2: 20,0a               sjmp  37ee             goto 37ee; } }
37e4: fb                  ei                     enable ints;
37e5: f0                  ret                    return;

37e6: fa                  di                     disable ints;
37e7: ff                  nop                    
37e8: 3a,a1,06            jb    B2,Ra1,37f1      if (Undsp = 0)  {
37eb: 91,04,a1            orb   Ra1,4            Undsp = 1;                        # set underspeed if necessary
37ee: 91,02,2d            orb   R2d,2            Undsp_trans = 1; }                # Underspeed transition
37f1: fb                  ei                     enable ints;
37f2: f0                  ret                    return;

#################################################################
# Update Throttle flags (RAA is Throttle position)
#################################################################


  Update_WOT:
37f3: 71,7f,e9            an2b  Re9,7f           Ctptfg = 0;
37f6: a3,72,a6,36         ldw   R36,[R72+a6]     R36 = TPS_Min;
37fa: 47,fa,02,36,38      ad3w  R38,R36,[Rfa+2]  R38 = R36 + Tp_Delta;             # Min+delta
37ff: db,3a               jc    383b             if ((uns) R38 >= 0) goto 383b;    # Min>=delta, clr WOT
3801: 88,38,aa            cmpw  Raa,R38          
3804: d1,35               jleu  383b             if ((uns) TP <= R38) goto 383b;   # TP <= max,  clr WOT
3806: 67,fa,06,38         ad2w  R38,[Rfa+6]      R38 += TP_Hysts;                  # hysterysis?
380a: db,05               jc    3811             if ((uns) R38 >= 0) goto 3811;
380c: 88,38,aa            cmpw  Raa,R38          
380f: d9,03               jgtu  3814             if ((uns) TP > R38 ) goto 3814;   # TP > RATCH + DELTA + HYSTS
3811: 3f,d0,39            jb    B7,Rd0,384d      if (Cl_thrtl = 1) return;         # Closed Throttle ?
3814: 37,d0,03            jnb   B7,Rd0,381a      if (Cl_thrtl = 1)  {
3817: 91,80,e9            orb   Re9,80           Ctptfg = 1; }
381a: 67,fa,08,36         ad2w  R36,[Rfa+8]      R36 += Wotbrkv;                   # WOT breakpoint (TPS voltage - 1)
381e: db,22               jc    3842             if (R36 > 0)  {
3820: 88,36,aa            cmpw  Raa,R36          
3823: d1,1d               jleu  3842             if ((uns) TP > R36 )  {
3825: 67,fa,04,36         ad2w  R36,[Rfa+4]      R36 += Tp_Hysts2;
3829: db,05               jc    3830             if ((uns) R36 >= 0) goto 3830;
382b: 88,36,aa            cmpw  Raa,R36          
382e: d9,04               jgtu  3834             if ((uns) TP > R36 ) goto 3834;   # set WOT
3830: 3f,d0,0f            jb    B7,Rd0,3842      if (Cl_thrtl = 0)  {
3833: f0                  ret                    return;

3834: b1,01,d0            ldb   Rd0,1            Apt = 1;
3837: 91,01,24            orb   R24,1            Wot = 1;
383a: f0                  ret                    return;

383b: b1,ff,d0            ldb   Rd0,ff           Apt = ff;
383e: 71,fe,24            an2b  R24,fe           Wot = 0;
3841: f0                  ret                    return; } } }

3842: 3f,a1,03            jb    B7,Ra1,3848      if (Cranking = 0)  {
3845: 91,10,2f            orb   R2f,10           Ptscr = 1; }
3848: 11,d0               clrb  Rd0              Apt = 0;
384a: 71,fe,24            an2b  R24,fe           Wot = 0; }
384d: f0                  ret                    return;

#################################################################
# Read Analog to Digital channels new state
#################################################################


  Update_AD:
384e: 36,e6,19            jnb   B6,Re6,386a      if (Pfehp_flg = 0) goto 386a;
3851: 36,c5,05            jnb   B6,Rc5,3859      if (Efmflag = 1)  {
3854: 91,04,c5            orb   Rc5,4            Pefmfag = 1;
3857: 20,30               sjmp  3889             goto 3889; }                      # jmp to ACT test

#### update EVP
3859: 32,c5,2d            jnb   B2,Rc5,3889      if (Pefmfag = 1)  {               # skip EVP update
385c: a1,80,a2,30         ldw   R30,a280         R30 = a280;                       # default EVP
3860: c3,01,ee,07,30      stw   R30,[R0+7ee]     KEptzer = R30;                    # filtered EVP saved in KAM
3865: 71,fb,c5            an2b  Rc5,fb           Pefmfag = 0;
3868: 20,1f               sjmp  3889             goto 3889;                        # go to ACT test
386a: 3e,c5,14            jb    B6,Rc5,3881      if (Efmflag = 1) goto 3881;       # use 128 as ACT
386d: a3,72,96,30         ldw   R30,[R72+96]     R30 = EVP_Raw;                    # raw EVP 116
3871: 8b,f3,b2,00,30      cmpw  R30,[Rf2+b2]     
3876: d9,11               jgtu  3889             if ((uns) R30 <= Evpmax)  {
3878: 8b,f3,b0,00,30      cmpw  R30,[Rf2+b0]     
387d: db,06               jc    3885             if ((uns) R30 >= Evpmin) goto 3885; # OK, use as new value
387f: 20,08               sjmp  3889             goto 3889;                        # go to ACT test
3881: a3,72,a8,30         ldw   R30,[R72+a8]     R30 = EVP_Def;                    # Default EVP ? 128
3885: c3,72,f0,30         stw   R30,[R72+f0]     Evp = R30; } }

#### update ACT
3889: 3d,c5,1d            jb    B5,Rc5,38a9      if (Afmflag = 0)  {               # skip ACT test
388c: a3,72,94,30         ldw   R30,[R72+94]     R30 = ACT_Raw;
3890: 8b,f2,6a,30         cmpw  R30,[Rf2+6a]     
3894: d9,13               jgtu  38a9             if ((uns) R30 <= Actmax)  {
3896: 8b,f2,68,30         cmpw  R30,[Rf2+68]     
389a: d3,0d               jnc   38a9             if ((uns) R30 >= Actmin)  {
389c: 45,b0,01,f0,32      ad3w  R32,Rf0,1b0      R32 = Fn703A;                     # AD to degrees F
38a1: b3,72,95,34         ldb   R34,[R72+95]     R34 = [115];                      # input for ACT calc (addr= 115)
38a5: 2d,0d               scall 35b4             USByteLU();
38a7: 20,0f               sjmp  38b8             goto 38b8; } } }                  # R38 is our new ACT

#### ACT sensor is BAD
38a9: 39,ef,05            jb    B1,Ref,38b1      if (Wmegol = 0)  {                # do NOT use ECT as new ACT ?
38ac: b0,b0,38            ldb   R38,Rb0          R38 = ECT;
38af: 20,07               sjmp  38b8             goto 38b8; }                      # use ECT as ACT
38b1: 35,c5,07            jnb   B5,Rc5,38bb      if (Afmflag = 1)  {               # do NOT set ACT from ROM ?
38b4: b3,f6,7f,38         ldb   R38,[Rf6+7f]     R38 = [9427];                     # Default ACT ?
38b8: b0,38,b1            ldb   Rb1,R38          ACT = R38; }

##### update ACT
38bb: 3f,c5,1e            jb    B7,Rc5,38dc      if (Cfmflag = 0)  {
38be: a3,72,92,30         ldw   R30,[R72+92]     R30 = ECT_Raw;
38c2: 8b,f3,80,00,30      cmpw  R30,[Rf2+80]     
38c7: d9,13               jgtu  38dc             if ((uns) R30 <= Ectmax)  {
38c9: 8b,f2,7e,30         cmpw  R30,[Rf2+7e]     
38cd: d3,0d               jnc   38dc             if ((uns) R30 >= Ectmin)  {       # BAD sensor
38cf: 45,b0,01,f0,32      ad3w  R32,Rf0,1b0      R32 = Fn703A;                     # AD to degrees F
38d4: b3,72,93,34         ldb   R34,[R72+93]     R34 = [113];                      # Input for ECT calc  (addr=113)
38d8: 2c,da               scall 35b4             USByteLU();
38da: 20,22               sjmp  38fe             goto 38fe; } } }

###### invalid ECT sensor reading
38dc: b0,b1,38            ldb   R38,Rb1          R38 = ACT;                        # use ACT for ECT ?
38df: 3f,a1,1c            jb    B7,Ra1,38fe      if (Cranking = 1) goto 38fe;
38e2: 9b,fe,04,ad         cmpb  Rad,[Rfe+4]      
38e6: de,08               jlt   38f0             if (Tcstrt < CThigh) goto 38f0;
38e8: 9b,fc,0e,c8         cmpb  Rc8,[Rfc+e]      
38ec: d3,10               jnc   38fe             if ((uns) Atmr1 < [9a8c]) goto 38fe;
38ee: 20,06               sjmp  38f6             goto 38f6;
38f0: 9b,fc,0f,c8         cmpb  Rc8,[Rfc+f]      
38f4: d3,08               jnc   38fe             if ((uns) Atmr1 < [9a8d]) goto 38fe;
38f6: 37,c5,17            jnb   B7,Rc5,3910      if (Cfmflag = 1)  {
38f9: b3,f7,80,00,38      ldb   R38,[Rf6+80]     R38 = [9428];                     # Default ECT value from ROM ? (75 deg ?)
38fe: bc,b0,32            ldsbw R32,Rb0          R32 = (int)ECT;                   # previous Engine Coolant Temp - degrees F ?
3901: bc,38,34            ldsbw R34,R38          R34 = (int)R38;                   # new ECT value to filter and save
3904: 09,08,38            shlw  R38,8            R38 *= 100;                       # R38 = R38 * 256
3907: a3,fa,44,36         ldw   R36,[Rfa+44]     R36 = [97ec];                     # filter factor
390b: 2d,5d               scall 366a             FilterX();                        # FILTER (factor times difference added back)
390d: b0,3e,b0            ldb   Rb0,R3e          ECT = R3e; }                      # Filterd Engine Coolant Temperature
3910: a3,72,b4,14         ldw   R14,[R72+b4]     R14 = Putmr;                      # Counts up after h/w reset
3914: 8b,f8,52,14         cmpw  R14,[Rf8+52]                                       # TKYON2 - compare whole seconds
3918: d1,15               jleu  392f             if ((uns) R14 > [9482] )  {       # jump timer <= ROM time
391a: b3,74,e7,14         ldb   R14,[R74+e7]     R14 = Ectcnt;
391e: 99,08,14            cmpb  R14,8            
3921: db,0c               jc    392f             if (R14 > 8)  {                   # jmp time <= 8 secs?
3923: 0a,03,38            asrw  R38,3            R38 /= 8;                         # div by 8
3926: 64,38,ac            ad2w  Rac,R38          Tcstrl += R38;
3929: 17,14               incb  R14              R14++;                            # incr putimer
392b: c7,74,e7,14         stb   R14,[R74+e7]     Ectcnt = R14; } }

#### update TP

392f: 3c,c5,10            jb    B4,Rc5,3942      if (Tfmflag = 1) goto 3942;       # TP sensor has failed ?
3932: a3,72,a2,30         ldw   R30,[R72+a2]     R30 = TPS_Raw;
3936: 8b,f2,70,30         cmpw  R30,[Rf2+70]     
393a: d3,06               jnc   3942             if ((uns) R30 < Tapmin) goto 3942;
393c: 8b,f2,6e,30         cmpw  R30,[Rf2+6e]     

#### TP is out of range

3940: d1,23               jleu  3965             if ((uns) R30 <= Tapmax) goto 3965;
3942: a3,72,a6,30         ldw   R30,[R72+a6]     R30 = TPS_Min;
3946: 3f,a1,1c            jb    B7,Ra1,3965      if (Cranking = 1) goto 3965;
3949: 8b,f7,84,00,a2      cmpw  Ra2,[Rf6+84]     
394e: d3,15               jnc   3965             if ((uns) AM < [942c]) goto 3965; # range error
3950: 34,c5,15            jnb   B4,Rc5,3968      if (Tfmflag = 1)  {               # TP sensor has failed ?
3953: a3,f0,02,30         ldw   R30,[Rf0+2]      R30 = [8c02];
3957: c3,72,a6,30         stw   R30,[R72+a6]     TPS_Min = R30;
395b: 67,f7,82,00,30      ad2w  R30,[Rf6+82]     R30 += [942a];                    # Change in TP if not at idle (as indicated by AM) To permit Part Throttle operation
3960: d3,03               jnc   3965             if ((uns) R30 >= 0)  {
3962: bd,c0,30            ldsbw R30,c0           R30 = (int)c0; }                  # default value
3965: a0,30,aa            ldw   Raa,R30          TP = R30; }

################# update TAR - Throttle position sensor rate

3968: a1,ae,a3,38         ldw   R38,a3ae         R38 = a3ae;                       # min rate?
396c: 6b,72,a0,38         sb2w  R38,[R72+a0]     R38 -= TAR_Raw;                   # read raw TAR sensor 120
3970: db,02               jc    3974             if (R38 > 0)  {
3972: 01,38               clrw  R38              R38 = 0; }                        # clamp to zero
3974: 6d,ae,bc,38         ml2w  R38,bcae         R38 *= bcae;
3978: 0d,01,38            shldw R38,1            R38 *= 2;
397b: 65,80,00,3a         ad2w  R3a,80           R3a += 80;                        # round up
397f: c7,74,20,3b         stb   R3b,[R74+20]     Tar = R3b;                        # TAR scaled and translated? 29E

############################## update BP
3983: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
3987: d7,0a               jne   3993             if (0 = [947b])  {
3989: b3,f8,4c,14         ldb   R14,[Rf8+4c]     R14 = [947c];
398d: c7,74,80,14         stb   R14,[R74+80]     Bp = R14;
3991: 20,94               sjmp  3a27             goto 3a27; }
3993: 31,c5,09            jnb   B1,Rc5,399f      if (Bfmflag = 0) goto 399f;
3996: b3,f7,86,00,35      ldb   R35,[Rf6+86]     R35 = [942e];
399b: 20,6c               sjmp  3a09             goto 3a09;                        # filter R35 as new TP


399d: 20,66               ??                                                       # Never gets here?

399f: b3,72,b6,3a         ldb   R3a,[R72+b6]     R3a = Baptmr;                     # time of last BP pulse ?
39a3: 9b,f3,16,01,3a      cmpb  R3a,[Rf2+116]    
39a8: d9,77               jgtu  3a21             if ((uns) R3a <= Vbpmax)  {
39aa: a3,72,8a,1c         ldw   R1c,[R72+8a]     R1c = BAP_Intvl;
39ae: 8b,f3,02,01,1c      cmpw  R1c,[Rf2+102]                                      # Faulty BAP?
39b3: d3,6c               jnc   3a21             if ((uns) R1c >= Vbpdl1)  {
39b5: 3f,a1,03            jb    B7,Ra1,39bb      if (Cranking = 1) goto 39bb;
39b8: 32,4e,4a            jnb   B2,R4e,3a05      if (New_Bpv = 1)  {
39bb: fa                  di                     disable ints;
39bc: ff                  nop                    
39bd: ac,b6,1e            ldzbw R1e,Rb6          R1e = (uns)Bapcnt;                # BP counts
39c0: a3,74,02,16         ldw   R16,[R74+2]      R16 = Last_bap;                   # time of last BP read
39c4: 11,b6               clrb  Rb6              Bapcnt = 0;                       # reset count to zero
39c6: 30,1e,07            jnb   B0,R1e,39d0      if (B0_R1e = 1)  {                # disallow odd BP counts
39c9: 15,1e               decb  R1e              R1e--;
39cb: 17,b6               incb  Rb6              Bapcnt++;
39cd: 68,1c,16            sb2w  R16,R1c          R16 -= R1c; }
39d0: fb                  ei                     enable ints;
39d1: 98,1e,00            cmpb  R0,R1e                                             # BP count == zero?
39d4: d6,2f               jge   3a05             if (0 < R1e)  {
39d6: 4b,72,bc,16,18      sb3w  R18,R16,[R72+bc] R18 = R16 - Mintim2;              # 13C - time of last BP read - R18 is delta time?
39db: 01,1a               clrw  R1a              R1a = 0;
39dd: 0d,01,18            shldw R18,1            R18 *= 2;
39e0: 8c,1e,18            divw  R18,R1e          R18 /= R1e;                       # convert counts to freq by dividing by time
39e3: a1,ab,9a,34         ldw   R34,9aab         R34 = 9aab;
39e7: a1,5b,06,36         ldw   R36,65b          R36 = 65b;
39eb: 8c,18,34            divw  R34,R18          R34 /= R18;                       # = 106666667/freq
39ee: 45,78,00,f0,32      ad3w  R32,Rf0,78       R32 = Bapxfr;                     # Table 8C78 - conversion to BP units
39f3: ef,16,fc            call  360c             UUWordLu();
39f6: 65,80,00,38         ad2w  R38,80           R38 += 80;                        # round up to save byte vs word
39fa: c7,72,af,39         stb   R39,[R72+af]     Ibap = R39;                       # save BP 12F
39fe: c3,72,bc,16         stw   R16,[R72+bc]     Mintim2 = R16;                    # time of last BP calc
3a02: 71,fb,4e            an2b  R4e,fb           New_Bpv = 0; } }
3a05: b3,72,af,35         ldb   R35,[R72+af]     R35 = Ibap;
3a09: 11,34               clrb  R34              R34 = 0;                          # new AD sensor value 
3a0b: a3,72,b0,32         ldw   R32,[R72+b0]     R32 = Bap_Filtl;                  # Old AD sensor value, filtered BP
3a0f: ef,4c,fc            call  365e             Srolav1T(97fe);                   # filter new/old AD input
3a12: 56,d0               #args  
3a14: c3,72,b0,3e         stw   R3e,[R72+b0]     Bap_Filtl = R3e;                  # filtered BP
3a18: c7,74,80,3f         stb   R3f,[R74+80]     Bp = R3f;                         # BP - barometric pressure 1FE
3a1c: 39,c5,02            jb    B1,Rc5,3a21      if (Bfmflag = 1) goto 3a21;
3a1f: 20,06               sjmp  3a27             goto 3a27; } }
3a21: 11,b6               clrb  Rb6              Bapcnt = 0;
3a23: c3,72,bc,06         stw   R6,[R72+bc]      Mintim2 = IO_Timer;               # time of last BP read/calc

##### update MAF

3a27: 3b,c5,19            jb    B3,Rc5,3a43      if (Mfmflag = 1) goto 3a43;
3a2a: a3,72,a4,34         ldw   R34,[R72+a4]     R34 = MAF_Raw;
3a2e: 8b,f3,12,01,ae      cmpw  Rae,[Rf2+112]    
3a33: db,07               jc    3a3c             if ((uns) Rpmx4 >= Vmarpm) goto 3a3c;
3a35: 8b,f3,0e,01,34      cmpw  R34,[Rf2+10e]                                      # max MAF count
3a3a: d9,07               jgtu  3a43             if ((uns) R34 > Maxmaf ) goto 3a43;
3a3c: 8b,f3,10,01,34      cmpw  R34,[Rf2+110]                                      # min MAF count
3a41: db,0b               jc    3a4e             if (R34 > Vmamin)  {              # range OK
3a43: 91,01,26            orb   R26,1            Imfmflg = 1;                      # MAF count out of range error
3a46: b3,f2,4c,34         ldb   R34,[Rf2+4c]     R34 = Mfmhys;                     # bad MAF sensor retry interval (3)
3a4a: c7,72,cb,34         stb   R34,[R72+cb]     [14b] = R34; }                    # set bad MAF retry interval
# valid MAF sensor reading
3a4e: 37,a1,06            jnb   B7,Ra1,3a57      if (Cranking = 1)  {
3a51: c7,72,cb,00         stb   R0,[R72+cb]      [14b] = 0;                        # counts since last bad MAF read
3a55: 20,11               sjmp  3a68             goto 3a68; }
3a57: b3,72,cb,34         ldb   R34,[R72+cb]     R34 = [14b];                      # decr bad MAF read count but clamp to zero
3a5b: 98,34,00            cmpb  R0,R34           
3a5e: df,08               je    3a68             if (0 != R34)  {
3a60: 15,34               decb  R34              R34--;
3a62: c7,72,cb,34         stb   R34,[R72+cb]     [14b] = R34;
3a66: 20,03               sjmp  3a6b             goto 3a6b; }
3a68: 71,fe,26            an2b  R26,fe           Imfmflg = 0;                      # clr MAF input range error?
3a6b: 38,26,1e            jb    B0,R26,3a8c      if (Imfmflg = 0)  {               # jmp if MAF out of range error
# MAF sensor read is bad - calc air mass by speed density
3a6e: cb,74,da            push  [R74+da]         push(Archfg);
3a71: cf,74,d4            pop   [R74+d4]         Archg = pop();
3a74: a3,74,d8,30         ldw   R30,[R74+d8]     R30 = Archi;
3a78: 01,32               clrw  R32              R32 = 0;
3a7a: 0d,08,30            shldw R30,8            R30 *= 100;
3a7d: 8f,74,da,30         divw  R30,[R74+da]     R30 /= Archfg;
3a81: d5,03               jnv   3a86             if (OVF = 1)  {
3a83: bd,ff,30            ldsbw R30,ff           R30 = (int)ff; }
3a86: c3,74,dc,30         stw   R30,[R74+dc]     Filrc1 = R30;
3a8a: 20,7d               sjmp  3b09             goto 3b09; }
3a8c: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
3a8f: 3c,c5,67            jb    B4,Rc5,3af9      if (Tfmflag = 0)  {
3a92: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # spark RPM scaling
3a97: ef,72,fb            call  360c             UUWordLu();
3a9a: a0,38,30            ldw   R30,R38          R30 = R38;
3a9d: a3,72,a2,34         ldw   R34,[R72+a2]     R34 = TPS_Raw;
3aa1: 6b,72,a6,34         sb2w  R34,[R72+a6]     R34 -= TPS_Min;
3aa5: db,02               jc    3aa9             if (R34 > 0)  {
3aa7: 01,34               clrw  R34              R34 = 0; }                        # clamp to zero (throttle closing? )
3aa9: 45,f0,00,f4,32      ad3w  R32,Rf4,f0       R32 = Fn098;                      # Normalized delta TP, used for MAF sensor failure Table lookup.
3aae: ef,5b,fb            call  360c             UUWordLu();
3ab1: a0,38,32            ldw   R32,R38          R32 = R38;
3ab4: 45,2c,01,f4,38      ad3w  R38,Rf4,12c      R38 = 9102;
3ab9: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
3abc: ef,2b,fc            call  36ea             UTabLookUp();
3abf: ac,3b,38            ldzbw R38,R3b          R38 = (uns)R3b;
3ac2: a3,74,e4,34         ldw   R34,[R74+e4]     R34 = Debyma_fm;
3ac6: 01,36               clrw  R36              R36 = 0;
3ac8: 0d,08,34            shldw R34,8            R34 *= 100;
3acb: 8c,ae,34            divw  R34,Rae          R34 /= Rpmx4;
3ace: 9f,fe,07,34         divb  R34,[Rfe+7]      R34 /= PIPsC;
3ad2: d5,03               jnv   3ad7             if (OVF = 1)  {
3ad4: b1,ff,34            ldb   R34,ff           R34 = ff; }
3ad7: 11,35               clrb  R35              R35 = 0;
3ad9: 64,38,34            ad2w  R34,R38          R34 += R38;
3adc: af,74,80,36         ldzbw R36,[R74+80]     R36 = (uns)Bp;
3ae0: 09,07,36            shlw  R36,7            R36 *= 80;
3ae3: 6c,36,34            ml2w  R34,R36          R34 *= R36;
3ae6: 8d,ef,00,34         divw  R34,ef           R34 /= ef;
3aea: d5,03               jnv   3aef             if (OVF = 1)  {
3aec: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
3aef: c3,74,d4,34         stw   R34,[R74+d4]     Archg = R34;
3af3: c3,74,da,34         stw   R34,[R74+da]     Archfg = R34;
3af7: 20,10               sjmp  3b09             goto 3b09; }
3af9: 45,0c,01,f4,32      ad3w  R32,Rf4,10c      R32 = 90e2;
3afe: ef,0b,fb            call  360c             UUWordLu();
# Update NDS and ACC (multiplexed inputs)
3b01: c3,74,d4,38         stw   R38,[R74+d4]     Archg = R38;
3b05: c3,74,da,38         stw   R38,[R74+da]     Archfg = R38;
3b09: a3,72,9a,14         ldw   R14,[R72+9a]     R14 = NDS_Raw;
3b0d: 4b,74,0c,14,16      sb3w  R16,R14,[R74+c]  R16 = R14 - Lst_iacc;             # last raw AD NDS/A3C
3b12: db,02               jc    3b16             if (R16 > 0)  {
3b14: 03,16               negw  R16              R16 = -R16; }
3b16: 89,80,02,16         cmpw  R16,280          
3b1a: d9,28               jgtu  3b44             if ((uns) R16 <= 280)  {
3b1c: 71,7f,ee            an2b  Ree,7f           A3C = 0;                          # A/C cycling control switch is open
3b1f: 91,40,ee            orb   Ree,40           Indflg = 1;
3b22: 89,00,ee,14         cmpw  R14,ee00         
3b26: db,1c               jc    3b44             if (R14 > ee00)  {
3b28: 89,00,8b,14         cmpw  R14,8b00         
3b2c: d3,05               jnc   3b33             if ((uns) R14 >= 8b00)  {
3b2e: 71,bf,ee            an2b  Ree,bf           Indflg = 0;
3b31: 20,11               sjmp  3b44             goto 3b44; }
3b33: 89,00,67,14         cmpw  R14,6700         
3b37: d3,05               jnc   3b3e             if ((uns) R14 >= 6700)  {
3b39: 91,80,ee            orb   Ree,80           A3C = 1;
3b3c: 20,06               sjmp  3b44             goto 3b44; }
3b3e: 91,80,ee            orb   Ree,80           A3C = 1;                          # A/C cycling control switch is closed
3b41: 71,bf,ee            an2b  Ree,bf           Indflg = 0; } }
3b44: c3,74,0c,14         stw   R14,[R74+c]      Lst_iacc = R14;                   # save last NDS/A3C
3b48: b3,fe,02,18         ldb   R18,[Rfe+2]      R18 = TRLOAD;                     # Transmission Load switch
3b4c: b0,e7,30            ldb   R30,Re7          R30 = Flag_e7;
3b4f: 71,7f,e7            an2b  Re7,7f           Ndsflg = 0;                       # 1 = Drive.
3b52: 99,00,18            cmpb  R18,0                                              # Manual Trans, no clutch or gear switches, forced neutral state (NDSFLG = 0).
3b55: df,06               je    3b5d             if (R18 != 0)  {
3b57: 36,ee,03            jnb   B6,Ree,3b5d      if (Indflg = 1)  {
3b5a: 91,80,e7            orb   Re7,80           Ndsflg = 1; } }                   # 1 = Drive.
3b5d: 94,e7,30            xorb  R30,Re7          R30 ^= Flag_e7;
3b60: 37,30,02            jnb   B7,R30,3b65      if (B7_R30 = 1)  {
3b63: 11,cc               clrb  Rcc              Nddtim = 0; }                     # time since Neutral/Drive Switch State change, sec.
3b65: 99,03,18            cmpb  R18,3                                              # Manual Transmission, both clutch and gear switches.
3b68: d9,0b               jgtu  3b75             if ((uns) R18 > 3 ) goto 3b75;
3b6a: 71,bf,26            an2b  R26,bf           Dndsup = 0;
3b6d: 37,e7,2a            jnb   B7,Re7,3b9a      if (Ndsflg = 1)  {                # 1 = Drive.
3b70: 91,40,26            orb   R26,40           Dndsup = 1;                       # Drive Neutral select.
3b73: 20,25               sjmp  3b9a             goto 3b9a;
3b75: 3f,e7,0f            jb    B7,Re7,3b87      if (Ndsflg = 1) goto 3b87;        # 1 = Drive.
3b78: b3,f5,92,00,38      ldb   R38,[Rf4+92]     R38 = Nddelt;
3b7d: 98,cc,38            cmpb  R38,Rcc                                            # time since Neutral/Drive Switch State change, sec.
3b80: d9,18               jgtu  3b9a             if ((uns) R38 <= Nddtim)  {
3b82: 71,bf,26            an2b  R26,bf           Dndsup = 0;                       # clr  Drive Neutral select.
3b85: 20,13               sjmp  3b9a             goto 3b9a;
3b87: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
3b8a: 45,26,00,f0,32      ad3w  R32,Rf0,26       R32 = 8c26;                       # OUTPUT = Seconds.
3b8f: ef,1a,fa            call  35ac             subyteLU();
3b92: 98,cc,38            cmpb  R38,Rcc                                            # time since Neutral/Drive Switch State change, sec.
3b95: d9,03               jgtu  3b9a             if ((uns) R38 <= Nddtim)  {
3b97: 91,40,26            orb   R26,40           Dndsup = 1; } } }                 # set Drive/Neutral Select.
3b9a: 71,ef,27            an2b  R27,ef           Powsfg = 0;                       # clear Power Steering Flag.
3b9d: 30,df,03            jnb   B0,Rdf,3ba3      if (Psps_lvl = 1)  {
3ba0: 91,10,27            orb   R27,10           Powsfg = 1; }

 ###### CHECK EGOs - handle cross, rich to lean, or lean to rich
 ## check EGO 1

3ba3: 71,f7,27            an2b  R27,f7           Swtfl1 = 0;                       # Mixture cross flag EGO1
3ba6: a3,72,9c,14         ldw   R14,[R72+9c]     R14 = EGO1_Raw;
3baa: 89,c0,d5,14         cmpw  R14,d5c0                                           # Trip Voltage
3bae: db,08               jc    3bb8             if ((uns) R14 >= d5c0) goto 3bb8; # 4.17v = Rich
3bb0: 3f,ea,13            jb    B7,Rea,3bc6      if (Egofl1 = 0)  {                # jump if already rich (No Cross)
3bb3: 91,80,ea            orb   Rea,80           Egofl1 = 1;                       # Set Mixture Rich
3bb6: 20,06               sjmp  3bbe             goto 3bbe;
3bb8: 37,ea,0b            jnb   B7,Rea,3bc6      if (Egofl1 = 1)  {                # jump if already lean
3bbb: 71,7f,ea            an2b  Rea,7f           Egofl1 = 0;                       # mixture is lean
3bbe: 91,08,27            orb   R27,8            Swtfl1 = 1;                       # Set CROSS flag
3bc1: ad,01,42            ldzbw R42,1            R42 = (uns)1;                     # sensor 1
3bc4: 29,09               scall 3ccf             EGO_CrosscntB(); } }

 ## check EGO 2  (same but different flags)

3bc6: 71,fe,27            an2b  R27,fe           Swtfl2 = 0;
3bc9: a3,72,9e,14         ldw   R14,[R72+9e]     R14 = EGO2_Raw;
3bcd: 89,c0,d5,14         cmpw  R14,d5c0         
3bd1: db,08               jc    3bdb             if ((uns) R14 >= d5c0) goto 3bdb;
3bd3: 3e,ea,13            jb    B6,Rea,3be9      if (Egofl2 = 0)  {
3bd6: 91,40,ea            orb   Rea,40           Egofl2 = 1;
3bd9: 20,06               sjmp  3be1             goto 3be1;
3bdb: 36,ea,0b            jnb   B6,Rea,3be9      if (Egofl2 = 1)  {
3bde: 71,bf,ea            an2b  Rea,bf           Egofl2 = 0;
3be1: 91,01,27            orb   R27,1            Swtfl2 = 1;                       # CROSS FLAG
3be4: ad,02,42            ldzbw R42,2            R42 = (uns)2;                     # sensor 2
3be7: 28,e6               scall 3ccf             EGO_CrosscntB(); } }

#### Update Brake On / Off (A/C ? )

3be9: 71,fd,ea            an2b  Rea,fd           Biflg = 0;
3bec: 9b,f6,13,00         cmpb  R0,[Rf6+13]                                        # BIHP Brake Input H/w Present
3bf0: df,06               je    3bf8             if (0 != Bihp)  {                 # jmp if not A/C or BOO sensor input
3bf2: 34,90,03            jnb   B4,R90,3bf8      if (B4_Last_HSI = 1)  {           # jmp if not BOO HIGH
3bf5: 91,02,ea            orb   Rea,2            Biflg = 1; } }                    # Brake is on.
3bf8: 91,20,2b            orb   R2b,20           Stiflg = 1;
3bfb: 33,0b,03            jnb   B3,Rb,3c01       if (B3_HSI_Sample = 1)  {         # HSI bit 3 is STI - Self Test Input - on the fly test
3bfe: 71,df,2b            an2b  R2b,df           Stiflg = 0; }

###############################################################################
# KeyPower may be read thru a 20k and 4.35K voltage divider yielding 17.86% of battery voltage to AD input
# Update VCAL/KEYPWR
# VCAL is 2.5Volts giving an AD reading of 7FE0 
# a 14V battery thru the divider gives a 2.5V AD input
# resulting battery voltage level is times 16
############################################################################### 
3c01: a3,fc,0c,36         ldw   R36,[Rfc+c]      R36 = Spdlim_a_off;
3c05: 01,34               clrw  R34              R34 = 0;                          # R34L = 28000000
3c07: a3,72,90,32         ldw   R32,[R72+90]     R32 = VSS_Raw;
3c0b: 88,32,00            cmpw  R0,R32                                             # chk for div by zero (VCAL regulator is bad)
3c0e: df,05               je    3c15             if (0 = R32) goto 3c15;
3c10: 8c,32,34            divw  R34,R32          R34 /= R32;                       # 28000000/VCAL = 5014 without voltage error
3c13: d5,06               jnv   3c1b             if (OVF = 1)  {
3c15: a1,fd,8d,34         ldw   R34,8dfd         R34 = 8dfd;                       # VCAL default 

# validate VCAL range

3c19: 20,10               sjmp  3c2b             goto 3c2b; }
3c1b: 89,fd,8d,34         cmpw  R34,8dfd         
3c1f: d9,f4               jgtu  3c15             if ((uns) R34 > 8dfd ) goto 3c15;
3c21: 89,89,41,34         cmpw  R34,4189         
3c25: d9,04               jgtu  3c2b             if ((uns) R34 <= 4189)  {
3c27: a1,89,41,34         ldw   R34,4189         R34 = 4189; }                     # clamp range err

# normalize KEYPWR voltage

3c2b: 6f,fe,18,34         ml2w  R34,[Rfe+18]     R34 *= [9e72];                    # = B32C (gives 380BBF70 w/o voltage err)
3c2f: a0,36,34            ldw   R34,R36          R34 = R36;                        # hi 16 bits of 32 bit result
3c32: 6f,72,8c,34         ml2w  R34,[R72+8c]     R34 *= Key_Pwr;                   # raw KEYPWR (17.86% of bat voltage)(result is VBat * 2)(result Hi SB 1BFE w/o errs)
3c36: 89,e1,1f,36         cmpw  R36,1fe1                                           # check max voltage in top 16 of 32 bit result (~15.94V)
3c3a: d9,05               jgtu  3c41             if ((uns) R36 <= 1fe1)  {         # clamp voltage
3c3c: 0d,03,34            shldw R34,3            R34 *= 8;                         # now volts * 16
3c3f: 20,03               sjmp  3c44             goto 3c44; }
3c41: b1,ff,37            ldb   R37,ff           R37 = ff;                         # max voltage

# filter battery voltage level

3c44: af,74,93,32         ldzbw R32,[R74+93]     R32 = (uns)Vbat;                  # OLD AD sensor value Lo = 211 - Battery Voltage Level
3c48: ac,37,34            ldzbw R34,R37          R34 = (uns)R37;                   # NEW AD sensor value Lo
3c4b: ef,10,fa            call  365e             Srolav1T(97f8);                   # filter new AD input - battery voltage
3c4e: 50,d0               #args                                                    # filter factors (lookup in ROM)
3c50: c7,74,93,3e         stb   R3e,[R74+93]     Vbat = R3e;                       # updated AD value = 211 - Battery Voltage Level * 16
3c54: b0,3e,34            ldb   R34,R3e          R34 = R3e;
3c57: 45,b2,00,fc,32      ad3w  R32,Rfc,b2       R32 = Inj_vss;                    # Table injector offset vs battery volts
3c5c: ef,58,f9            call  35b7             UUbyteLu();
3c5f: c7,72,13,38         stb   R38,[R72+13]     Pwofs = R38;
3c63: 01,30               clrw  R30              R30 = 0;
3c65: b0,38,31            ldb   R31,R38          R31 = R38;
3c68: 6d,06,0d,30         ml2w  R30,d06          R30 *= d06;
3c6c: c3,72,0e,32         stw   R32,[R72+e]      Pwoff = R32;
3c70: a3,74,9c,32         ldw   R32,[R74+9c]     R32 = Oldtp;
3c74: 68,aa,32            sb2w  R32,Raa          R32 -= TP;
3c77: d3,0a               jnc   3c83             if ((uns) R32 >= 0)  {
3c79: 8b,f4,30,32         cmpw  R32,[Rf4+30]     
3c7d: d1,04               jleu  3c83             if ((uns) R32 > Tpdlta )  {
3c7f: c7,74,20,00         stb   R0,[R74+20]      Tar = 0; } }                      # scale and translated TAR
3c83: b3,74,20,30         ldb   R30,[R74+20]     R30 = Tar;
3c87: 9b,f4,34,30         cmpb  R30,[Rf4+34]     
3c8b: d1,15               jleu  3ca2             if ((uns) R30 > Aetar )  {
3c8d: a3,74,de,32         ldw   R32,[R74+de]     R32 = Load;                       # engine load (VE? )
3c91: 6b,74,9e,32         sb2w  R32,[R74+9e]     R32 -= Aeload;
3c95: d3,0b               jnc   3ca2             if ((uns) R32 >= 0)  {
3c97: 8b,f4,32,32         cmpw  R32,[Rf4+32]     
3c9b: d1,05               jleu  3ca2             if ((uns) R32 > Aeacld )  {
3c9d: 91,20,29            orb   R29,20           Aeoflg = 1;
3ca0: 20,08               sjmp  3caa             goto 3caa; } } }
3ca2: 98,00,30            cmpb  R30,R0           
3ca5: d7,03               jne   3caa             if (R30 = 0)  {
3ca7: 71,df,29            an2b  R29,df           Aeoflg = 0; }
3caa: c3,74,9c,aa         stw   Raa,[R74+9c]     Oldtp = TP;
3cae: 45,e3,00,f4,32      ad3w  R32,Rf4,e3       R32 = Fn389;
3cb3: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;
3cb7: ef,fd,f8            call  35b7             UUbyteLu();
3cba: c7,74,82,38         stb   R38,[R74+82]     Mult_bp311 = R38;
3cbe: 45,46,01,fa,32      ad3w  R32,Rfa,146      R32 = 98ee;
3cc3: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;
3cc7: ef,ed,f8            call  35b7             UUbyteLu();
3cca: c7,74,83,38         stb   R38,[R74+83]     Mult_bp212A = R38;
3cce: f0                  ret                    return;

###################################################################
# Count the no of times switched between rich and lean (of stiochoimetric)
# 2A4 - total crosses
# 2A5 - EGO1 crosses
# 2A6 - EGO2 crosses
### DO THIS ON CROSS. R42 CONTAINS EGO NUMERB - EITHER 1 OR 2
###################################################################


  EGO_CrosscntB:
3ccf: 28,02               scall 3cd3             EGO_crosscnt();                   # Increment CROSS COUNT by BANK
3cd1: 11,42               clrb  R42              R42 = 0;

  EGO_crosscnt:
3cd3: b3,43,a4,02,34      ldb   R34,[R42+2a4]    R34 = [R42+Egosss];               # INCREMENT CROSS COUNTER
3cd8: 17,34               incb  R34              R34++;
3cda: d3,02               jnc   3cde             if ((uns) R34 >= 0)  {
3cdc: 15,34               decb  R34              R34--; }                          # clamp max to FF
3cde: c7,43,a4,02,34      stb   R34,[R42+2a4]    [R42+Egosss] = R34;
3ce3: f0                  ret                    return;

#################################################################
# Update (MPH) vehicle speed values
# get sample interval time end and click count
# see routine 2A15 for click count
# 02AC = filtered MPH
# 02B2 = unfiltered MPH
# 02BC = filtered MPH
# Tasklist Routine at 2151, routine offset 12
#################################################################


  Update_MPH:
3ce4: fa                  di                     disable ints;
3ce5: ff                  nop                    
3ce6: ac,b2,42            ldzbw R42,Rb2          R42 = (uns)Mphcnt;                # (VSS)
3ce9: a3,74,40,30         ldw   R30,[R74+40]     R30 = Mphtiml1;                   # IO time for HSI going 'high'
3ced: b3,74,42,32         ldb   R32,[R74+42]     R32 = Mphtim1H;
3cf1: 11,b2               clrb  Rb2              Mphcnt = 0;                       # VSS speed ring clicks
# start new sample interval
3cf3: fb                  ei                     enable ints;
3cf4: 01,34               clrw  R34              R34 = 0;
3cf6: b3,74,3d,36         ldb   R36,[R74+3d]     R36 = Tslmph;                     # time since last click
3cfa: 99,ff,36            cmpb  R36,ff           
3cfd: d3,05               jnc   3d04             if ((uns) R36 >= ff)  {
3cff: 71,fb,c4            an2b  Rc4,fb           First_mph = 0;                    # timed out, clear and reset
# check for any click count
3d02: 20,2f               sjmp  3d33             goto 3d33; }
3d04: 98,00,42            cmpb  R42,R0                                             # no clicks?
3d07: d7,06               jne   3d0f             if (R42 = 0)  {                   # jmp if valid sample
3d09: a3,74,34,34         ldw   R34,[R74+34]     R34 = Mph_Raw;                    # NEW MPH = last MPH
# calc time per speed ring click
3d0d: 20,28               sjmp  3d37             goto 3d37; }
3d0f: ac,32,16            ldzbw R16,R32          R16 = (uns)R32;                   # time hi 8 bits
3d12: 4b,74,44,30,14      sb3w  R14,R30,[R74+44] R14 = R30 - Mphtim2H;             # time since start of this RB2 click count (24 bits)
3d17: bb,74,46,16         sbbb  R16,[R74+46]     R16 -= [2c4] - CY;
3d1b: 8c,42,14            divw  R14,R42          R14 /= R42;                       # = time per VSS click
3d1e: d5,03               jnv   3d23             if (OVF = 1)  {
3d20: bd,ff,14            ldsbw R14,ff           R14 = (int)ff; }

# calc MPH - 96000000/2.4 = 40000000.  4000 clicks per mile ?
3d23: a1,b8,05,36         ldw   R36,5b8          R36 = 5b8;                        # = 96000000 
3d27: a1,00,d8,34         ldw   R34,d800         R34 = d800;
3d2b: 8c,14,34            divw  R34,R14          R34 /= R14;                       # 96M / R14(time per click) = distance per time (MPH? )
3d2e: d5,03               jnv   3d33             if (OVF = 1)  {
3d30: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
3d33: c3,74,34,34         stw   R34,[R74+34]     Mph_Raw = R34;                    # NEW (unfiltered) MPH
3d37: c3,74,44,30         stw   R30,[R74+44]     Mphtim2H = R30;                   # IOTIme of this sample (24 bits)
3d3b: c7,74,46,32         stb   R32,[R74+46]     [2c4] = R32;
3d3f: a3,74,3e,32         ldw   R32,[R74+3e]     R32 = Mph_Filt;
3d43: ef,18,f9            call  365e             Srolav1T(97fa);
3d46: 52,d0               #args  
3d48: c3,74,3e,3e         stw   R3e,[R74+3e]     Mph_Filt = R3e;                   # Filtered vehicle speed (1)
3d4c: a3,74,2e,32         ldw   R32,[R74+2e]     R32 = Mph_FiltA;
3d50: ef,0b,f9            call  365e             Srolav1T(9802);
3d53: 5a,d0               #args  
3d55: c3,74,2e,3e         stw   R3e,[R74+2e]     Mph_FiltA = R3e;                  # Filtered vehicle speed (2)
3d59: f0                  ret                    return;

#################################################################
# Update heated windshield flag - check for some frequency input
# Tasklist Routine at 2151, routine offset 10
#################################################################


  Update_HWND:
3d5a: 51,80,ee,30         an3b  R30,Ree,80       R30 = Flags_ee & 80;              # A3C flag
3d5e: 5b,76,38,30,32      sb3b  R32,R30,[R76+38] R32 = R30 - Lsta3C;               # subtract from last state
3d63: df,08               je    3d6d             if (R32 != 0)  {                  # no state change
3d65: c7,76,38,30         stb   R30,[R76+38]     Lsta3C = R30;                     # last state = current state
3d69: c3,76,2e,00         stw   R0,[R76+2e]      A3CTMR = 0; }
3d6d: a3,76,2e,30         ldw   R30,[R76+2e]     R30 = A3CTMR;
3d71: 8b,f0,06,30         cmpw  R30,[Rf0+6]      
3d75: d1,04               jleu  3d7b             if ((uns) R30 > [8c06] )  {       # 250mS
3d77: c3,76,30,00         stw   R0,[R76+30]      Hwtmr = 0; }
3d7b: a3,76,30,34         ldw   R34,[R76+30]     R34 = Hwtmr;
3d7f: 8b,f0,08,34         cmpw  R34,[Rf0+8]      
3d83: d1,0e               jleu  3d93             if ((uns) R34 > [8c08] )  {       # 300mS
3d85: 39,e6,0b            jb    B1,Re6,3d93      if (Hwflag = 0)  {                # defrost already on ?
3d88: 38,e6,08            jb    B0,Re6,3d93      if (Hwflgl = 0)  {                # jmp if HWFLGL - first time
3d8b: 91,02,e6            orb   Re6,2            Hwflag = 1;
3d8e: 91,01,e6            orb   Re6,1            Hwflgl = 1;                       # set first time defrost on
3d91: 20,0c               sjmp  3d9f             return; } } }
3d93: 8b,f6,0a,30         cmpw  R30,[Rf6+a]      
3d97: d1,06               jleu  3d9f             if ((uns) R30 <= SSFCTR) return;
3d99: 3f,ee,03            jb    B7,Ree,3d9f      if (A3C = 1) return;              # jmp if A3C - is AC on?
3d9c: 71,fd,e6            an2b  Re6,fd           Hwflag = 0;
3d9f: f0                  ret                    return;

 ############# RPM calc tables ###################################
# first list is top word, second is bottom word of 32 bit variable
# used below, where  rpm*4 = value/PIP interval  (in IOtimer ticks)
##################################################################



3da0: fa,02               word    2fa
3da2: fc,01               word    1fc
3da4: 7d,01               word    17d
3da6: 80,f0               word   f080                                              # = 2faf080 = 50,000,000 4 cyl
3da8: 55,a0               word   a055                                              # = 1fca055 = 33,333,333 6 cyl
3daa: 40,78               word   7840                                              # = 17d7840 = 25,000,000 8 cyl

#################################################################
# Update RPM variables - filtering as required and other stuff
# 0x108 (RPM_Filt1) RPM with filter 1
# 0x27C (RPM_Filt2) RPM with filter 2
# Tasklist Routine at 2151, routine offset 14
# RAE is raw RPM ( engine RPM * 4 )
#################################################################


  Update_rpm:
3dac: a1,33,03,14         ldw   R14,333          R14 = Tstall;
3db0: 8b,72,be,14         cmpw  R14,[R72+be]                                       # time since last PIP recieved ?
3db4: d9,3b               jgtu  3df1             if ((uns) R14 <= Tslpip)  {
3db6: 01,36               clrw  R36              R36 = 0;                          # RPM = 0?
3db8: 71,ef,2d            an2b  R2d,ef           First_pip = 0;
3dbb: b1,01,32            ldb   R32,1            R32 = 1;
3dbe: c7,74,ec,32         stb   R32,[R74+ec]     Inj_pip_cnt1 = R32;
3dc2: c7,74,ed,32         stb   R32,[R74+ed]     Inj_pip_cnt2 = R32;
3dc6: 71,2f,2e            an2b  R2e,2f           Sync_up_fuel = 0;
                                                 Synflg = 0;
                                                 Fuel_in_sync = 0;
3dc9: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
3dcd: df,0d               je    3ddc             if (0 != Tfi_dwell)  {
3dcf: fa                  di                     disable ints;
3dd0: ff                  nop                    
3dd1: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # short entry 2284 - spout?
3dd5: 91,08,4c            orb   R4c,8            Immediate = 1;
3dd8: ef,e2,e5            call  23bd             Send_HSO_Cmd();                   # send HSO command 55 ands lots of other stuff - spout?
3ddb: fb                  ei                     enable ints; }
3ddc: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
3de0: df,0d               je    3def             if (0 != Hphidres)  {
3de2: fa                  di                     disable ints;
3de3: ff                  nop                    
3de4: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # 2nd short entry 2284 - spout?
3de8: 91,08,4c            orb   R4c,8            Immediate = 1;
3deb: ef,cf,e5            call  23bd             Send_HSO_Cmd();                   # send HSO command C5 ands lots of other stuff - spout?
3dee: fb                  ei                     enable ints; }
3def: 20,25               sjmp  3e16             goto 3e16; }
3df1: 33,4e,4e            jnb   B3,R4e,3e42      if (New_rpm = 1)  {
3df4: 71,f7,4e            an2b  R4e,f7           New_rpm = 0;
3df7: af,fe,07,30         ldzbw R30,[Rfe+7]      R30 = (uns)PIPsC;
3dfb: a3,31,9c,3d,36      ldw   R36,[R30+3d9c]   R36 = [R30+3d9c];                 # Hi word from table
3e00: a3,31,a2,3d,34      ldw   R34,[R30+3da2]   R34 = [R30+3da2];                 # Lo word from table
3e05: a0,ba,38            ldw   R38,Rba          R38 = PIPHi_ETime;                # PIP time Lo 
3e08: ac,bc,3a            ldzbw R3a,Rbc          R3a = (uns)PIPHi_ETimeH;          # Pip time Hi (byte)
3e0b: 0f,30,38            norm  R0,R30           R30 = nrml(0);                    # normalize time value (R38Long)
3e0e: 8c,3a,34            divw  R34,R3a          R34 /= R3a;                       # divide. (val/pip time = RPM)
3e11: 01,36               clrw  R36              R36 = 0;                          # engine RPM is in bottom bits of LONG shift
3e13: 0d,30,34            shldw R34,R30          R34 <<= R30;                      # new RPM
3e16: a0,36,ae            ldw   Rae,R36          Rpmx4 = R36;                      # RAE = RPM * 4
3e19: 08,06,36            shrw  R36,6            R36 /= 40;
3e1c: 98,00,37            cmpb  R37,R0           
3e1f: df,03               je    3e24             if (R37 != 0)  {
3e21: b1,ff,36            ldb   R36,ff           R36 = ff; }
3e24: c7,74,21,36         stb   R36,[R74+21]     N_byte = R36;
3e28: ef,29,f8            call  3654             Srolav3T(RPM_Filt1,Rpmx4,97f4);
3e2b: 08,01,ae,00,4c,d0   #args  
3e31: c3,72,88,3e         stw   R3e,[R72+88]     RPM_Filt1 = R3e;
3e35: ef,1c,f8            call  3654             Srolav3T(RPM_Filt2,Rpmx4,9804);
3e38: 7c,02,ae,00,5c,d0   #args  
3e3e: c3,74,fe,3e         stw   R3e,[R74+fe]     RPM_Filt2 = R3e; }
3e42: a3,fc,2e,32         ldw   R32,[Rfc+2e]     R32 = [9aac];                     # = 256
3e46: 08,04,32            shrw  R32,4            R32 /= 10;
3e49: 7f,fc,33,32         ml2b  R32,[Rfc+33]     R32 *= Outinj;                    # R32 = 16
3e4d: 9f,fc,32,32         divb  R32,[Rfc+32]     R32 /= Cyl_wrap;                  # 8 - no of cyls
3e51: c7,76,44,32         stb   R32,[R76+44]     Piplim = R32;                     # piplim = 4
3e55: af,fe,07,14         ldzbw R14,[Rfe+7]      R14 = (uns)PIPsC;
3e59: 69,04,00,14         sb2w  R14,4            R14 -= 4;                         # R14 is index (0,2,4)=(4,6,8 cyls)
3e5d: cb,15,c4,27         push  [R14+27c4]       push([R14+27c4]);                 # 27C4 [4] = 3200
3e61: cf,76,48            pop   [R76+48]         Sim_min = pop();                  # sim min = 3200
3e64: 64,f0,14            ad2w  R14,Rf0          R14 += Rf0;
3e67: cb,14,12            push  [R14+12]         push([R14+12]);                   # Min PIP Period
3e6a: cf,76,46            pop   [R76+46]         Min_pip_dly = pop();              # Min PIP dly = 961
3e6d: 8b,fe,0e,00         cmpw  R0,[Rfe+e]                                         # = 13107  20% of 65536
3e71: d6,05               jge   3e78             if (0 < MHPFD)  {
3e73: 71,fb,25            an2b  R25,fb           Mhpfd_neg = 0;
3e76: 20,03               sjmp  3e7b             return; }
3e78: 91,04,25            orb   R25,4            Mhpfd_neg = 1;
3e7b: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 20
#################################################################


  Load_Calc:
3e7c: a3,f4,42,36         ldw   R36,[Rf4+42]     R36 = Archlk;
3e80: 9f,fe,07,36         divb  R36,[Rfe+7]      R36 /= PIPsC;
3e84: d5,03               jnv   3e89             if (OVF = 1)  {
3e86: b1,ff,36            ldb   R36,ff           R36 = ff; }
3e89: 11,37               clrb  R37              R37 = 0;
3e8b: 01,34               clrw  R34              R34 = 0;
3e8d: 8c,ae,34            divw  R34,Rae          R34 /= Rpmx4;
3e90: d5,03               jnv   3e95             if (OVF = 1)  {
3e92: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
3e95: c3,74,d6,34         stw   R34,[R74+d6]     Archli = R34;
3e99: 9b,f6,08,00         cmpb  R0,[Rf6+8]       
3e9d: df,05               je    3ea4             if (0 != [93b0])  {
3e9f: 91,02,26            orb   R26,2            Archflg = 1;
3ea2: 20,03               sjmp  3ea7             goto 3ea7; }
3ea4: 71,fd,26            an2b  R26,fd           Archflg = 0;
3ea7: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # spark RPM scaling
3eac: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
3eaf: ef,5a,f7            call  360c             UUWordLu();
3eb2: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
3eb5: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = Emm_lscale;                 # emission load scaling
3eba: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # raw engine load (= VE? )
3ebe: ef,4b,f7            call  360c             UUWordLu();
3ec1: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
3ec4: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
3ec7: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
3eca: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
3ecd: 45,22,01,fc,38      ad3w  R38,Rfc,122      R38 = 9ba0;                       # Air Meter Backflow Correction Table
3ed2: ef,15,f8            call  36ea             UTabLookUp();
3ed5: c7,76,39,3b         stb   R3b,[R76+39]     Archcor = R3b;
3ed9: 45,2e,02,f4,32      ad3w  R32,Rf4,22e      R32 = 9204;                       # Table 9204 ? vs RPM
3ede: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
3ee1: ef,28,f7            call  360c             UUWordLu();
3ee4: c3,76,2c,38         stw   R38,[R76+2c]     Air37 = R38;
3ee8: a3,74,d4,30         ldw   R30,[R74+d4]     R30 = Archg;
3eec: af,fe,07,32         ldzbw R32,[Rfe+7]      R32 = (uns)PIPsC;
3ef0: 6c,32,30            ml2w  R30,R32          R30 *= R32;
3ef3: 0c,03,30            shrdw R30,3            R30 /= 8;
3ef6: 6c,ae,30            ml2w  R30,Rae          R30 *= Rpmx4;
3ef9: 0c,0e,30            shrdw R30,e            R30 /= 4000;
3efc: 88,00,32            cmpw  R32,R0           
3eff: df,03               je    3f04             if (R32 != 0)  {
3f01: bd,ff,30            ldsbw R30,ff           R30 = (int)ff; }
3f04: c0,a2,30            stw   R30,Ra2          AM = R30;
3f07: a3,72,de,3e         ldw   R3e,[R72+de]     R3e = Fam;
3f0b: 08,01,3e            shrw  R3e,1            R3e /= 2;
3f0e: a3,72,a6,3c         ldw   R3c,[R72+a6]     R3c = TPS_Min;                    # =Closed TP
3f12: 67,f4,6a,3c         ad2w  R3c,[Rf4+6a]     R3c += Delrat;
3f16: 47,fe,24,3c,38      ad3w  R38,R3c,[Rfe+24] R38 = R3c + [9e7e];
3f1b: 88,aa,38            cmpw  R38,Raa          
3f1e: d3,22               jnc   3f42             if ((uns) R38 < TP) goto 3f42;
3f20: b3,72,e6,38         ldb   R38,[R72+e6]     R38 = Dsdrpm;
3f24: 9b,fe,1e,38         cmpb  R38,[Rfe+1e]     
3f28: d9,18               jgtu  3f42             if ((uns) R38 > [9e78] ) goto 3f42;
3f2a: 77,fe,1f,38         ad2b  R38,[Rfe+1f]     R38 += [9e79];
3f2e: db,2a               jc    3f5a             if ((uns) R38 >= 0) goto 3f5a;
3f30: 9b,74,21,38         cmpb  R38,[R74+21]     
3f34: db,24               jc    3f5a             if ((uns) R38 >= N_byte) goto 3f5a;
3f36: 77,fe,20,38         ad2b  R38,[Rfe+20]     R38 += [9e7a];
3f3a: db,75               jc    3fb1             if ((uns) R38 >= 0) goto 3fb1;
3f3c: 9b,74,21,38         cmpb  R38,[R74+21]     
3f40: db,6f               jc    3fb1             if ((uns) R38 >= N_byte) goto 3fb1;
3f42: 71,f7,ec            an2b  Rec,f7           Refflg = 0;
3f45: a3,fe,26,3c         ldw   R3c,[Rfe+26]     R3c = IFAM;
3f49: 08,01,3c            shrw  R3c,1            R3c /= 2;
3f4c: 88,3c,3e            cmpw  R3e,R3c          
3f4f: d1,07               jleu  3f58             if ((uns) R3e > R3c )  {
3f51: 09,01,3c            shlw  R3c,1            R3c *= 2;
3f54: c3,72,de,3c         stw   R3c,[R72+de]     Fam = R3c; }
3f58: 20,a2               sjmp  3ffc             goto 3ffc;
3f5a: 88,aa,3c            cmpw  R3c,Raa          
3f5d: d3,52               jnc   3fb1             if ((uns) R3c >= TP)  {
3f5f: 3b,ec,4f            jb    B3,Rec,3fb1      if (Refflg = 0)  {
3f62: 91,08,ec            orb   Rec,8            Refflg = 1;
3f65: c3,72,b2,00         stw   R0,[R72+b2]      Ffmtmr = 0;
3f69: af,fe,22,30         ldzbw R30,[Rfe+22]     R30 = (uns)[9e7c];                # = 66
3f6d: 6c,3e,30            ml2w  R30,R3e          R30 *= R3e;
3f70: 0c,07,30            shrdw R30,7            R30 /= 80;
3f73: 88,30,a2            cmpw  Ra2,R30          
3f76: db,05               jc    3f7d             if (AM > R30)  {
3f78: a0,30,a2            ldw   Ra2,R30          AM = R30;
3f7b: 20,12               sjmp  3f8f             goto 3f8f; }
3f7d: af,fe,21,30         ldzbw R30,[Rfe+21]     R30 = (uns)[9e7b];                # = 9A
3f81: 6c,3e,30            ml2w  R30,R3e          R30 *= R3e;
3f84: 0c,07,30            shrdw R30,7            R30 /= 80;
3f87: 88,30,a2            cmpw  Ra2,R30          
3f8a: d1,03               jleu  3f8f             if ((uns) AM > R30 )  {
3f8c: a0,30,a2            ldw   Ra2,R30          AM = R30; }
3f8f: a3,f4,4a,32         ldw   R32,[Rf4+4a]     R32 = Faminc;
3f93: 0a,01,32            asrw  R32,1            R32 /= 2;
3f96: 44,a2,32,3e         ad3w  R3e,R32,Ra2      R3e = R32 + AM;
3f9a: 3f,33,07            jb    B7,R33,3fa4      if (B7_R33 = 1) goto 3fa4;
3f9d: d3,09               jnc   3fa8             if ((uns) R3e >= 0)  {
3f9f: bd,ff,3e            ldsbw R3e,ff           R3e = (int)ff;
3fa2: 20,04               sjmp  3fa8             goto 3fa8;
3fa4: db,02               jc    3fa8             if (R3e > 0)  {
3fa6: 01,3e               clrw  R3e              R3e = 0; } }
3fa8: 09,01,3e            shlw  R3e,1            R3e *= 2;
3fab: c3,72,de,3e         stw   R3e,[R72+de]     Fam = R3e;
3faf: 20,45               sjmp  3ff6             goto 3ff6; } }
3fb1: 33,ec,42            jnb   B3,Rec,3ff6      if (Refflg = 0) goto 3ff6;
3fb4: 48,3e,a2,40         sb3w  R40,Ra2,R3e      R40 = AM - R3e;
3fb8: d6,02               jge   3fbc             if (R40 < 0)  {
3fba: 03,40               negw  R40              R40 = -R40; }
3fbc: a3,f4,7e,34         ldw   R34,[Rf4+7e]     R34 = Famlim;
3fc0: 6c,a2,34            ml2w  R34,Ra2          R34 *= AM;
3fc3: 88,36,40            cmpw  R40,R36          
3fc6: d1,2e               jleu  3ff6             if ((uns) R40 <= R36) goto 3ff6;
3fc8: b3,72,ea,34         ldb   R34,[R72+ea]     R34 = Bgcnt;
3fcc: 17,34               incb  R34              R34++;
3fce: 9b,f4,6c,34         cmpb  R34,[Rf4+6c]     
3fd2: d3,24               jnc   3ff8             if ((uns) R34 >= Samrat)  {
3fd4: a0,3e,32            ldw   R32,R3e          R32 = R3e;
3fd7: a0,a2,34            ldw   R34,Ra2          R34 = AM;
3fda: a3,fa,4a,36         ldw   R36,[Rfa+4a]     R36 = [97f2];
3fde: a3,72,b2,3e         ldw   R3e,[R72+b2]     R3e = Ffmtmr;
3fe2: c3,72,b2,00         stw   R0,[R72+b2]      Ffmtmr = 0;
3fe6: 91,01,ca            orb   Rca,1            Asp_input = 1;
3fe9: ef,77,f6            call  3663             Urolav();
3fec: 09,01,3e            shlw  R3e,1            R3e *= 2;
3fef: c3,72,de,3e         stw   R3e,[R72+de]     Fam = R3e;
3ff3: 08,01,3e            shrw  R3e,1            R3e /= 2;
3ff6: 11,34               clrb  R34              R34 = 0; }
3ff8: c7,72,ea,34         stb   R34,[R72+ea]     Bgcnt = R34;
3ffc: 3b,ec,0f            jb    B3,Rec,400e      if (Refflg = 0)  {
3fff: 11,32               clrb  R32              R32 = 0;
4001: 20,03               sjmp  4006             goto 4006;
4003: b1,80,32            ldb   R32,80           R32 = 80;
4006: 71,f7,25            an2b  R25,f7           Fam_flg = 0;
4009: a0,a2,3e            ldw   R3e,Ra2          R3e = AM;
400c: 20,2c               sjmp  403a             goto 403a; }
400e: b1,ff,32            ldb   R32,ff           R32 = ff;
4011: a3,fe,1c,34         ldw   R34,[Rfe+1c]     R34 = [9e76];                     # = 0
4015: 6c,3e,34            ml2w  R34,R3e          R34 *= R3e;
4018: 0d,01,34            shldw R34,1            R34 *= 2;
401b: db,08               jc    4025             if ((uns) R34 >= 0) goto 4025;
401d: 88,36,a2            cmpw  Ra2,R36          
4020: d9,e1               jgtu  4003             if ((uns) AM > R36 ) goto 4003;
4022: 91,08,25            orb   R25,8            Fam_flg = 1;
4025: a3,f5,80,00,34      ldw   R34,[Rf4+80]     R34 = Maxfam;                     # = A0
402a: 6c,a2,34            ml2w  R34,Ra2          R34 *= AM;
402d: 0d,01,34            shldw R34,1            R34 *= 2;
4030: db,08               jc    403a             if (R34 > 0)  {
4032: 88,36,3e            cmpw  R3e,R36          
4035: d1,03               jleu  403a             if ((uns) R3e > R36 )  {
4037: a0,36,3e            ldw   R3e,R36          R3e = R36; } }
403a: 8b,fe,1a,3e         cmpw  R3e,[Rfe+1a]     
403e: db,04               jc    4044             if (R3e > MINAM)  {
4040: a3,fe,1a,3e         ldw   R3e,[Rfe+1a]     R3e = MINAM; }
4044: c0,a2,3e            stw   R3e,Ra2          AM = R3e;
4047: c7,72,e7,32         stb   R32,[R72+e7]     Famreg = R32;
404b: af,74,0a,38         ldzbw R38,[R74+a]      R38 = (uns)Em;                    # EGR Mass Flow
404f: 09,03,38            shlw  R38,3            R38 *= 8;
4052: 64,a2,38            ad2w  R38,Ra2          R38 += AM;
4055: d3,03               jnc   405a             if ((uns) R38 >= 0)  {
4057: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }                  # clamp max to FFFF
405a: a0,38,a4            ldw   Ra4,R38          Ampem = R38;
405d: a3,74,d4,3e         ldw   R3e,[R74+d4]     R3e = Archg;
4061: 01,3c               clrw  R3c              R3c = 0;
4063: 0c,03,3c            shrdw R3c,3            R3c /= 8;
# engine displacement = 1B4A = 6986 - engine displacement (unit = 0.0430981 Cubic Inches)#

4066: 8f,f4,44,3c         divw  R3c,[Rf4+44]     R3c /= Engdisp;
406a: d5,03               jnv   406f             if (OVF = 1)  {
406c: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; }                  # clamp max to FFFF
406f: c3,74,de,3c         stw   R3c,[R74+de]     Load = R3c;                       # SET engine load

# speed density VE calc? RPM*BP/#00EF = ?  #

4073: 45,12,02,fc,32      ad3w  R32,Rfc,212      R32 = 9c90;
4078: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
407b: ef,8e,f5            call  360c             UUWordLu();
407e: af,74,80,30         ldzbw R30,[R74+80]     R30 = (uns)Bp;
4082: 6c,38,30            ml2w  R30,R38          R30 *= R38;                       # BP * fs(RPM)
4085: 8d,ef,00,30         divw  R30,ef           R30 /= ef;
4089: d5,03               jnv   408e             if (OVF = 1)  {
408b: bd,ff,30            ldsbw R30,ff           R30 = (int)ff; }                  # clamp max to FFFF
408e: c3,74,e0,30         stw   R30,[R74+e0]     Peak_load = R30;
4092: 9b,fc,02,00         cmpb  R0,[Rfc+2]       
4096: d7,10               jne   40a8             if (0 = [9a80])  {                # never jumps ?
4098: a0,3c,3e            ldw   R3e,R3c          R3e = R3c;
409b: 01,3c               clrw  R3c              R3c = 0;
409d: 0c,01,3c            shrdw R3c,1            R3c /= 2;                         # div by 2
40a0: 8c,30,3c            divw  R3c,R30          R3c /= R30;                       # air flow / (RPM * CID) = VE (=Load)
40a3: d5,03               jnv   40a8             if (OVF = 1)  {
40a5: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; } }                # clamp max to FFFF
40a8: c3,74,e2,3c         stw   R3c,[R74+e2]     Perload = R3c;                    # Volumetric Efficiency (=Load)
40ac: ef,a5,f5            call  3654             Srolav3T(Aeload,Load,ldffact);
40af: 1c,02,5c,02,54,d0   #args  
40b5: c3,74,9e,3e         stw   R3e,[R74+9e]     Aeload = R3e;                     # Save filtered Load
40b9: f0                  ret                    return;

#################################################################
# Update EGR stuff?
# Tasklist Routine at 2151, routine offset 24
#################################################################


  Update_Egr:
40ba: 36,e6,4a            jnb   B6,Re6,4107      if (Pfehp_flg = 0) goto 4107;     # PFE EGR Present
40bd: 3f,a1,3c            jb    B7,Ra1,40fc      if (Cranking = 0)  {
40c0: ef,91,f5            call  3654             Srolav3T(EPT_Filt,EVP_Raw,97f0);
40c3: 04,01,16,01,48,d0   #args  
40c9: c3,72,84,3e         stw   R3e,[R72+84]     EPT_Filt = R3e;                   # save result
40cd: 37,d0,2a            jnb   B7,Rd0,40fa      if (Cl_thrtl = 1)  {
40d0: 77,fa,30,00         ad2b  R0,[Rfa+30]      R0 += [97d8];
40d4: df,24               je    40fa             if (R0 != 0)  {
40d6: af,72,e6,30         ldzbw R30,[R72+e6]     R30 = (uns)Dsdrpm;                # 166
40da: 09,06,30            shlw  R30,6            R30 *= 40;
40dd: 67,fa,32,30         ad2w  R30,[Rfa+32]     R30 += [97da];
40e1: 88,30,ae            cmpw  Rae,R30          
40e4: d9,14               jgtu  40fa             if ((uns) Rpmx4 <= R30)  {
40e6: 9b,fa,34,b0         cmpb  Rb0,[Rfa+34]     
40ea: de,0e               jlt   40fa             if (ECT >= [97dc])  {
40ec: ef,65,f5            call  3654             Srolav3T(KEptzer,EVP_Raw,97f0);
40ef: ee,07,16,01,48,d0   #args  
40f5: c3,01,ee,07,3e      stw   R3e,[R0+7ee]     KEptzer = R3e; } } } }            # Save result
40fa: 20,27               sjmp  4123             goto 4123; }
40fc: a3,01,ee,07,30      ldw   R30,[R0+7ee]     R30 = KEptzer;                    # filtered result EVP 2
4101: c3,72,84,30         stw   R30,[R72+84]     EPT_Filt = R30;                   # filtered result EVP 1
4105: 20,39               sjmp  4140             goto 4140;
4107: 37,a1,02            jnb   B7,Ra1,410c      if (Cranking = 1)  {
410a: 20,34               sjmp  4140             return; }
410c: ef,45,f5            call  3654             Srolav3T(EGR_Filt,Evp,9808);
410f: 02,01,70,01,60,d0   #args  
4115: c3,72,82,3e         stw   R3e,[R72+82]     EGR_Filt = R3e;                   # Store result
4119: 8b,72,a8,3e         cmpw  R3e,[R72+a8]     
411d: db,04               jc    4123             if (R3e > EVP_Def)  {
411f: c3,72,a8,3e         stw   R3e,[R72+a8]     EVP_Def = R3e; }
4123: ef,2e,f5            call  3654             Srolav3T(TP_Filt,TP,97f6);
4126: 00,01,aa,00,4e,d0   #args  
412c: c3,72,80,3e         stw   R3e,[R72+80]     TP_Filt = R3e;                    # Save result
4130: 89,08,07,ae         cmpw  Rae,708                                            # RPM <= 450 RPM ?
4134: d1,0a               jleu  4140             if ((uns) Rpmx4 <= 708) return;
4136: 8b,72,a6,3e         cmpw  R3e,[R72+a6]     
413a: db,04               jc    4140             if ((uns) R3e >= TPS_Min) return;
413c: c3,72,a6,3e         stw   R3e,[R72+a6]     TPS_Min = R3e;                    # update to smaller Min TP Closed position
4140: f0                  ret                    return;

#################################################################
# Check for RPM and Speed limiters
# Tasklist Routine at 2151, routine offset 26
# RPM values here are RPM * 4
# Overspeed RPM, sets stage 3 fuel limiter
#################################################################


  Check_spd_lim:
4141: 45,04,00,fc,42      ad3w  R42,Rfc,4        R42 = Halffuelon;                 # = 0x9a82 = 8000 rpm
4146: 8a,43,ae            cmpw  Rae,[R42++]      
4149: d1,03               jleu  414e             if ((uns) Rpmx4 > [R42++] )  {
414b: 91,08,2f            orb   R2f,8            Nlmt_flg = 1; }                   # > 8000 rpm - Half fuel ON
414e: 8a,43,ae            cmpw  Rae,[R42++]                                        # = 0x9a84 = 7500 RPM 
4151: db,03               jc    4156             if (Rpmx4 > [R42++])  {
4153: 71,f7,2f            an2b  R2f,f7           Nlmt_flg = 0; }                   # < 7500 rpm - Half fuel OFF
4156: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
415a: d7,07               jne   4163             if (0 = Vstype)  {                # tracking vehcle speed ? = 1
415c: 71,fb,e7            an2b  Re7,fb           Hspflg = 0;
415f: 71,fe,e7            an2b  Re7,fe           Fofflg = 0;
4162: f0                  ret                    return; }

4163: b3,74,3f,30         ldb   R30,[R74+3f]     R30 = Mph_FiltH;                  # vehicle speed filtered(1)
4167: 9a,43,30            cmpb  R30,[R42++]                                        # Speed Limiter A = FF ON
416a: d1,03               jleu  416f             if ((uns) R30 > [R42++] )  {      # jmp if speed < FF (ALWAYS)
416c: 91,20,25            orb   R25,20           Slq1 = 1; }
416f: 9a,43,30            cmpb  R30,[R42++]                                        # Speed Limiter A = FF OFF
4172: db,03               jc    4177             if (R30 > [R42++])  {             # jmp if speed < FF
4174: 71,df,25            an2b  R25,df           Slq1 = 0; }
4177: 9a,43,30            cmpb  R30,[R42++]                                        # Speed Limiter B = FF ON
417a: d9,0d               jgtu  4189             if ((uns) R30 > [R42++] ) goto 4189; # jump if speed <= ROM limit
417c: 38,e7,0a            jb    B0,Re7,4189      if (Fofflg = 1) goto 4189;
417f: 9a,42,30            cmpb  R30,[R42]                                          # Speed Limiter B = FF OFF
4182: db,08               jc    418c             if (R30 > [R42])  {               # jmp if speed >= ROM limit
4184: 71,ef,25            an2b  R25,ef           Slq2 = 0;
4187: 20,03               sjmp  418c             goto 418c;
4189: 91,10,25            orb   R25,10           Slq2 = 1; }
418c: 35,25,04            jnb   B5,R25,4193      if (Slq1 = 1)  {
418f: 91,01,e7            orb   Re7,1            Fofflg = 1;
4192: f0                  ret                    return; }

4193: 34,25,07            jnb   B4,R25,419d      if (Slq2 = 1)  {
4196: 91,04,e7            orb   Re7,4            Hspflg = 1;                       # 1 = High speed alternate fuel/spark
4199: 71,fe,e7            an2b  Re7,fe           Fofflg = 0;                       # 1 = fire alternate injectors
419c: f0                  ret                    return; }

419d: 71,fb,e7            an2b  Re7,fb           Hspflg = 0;
41a0: f0                  ret                    return;

#################################################################
# Update closed loop flags
# Update warm EGO flags
# Tasklist Routine at 2151, routine offset 28
#################################################################


  Update_clolp:
41a1: a3,fa,0e,30         ldw   R30,[Rfa+e]      R30 = LDMH;
41a5: 47,fa,10,30,32      ad3w  R32,R30,[Rfa+10] R32 = R30 + LDMHH;
41aa: 8b,74,e2,32         cmpw  R32,[R74+e2]                                       # 260 Volumetric Efficiency
41ae: d9,05               jgtu  41b5             if ((uns) R32 <= Perload)  {
41b0: 91,01,e9            orb   Re9,1            Prld_ff = 1;                      # set LDFlag
41b3: 20,09               sjmp  41be             goto 41be; }
41b5: 8b,74,e2,30         cmpw  R30,[R74+e2]                                       # 260 Volumetric Efficiency
41b9: d1,03               jleu  41be             if ((uns) R30 > Perload )  {
41bb: 71,fe,e9            an2b  Re9,fe           Prld_ff = 0; }                    # clr LDFlag
41be: 30,e9,21            jnb   B0,Re9,41e2      if (Prld_ff = 1)  {               # LDFlag
41c1: 38,d0,1e            jb    B0,Rd0,41e2      if (B0_Apt = 0)  {                # WOT flag?
41c4: 9b,fa,0a,b0         cmpb  Rb0,[Rfa+a]                                        # Engine Temp 254 degrees F ?
41c8: da,18               jle   41e2             if ((uns) ECT < Ldel)  {
41ca: 9b,fa,0b,b0         cmpb  Rb0,[Rfa+b]                                        # Engine Temp 220 degrees F ?
41ce: d6,12               jge   41e2             if (ECT < Ldeh)  {
41d0: b3,72,c5,42         ldb   R42,[R72+c5]     R42 = Lugtmr;
41d4: 9b,fa,0d,42         cmpb  R42,[Rfa+d]      
41d8: d3,08               jnc   41e2             if ((uns) R42 >= LDLTM)  {
41da: 31,ef,05            jnb   B1,Ref,41e2      if (Wmegol = 1)  {                # jmp if not WMEGOL
41dd: 91,02,e9            orb   Re9,2            Ldflg = 1;
41e0: 20,03               sjmp  41e5             goto 41e5; } } } } } }
41e2: 71,fd,e9            an2b  Re9,fd           Ldflg = 0;
41e5: 45,0e,00,fc,30      ad3w  R30,Rfc,e        R30 = 9a8c;
41ea: ef,62,f5            call  374f             Check_Timers();
41ed: db,10               jc    41ff             if (R30 > 0)  {
41ef: b3,74,26,30         ldb   R30,[R74+26]     R30 = Egosss;
41f3: 9b,fc,1a,30         cmpb  R30,[Rfc+1a]                                       # EGOCL1 = 1
41f7: d3,06               jnc   41ff             if ((uns) R30 >= [9a98])  {
41f9: 91,04,ef            orb   Ref,4            Wrmego = 1;
41fc: 91,02,ef            orb   Ref,2            Wmegol = 1; } }
41ff: a3,fc,1c,32         ldw   R32,[Rfc+1c]     R32 = Min_cl_ld;                  # open loop min load(min load for OL control)
4203: 8b,74,de,32         cmpw  R32,[R74+de]                                       # engine load (VE? )
4207: db,05               jc    420e             if (R32 > Load)  {
4209: 91,08,ee            orb   Ree,8            Qclol = 1;
420c: 20,0f               sjmp  421d             goto 421d; }
420e: 6b,fc,1e,32         sb2w  R32,[Rfc+1e]     R32 -= Min_ld_cl;                 # min load for closed loop
4212: d3,09               jnc   421d             if ((uns) R32 >= 0)  {
4214: 8b,74,de,32         cmpw  R32,[R74+de]                                       # engine load (VE? )
4218: d1,03               jleu  421d             if ((uns) R32 > Load )  {
421a: 71,f7,ee            an2b  Ree,f7           Qclol = 0; } }
421d: 45,2e,02,fc,32      ad3w  R32,Rfc,22e      R32 = 9cac;                       # Table 9CAC
4222: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4225: ef,d9,f3            call  3601             SUWordLU();
4228: 8b,74,e2,38         cmpw  R38,[R74+e2]     
422c: d1,05               jleu  4233             if ((uns) R38 > Perload )  {
422e: 91,01,29            orb   R29,1            Hltmr_Off = 1;
4231: 20,12               sjmp  4245             goto 4245; }
4233: 67,fc,20,38         ad2w  R38,[Rfc+20]     R38 += HLODH;                     # Upper LOAD Limit for Closed Loop Fuel Control,unitless
4237: d3,03               jnc   423c             if ((uns) R38 >= 0)  {
4239: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
423c: 8b,74,e2,38         cmpw  R38,[R74+e2]     
4240: db,03               jc    4245             if (R38 > Perload)  {
4242: 71,fe,29            an2b  R29,fe           Hltmr_Off = 0; }
4245: a3,fc,14,38         ldw   R38,[Rfc+14]     R38 = Openlpv;                    # open loop tp Voltage (throttle position to force open loop (TPS voltage - 1))
4249: 67,72,a6,38         ad2w  R38,[R72+a6]     R38 += TPS_Min;
424d: db,05               jc    4254             if ((uns) R38 >= 0) goto 4254;
424f: 88,aa,38            cmpw  R38,Raa          
4252: d3,05               jnc   4259             if ((uns) R38 >= TP)  {
4254: 91,04,29            orb   R29,4            Qtpclol = 1;
4257: 20,0e               sjmp  4267             goto 4267; }
4259: 67,fa,04,38         ad2w  R38,[Rfa+4]      R38 += Tp_Hysts2;                 # Hysteresis term to enter WOT mode
425d: db,08               jc    4267             if (R38 > 0)  {
425f: 88,aa,38            cmpw  R38,Raa          
4262: db,03               jc    4267             if (R38 > TP)  {
4264: 71,fb,29            an2b  R29,fb           Qtpclol = 0; } }
4267: 33,ee,49            jnb   B3,Ree,42b3      if (Qclol = 1)  {
426a: 32,29,46            jnb   B2,R29,42b3      if (Qtpclol = 1)  {
426d: 32,ef,43            jnb   B2,Ref,42b3      if (Wrmego = 1)  {
4270: 9b,fc,53,b3         cmpb  Rb3,[Rfc+53]     
4274: d7,3d               jne   42b3             if (Ppctr = Pipnum)  {
4276: 36,25,3a            jnb   B6,R25,42b3      if (Chkair = 1)  {
4279: 3a,e7,37            jb    B2,Re7,42b3      if (Hspflg = 0)  {
427c: 39,e9,34            jb    B1,Re9,42b3      if (Ldflg = 0)  {
427f: 30,d0,0a            jnb   B0,Rd0,428c      if (B0_Apt = 0) goto 428c;
4282: b3,72,c4,32         ldb   R32,[R72+c4]     R32 = Ctntmr;
4286: 9b,f4,72,32         cmpb  R32,[Rf4+72]     
428a: d9,27               jgtu  42b3             if ((uns) R32 <= Niold)  {
428c: 30,ec,06            jnb   B0,Rec,4295      if (Mfa_on = 0) goto 4295;
428f: 9b,f4,07,00         cmpb  R0,[Rf4+7]       
4293: d7,1e               jne   42b3             if (0 = Mfasw)  {
4295: 38,29,0a            jb    B0,R29,42a2      if (Hltmr_Off = 1) goto 42a2;
4298: b3,72,cc,32         ldb   R32,[R72+cc]     R32 = Hltmr;                      # High load timer - 1/8 seconds under high load so far
429c: 9b,fc,22,32         cmpb  R32,[Rfc+22]                                       # time at high load to force Open loop(seconds)
42a0: d9,11               jgtu  42b3             if ((uns) R32 <= Ol_time)  {
42a2: 32,ee,03            jnb   B2,Ree,42a8      if (Olflg = 1)  {
42a5: 91,01,eb            orb   Reb,1            Ol_cl_transition = 1; }
42a8: 71,fb,ee            an2b  Ree,fb           Olflg = 0;
42ab: b1,01,34            ldb   R34,1            R34 = 1;                          # 1 = closed loop control mode
42ae: c7,74,92,34         stb   R34,[R74+92]     Clflg = R34;
42b2: f0                  ret                    return; } } } } } } } } } }

42b3: 91,04,ee            orb   Ree,4            Olflg = 1;
42b6: c7,74,92,00         stb   R0,[R74+92]      Clflg = 0;                        # set open loop
42ba: b1,01,34            ldb   R34,1            R34 = 1;
42bd: c7,74,ea,34         stb   R34,[R74+ea]     Enpip1 = R34;                     # ENPIP1 = 1
42c1: c7,74,eb,34         stb   R34,[R74+eb]     Enpip2 = R34;                     # ENPIP2 = 1
42c5: f0                  ret                    return;


  Calc_Fuel_ratio:
42c6: 01,14               clrw  R14              R14 = 0;
42c8: 01,16               clrw  R16              R16 = 0;
42ca: 39,ed,21            jb    B1,Red,42ee      if (Legofg1 = 1) goto 42ee;
42cd: 71,fd,ee            an2b  Ree,fd           Egofl = 0;
42d0: 37,ea,03            jnb   B7,Rea,42d6      if (Egofl1 = 1)  {
42d3: 91,02,ee            orb   Ree,2            Egofl = 1; }
42d6: 71,fe,ee            an2b  Ree,fe           Swtfl = 0;
42d9: 33,27,03            jnb   B3,R27,42df      if (Swtfl1 = 1)  {
42dc: 91,01,ee            orb   Ree,1            Swtfl = 1; }
42df: 28,85               scall 4366             Sub11();
42e1: 38,ed,23            jb    B0,Red,4307      if (Legofg2 = 0)  {
42e4: af,fe,16,16         ldzbw R16,[Rfe+16]     R16 = (uns)No_hegos;              # no of HEGOs
42e8: 31,16,1c            jnb   B1,R16,4307      if (B1_R16 = 1)  {
42eb: ad,01,14            ldzbw R14,1            R14 = (uns)1;
42ee: 71,fd,ee            an2b  Ree,fd           Egofl = 0;
42f1: 36,ea,03            jnb   B6,Rea,42f7      if (Egofl2 = 1)  {
42f4: 91,02,ee            orb   Ree,2            Egofl = 1; }
42f7: 71,fe,ee            an2b  Ree,fe           Swtfl = 0;
42fa: 30,27,03            jnb   B0,R27,4300      if (Swtfl2 = 1)  {
42fd: 91,01,ee            orb   Ree,1            Swtfl = 1; }
4300: 28,64               scall 4366             Sub11();
4302: 39,ed,02            jb    B1,Red,4307      if (Legofg1 = 1) goto 4307;
4305: 20,08               sjmp  430f             goto 430f; } }
4307: a3,74,8c,42         ldw   R42,[R74+8c]     R42 = Lambse1;                    # Desired fuel ratio for the left side bank
430b: c3,74,8e,42         stw   R42,[R74+8e]     Lambse2 = R42;                    # Desired fuel ratio for the right side bank
430f: 3b,ec,16            jb    B3,Rec,4328      if (Refflg = 1) goto 4328;
4312: 33,26,1b            jnb   B3,R26,4330      if (Jmpflg = 1)  {
4315: 71,f7,26            an2b  R26,f7           Jmpflg = 0;
4318: 01,16               clrw  R16              R16 = 0;
431a: a3,fc,26,34         ldw   R34,[Rfc+26]     R34 = Lammin;
431e: 29,f3               scall 4513             Sub12();
4320: 07,16               incw  R16              R16++;
4322: 07,16               incw  R16              R16++;
4324: 29,ed               scall 4513             Sub12();
4326: 20,08               sjmp  4330             goto 4330;
4328: 3b,26,05            jb    B3,R26,4330      if (Jmpflg = 0)  {
432b: 91,08,26            orb   R26,8            Jmpflg = 1;
432e: 28,1b               scall 434b             Sub10(); } }
4330: 37,d0,0c            jnb   B7,Rd0,433f      if (Cl_thrtl = 1)  {
4333: b3,72,eb,38         ldb   R38,[R72+eb]     R38 = Isflag;
4337: 9b,72,ec,38         cmpb  R38,[R72+ec]     
433b: df,02               je    433f             if (R38 != Islast)  {
433d: 28,0c               scall 434b             Sub10(); } }
433f: 30,eb,23            jnb   B0,Reb,4365      if (Ol_cl_transition = 0) return;
4342: 9b,fe,0a,00         cmpb  R0,[Rfe+a]       
4346: df,1d               je    4365             if (0 = [9e64]) return;
4348: 71,fe,eb            an2b  Reb,fe           Ol_cl_transition = 0;

  Sub10:
434b: a1,00,80,42         ldw   R42,8000         R42 = 8000;
434f: b3,74,8d,30         ldb   R30,[R74+8d]     R30 = [20b];
4353: 37,30,04            jnb   B7,R30,435a      if (B7_R30 = 1)  {
4356: c3,74,8c,42         stw   R42,[R74+8c]     Lambse1 = R42; }
435a: b3,74,8f,30         ldb   R30,[R74+8f]     R30 = [20d];
435e: 37,30,04            jnb   B7,R30,4365      if (B7_R30 = 0) return;
4361: c3,74,8e,42         stw   R42,[R74+8e]     Lambse2 = R42; }
4365: f0                  ret                    return;

########



  Sub11:
4366: 45,92,00,fc,32      ad3w  R32,Rfc,92       R32 = Emm_rscale;                 # emission rpm scaling
436b: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
436e: ef,9b,f2            call  360c             UUWordLu();
4371: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
4374: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = Ldscale;                    # load scaling
4379: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
437d: ef,8c,f2            call  360c             UUWordLu();
4380: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
4383: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
4386: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
4389: ad,04,34            ldzbw R34,4            R34 = (uns)4;
438c: 45,4a,03,fc,38      ad3w  R38,Rfc,34a      R38 = Hego_bias;                  # HEGO BIAS
4391: ef,53,f3            call  36e7             STabLookup();
4394: c7,72,14,3b         stb   R3b,[R72+14]     Bias = R3b;                       # computed HEGO bias?
4398: bc,3b,1e            ldsbw R1e,R3b          R1e = (int)R3b;
439b: 01,18               clrw  R18              R18 = 0;
439d: 37,1f,04            jnb   B7,R1f,43a4      if (B7_R1f = 1)  {
43a0: 17,18               incb  R18              R18++;
43a2: 03,1e               negw  R1e              R1e = -R1e; }
43a4: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
43a7: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
43aa: ad,04,34            ldzbw R34,4            R34 = (uns)4;
43ad: 45,2a,03,fc,38      ad3w  R38,Rfc,32a      R38 = Hego_ampl;                  # Closed Loop Peak-to-Peak amplitude, lambdas.
43b2: ef,35,f3            call  36ea             UTabLookUp();
43b5: ac,3b,1a            ldzbw R1a,R3b          R1a = (uns)R3b;
43b8: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
43bb: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
43be: ad,04,34            ldzbw R34,4            R34 = (uns)4;
43c1: 45,0a,03,fc,38      ad3w  R38,Rfc,30a      R38 = Ex_pulse;                   # time delay from when fuel change made until the EGO sensor sees it
43c6: ef,21,f3            call  36ea             UTabLookUp();
43c9: b0,3b,1d            ldb   R1d,R3b          R1d = R3b;
43cc: b0,1a,3b            ldb   R3b,R1a          R3b = R1a;
43cf: a0,1e,38            ldw   R38,R1e          R38 = R1e;
43d2: 09,07,38            shlw  R38,7            R38 *= 80;
43d5: 9c,3b,38            divb  R38,R3b          R38 /= R3b;
43d8: dd,05               jv    43df             if (OVF = 1) goto 43df;
43da: 99,e6,38            cmpb  R38,e6           
43dd: d1,03               jleu  43e2             if ((uns) R38 > e6 )  {
43df: b1,e6,38            ldb   R38,e6           R38 = e6; }
43e2: b0,38,1c            ldb   R1c,R38          R1c = R38;
43e5: 30,ee,02            jnb   B0,Ree,43ea      if (Swtfl = 0) goto 43ea;
43e8: 20,71               sjmp  445b             goto 445b;
43ea: a0,1e,3c            ldw   R3c,R1e          R3c = R1e;
43ed: a0,1a,30            ldw   R30,R1a          R30 = R1a;
43f0: 09,02,30            shlw  R30,2            R30 *= 4;
43f3: 68,30,3c            sb2w  R3c,R30          R3c -= R30;
43f6: db,61               jc    4459             if (R3c > 0)  {
43f8: 03,3c               negw  R3c              R3c = -R3c;
43fa: 45,6e,01,f0,32      ad3w  R32,Rf0,16e      R32 = Fn339;
43ff: b0,1c,34            ldb   R34,R1c          R34 = R1c;
4402: ef,b2,f1            call  35b7             UUbyteLu();
4405: 38,18,05            jb    B0,R18,440d      if (B0_R18 = 1) goto 440d;
4408: 39,ee,07            jb    B1,Ree,4412      if (Egofl = 0)  {
440b: 20,03               sjmp  4410             goto 4410;
440d: 31,ee,02            jnb   B1,Ree,4412      if (Egofl = 1)  {
4410: 13,38               negb  R38              R38 = -R38; } }
4412: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
4415: ac,1d,38            ldzbw R38,R1d          R38 = (uns)R1d;
4418: 6d,c0,03,38         ml2w  R38,3c0          R38 *= Min_pip_dly;
441c: 8c,ae,38            divw  R38,Rae          R38 /= Rpmx4;
441f: d5,03               jnv   4424             if (OVF = 1)  {
4421: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
4424: 8c,38,3c            divw  R3c,R38          R3c /= R38;
4427: d5,03               jnv   442c             if (OVF = 1)  {
4429: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; }
442c: 4b,17,74,02,06,34   sb3w  R34,R6,[R16+274] R34 = IO_Timer - [R16+Tslamu1];
4432: 6d,44,28,34         ml2w  R34,2844         R34 *= 2844;
4436: 6c,36,3c            ml2w  R3c,R36          R3c *= R36;
4439: a3,17,0a,02,34      ldw   R34,[R16+20a]    R34 = [R16+Lambse1];              # 20A - LAMBSE1( )[divide by 32768]
443e: 39,ee,09            jb    B1,Ree,444a      if (Egofl = 1) goto 444a;
4441: 68,3e,34            sb2w  R34,R3e          R34 -= R3e;
4444: db,0c               jc    4452             if (R34 > 0)  {
4446: 01,34               clrw  R34              R34 = 0;
4448: 20,08               sjmp  4452             goto 4452;
444a: 64,3e,34            ad2w  R34,R3e          R34 += R3e;
444d: d3,03               jnc   4452             if ((uns) R34 >= 0)  {
444f: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; } }                # clamp overflow
4452: 28,aa               scall 44fe             Clamp_Lamda();                    # clamp R34 Lambda to ROM limits (19.0:1 to 10.98:1)
4454: c3,17,0a,02,34      stw   R34,[R16+20a]    [R16+Lambse1] = R34; }            # 20A - LAMBSE1( )[divide by 32768]
4459: 20,9d               sjmp  44f8             goto 44f8;
445b: a0,1a,3c            ldw   R3c,R1a          R3c = R1a;
445e: 09,02,3c            shlw  R3c,2            R3c *= 4;
4461: 45,78,01,f0,32      ad3w  R32,Rf0,178      R32 = Fn342;
4466: b0,1c,34            ldb   R34,R1c          R34 = R1c;
4469: 30,18,05            jnb   B0,R18,4471      if (B0_R18 = 0) goto 4471;
446c: 39,ee,0f            jb    B1,Ree,447e      if (Egofl = 0)  {
446f: 20,03               sjmp  4474             goto 4474;
4471: 31,ee,0a            jnb   B1,Ree,447e      if (Egofl = 1)  {
4474: 64,1e,3c            ad2w  R3c,R1e          R3c += R1e;
4477: 45,86,01,f0,32      ad3w  R32,Rf0,186      R32 = Fn344;
447c: 17,19               incb  R19              R19++; } }
447e: ef,36,f1            call  35b7             UUbyteLu();
4481: 6c,3c,38            ml2w  R38,R3c          R38 *= R3c;
4484: 0c,04,38            shrdw R38,4            R38 /= 10;
4487: b3,15,68,02,3c      ldb   R3c,[R14+268]    R3c = [R14+Enpip1];
448c: 9b,15,9c,00,3c      cmpb  R3c,[R14+9c]     
4491: db,05               jc    4498             if (R3c > [R14+9c])  {
4493: c7,15,9c,00,3c      stb   R3c,[R14+9c]     [R14+9c] = R3c; }
4498: af,15,9c,00,3c      ldzbw R3c,[R14+9c]     R3c = (uns)[R14+9c];
449d: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
44a0: af,15,68,02,38      ldzbw R38,[R14+268]    R38 = (uns)[R14+Enpip1];
44a5: 8c,38,3c            divw  R3c,R38          R3c /= R38;
44a8: a3,17,0a,02,34      ldw   R34,[R16+20a]    R34 = [R16+Lambse1];              # 20A - LAMBSE1( )[divide by 32768]
44ad: 39,ee,09            jb    B1,Ree,44b9      if (Egofl = 1) goto 44b9;
44b0: 68,3c,34            sb2w  R34,R3c          R34 -= R3c;
44b3: db,0c               jc    44c1             if (R34 > 0)  {
44b5: 01,34               clrw  R34              R34 = 0;
44b7: 20,08               sjmp  44c1             goto 44c1;
44b9: 64,3c,34            ad2w  R34,R3c          R34 += R3c;
44bc: d3,03               jnc   44c1             if ((uns) R34 >= 0)  {
44be: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; } }                # clamp overflow
44c1: 28,3b               scall 44fe             Clamp_Lamda();                    # clamp R34 Lambda to ROM limits (19.0:1 to 10.98:1)
44c3: c3,17,0a,02,34      stw   R34,[R16+20a]    [R16+Lambse1] = R34;              # 20A - LAMBSE1( )[divide by 32768]
44c8: c7,15,9c,00,00      stb   R0,[R14+9c]      [R14+9c] = 0;
44cd: ac,1d,3c            ldzbw R3c,R1d          R3c = (uns)R1d;
44d0: 09,01,3c            shlw  R3c,1            R3c *= 2;
44d3: b1,10,38            ldb   R38,10           R38 = 10;
44d6: 38,19,0b            jb    B0,R19,44e4      if (B0_R19 = 0)  {
44d9: 45,90,01,f0,32      ad3w  R32,Rf0,190      R32 = Fn346;
44de: b0,1c,34            ldb   R34,R1c          R34 = R1c;
44e1: ef,d3,f0            call  35b7             UUbyteLu(); }
44e4: 7f,fe,07,38         ml2b  R38,[Rfe+7]      R38 *= PIPsC;
44e8: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
44eb: 88,00,3e            cmpw  R3e,R0           
44ee: df,03               je    44f3             if (R3e != 0)  {
44f0: b1,ff,3d            ldb   R3d,ff           R3d = ff; }
44f3: c7,15,68,02,3d      stb   R3d,[R14+268]    [R14+Enpip1] = R3d;
44f8: c3,17,74,02,06      stw   R6,[R16+274]     [R16+Tslamu1] = IO_Timer;
44fd: f0                  ret                    return;
# clamp R34 Lambda to ROM limits

######



  Clamp_Lamda:
44fe: 8b,fc,24,34         cmpw  R34,[Rfc+24]                                       # LAMMAX (A/F ratio 19.0:1)
4502: d1,04               jleu  4508             if ((uns) R34 > Lammax )  {
4504: a3,fc,24,34         ldw   R34,[Rfc+24]     R34 = Lammax; }
4508: 8b,fc,26,34         cmpw  R34,[Rfc+26]                                       # LAMMIN (A/F ratio 10.98:1)
450c: db,04               jc    4512             if ((uns) R34 >= Lammin) return;
450e: a3,fc,26,34         ldw   R34,[Rfc+26]     R34 = Lammin; }
4512: f0                  ret                    return;

######



  Sub12:
4513: a3,17,0a,02,36      ldw   R36,[R16+20a]    R36 = [R16+Lambse1];              # 20A - LAMBSE1( )[divide by 32768]
4518: 6b,fc,74,36         sb2w  R36,[Rfc+74]     R36 -= LMBJMP;
451c: d3,05               jnc   4523             if ((uns) R36 < 0) goto 4523;
451e: 88,34,36            cmpw  R36,R34          
4521: db,03               jc    4526             if (R36 > R34)  {
4523: c0,36,34            stw   R34,R36          R36 = R34; }
4526: c3,17,0a,02,36      stw   R36,[R16+20a]    [R16+Lambse1] = R36;              # 20A - LAMBSE1( )[divide by 32768]
452b: f0                  ret                    return;

######



  Sub13:
452c: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = Ectflscale;                 # used for Table lookup
4531: b3,fc,35,36         ldb   R36,[Rfc+35]     R36 = [9ab3];
4535: 29,b1               scall 46e8             Sub14();
4537: 0a,07,34            asrw  R34,7            R34 /= 80;
453a: ef,6f,f0            call  35ac             subyteLU();
453d: b0,38,30            ldb   R30,R38          R30 = R38;
4540: 45,16,01,f0,32      ad3w  R32,Rf0,116      R32 = Fn072A;
4545: a3,74,e2,34         ldw   R34,[R74+e2]     R34 = Perload;                    # 260 Volumetric Efficiency
4549: ef,c0,f0            call  360c             UUWordLu();
454c: b0,38,32            ldb   R32,R38          R32 = R38;
454f: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4552: 45,72,01,fc,38      ad3w  R38,Rfc,172      R38 = 9bf0;                       # Base Fuel (A/F ratio) (ECT vs load)
4557: ef,81,f1            call  36db             UTabLu16();
455a: 45,ca,00,fc,32      ad3w  R32,Rfc,ca       R32 = Olactmult;                  # Open Loop Fuel Multiplier vs ACT
455f: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
4562: ef,47,f0            call  35ac             subyteLU();
4565: 5c,3b,38,3c         ml3b  R3c,R38,R3b      R3c = R38 * R3b;
4569: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = Ectflscale;
456e: b3,fc,36,36         ldb   R36,[Rfc+36]     R36 = [9ab4];
4572: 29,74               scall 46e8             Sub14();
4574: 0a,07,34            asrw  R34,7            R34 /= 80;
4577: ef,32,f0            call  35ac             subyteLU();
457a: b0,38,30            ldb   R30,R38          R30 = R38;
457d: 45,90,00,f0,32      ad3w  R32,Rf0,90       R32 = Fn018;
4582: b0,c8,34            ldb   R34,Rc8          R34 = Atmr1;
4585: ef,2f,f0            call  35b7             UUbyteLu();
4588: b0,38,32            ldb   R32,R38          R32 = R38;
458b: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
458e: 45,c2,01,fc,38      ad3w  R38,Rfc,1c2      R38 = 9c40;                       # Startup Fuel (A/F ratio)(ECT vs Time)
4593: ef,45,f1            call  36db             UTabLu16();
4596: 69,80,00,3a         sb2w  R3a,80           R3a -= 80;
459a: 08,02,3a            shrw  R3a,2            R3a /= 4;
459d: 68,3a,3c            sb2w  R3c,R3a          R3c -= R3a;
45a0: db,02               jc    45a4             if (R3c > 0)  {
45a2: 01,3c               clrw  R3c              R3c = 0; }
45a4: ad,80,38            ldzbw R38,80           R38 = (uns)80;
45a7: 31,e9,3f            jnb   B1,Re9,45e9      if (Ldflg = 1)  {
45aa: b3,74,83,42         ldb   R42,[R74+83]     R42 = Mult_bp212A;
45ae: 45,82,00,fa,32      ad3w  R32,Rfa,82       R32 = Sea_llug_ol_mult;           # Sea Level Lugging O/L Fuel Multiplier vs RPM
45b3: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
45b6: ef,53,f0            call  360c             UUWordLu();
45b9: 7c,38,42            ml2b  R42,R38          R42 *= R38;
45bc: 45,c8,00,f8,32      ad3w  R32,Rf8,c8       R32 = 94f8;
45c1: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # barometric pressure
45c5: ef,ef,ef            call  35b7             UUbyteLu();
45c8: b0,38,30            ldb   R30,R38          R30 = R38;
45cb: 45,9e,00,fa,32      ad3w  R32,Rfa,9e       R32 = Alt_lug_ol_mult;            # Altitude Lugging O/L Fuel Multiplier vs RPM
45d0: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
45d3: ef,36,f0            call  360c             UUWordLu();
45d6: 7c,30,38            ml2b  R38,R30          R38 *= R30;
45d9: 64,42,38            ad2w  R38,R42          R38 += R42;
45dc: db,06               jc    45e4             if ((uns) R38 >= 0) goto 45e4;
45de: 08,07,38            shrw  R38,7            R38 /= 80;
45e1: 30,39,03            jnb   B0,R39,45e7      if (B0_R39 = 1)  {
45e4: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; }
45e7: 20,a7               sjmp  4690             goto 4690; }
45e9: 36,26,0d            jnb   B6,R26,45f9      if (Dndsup = 1)  {
45ec: 37,d0,0a            jnb   B7,Rd0,45f9      if (Cl_thrtl = 1)  {
45ef: 3a,ef,07            jb    B2,Ref,45f9      if (Wrmego = 0)  {
45f2: 45,d6,00,fc,32      ad3w  R32,Rfc,d6       R32 = Cl_ol_fuel;                 # fuel closed throttle open loop multiply
45f7: 20,91               sjmp  468a             goto 468a; } } }
45f9: 32,26,2c            jnb   B2,R26,4628      if (Nflg = 1)  {
45fc: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]      
4600: da,26               jle   4628             if ((uns) Tcstrt < CtLow)  {
4602: 9b,f4,0a,ad         cmpb  Rad,[Rf4+a]      
4606: d6,20               jge   4628             if (Tcstrt < Cthin)  {
4608: 9b,f4,0c,c8         cmpb  Rc8,[Rf4+c]      
460c: db,1a               jc    4628             if (Atmr1 > Olmtd1)  {
460e: 45,ee,00,fc,32      ad3w  R32,Rfc,ee       R32 = 9b6c;
4613: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4616: ef,f3,ef            call  360c             UUWordLu();
4619: 7f,f4,0b,38         ml2b  R38,[Rf4+b]      R38 *= Numpr;
461d: 08,07,38            shrw  R38,7            R38 /= 80;
4620: 30,39,03            jnb   B0,R39,4626      if (B0_R39 = 1)  {
4623: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; }
4626: 20,68               sjmp  4690             goto 4690; } } } }
4628: 30,ec,4d            jnb   B0,Rec,4678      if (Mfa_on = 1)  {
462b: 9b,f4,07,00         cmpb  R0,[Rf4+7]       
462f: df,47               je    4678             if (0 != Mfasw)  {
4631: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # Table spark RPM scaling
4636: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4639: ef,d0,ef            call  360c             UUWordLu();
463c: a0,38,30            ldw   R30,R38          R30 = R38;
463f: 45,16,01,f0,32      ad3w  R32,Rf0,116      R32 = Fn072A;                     # Table 9016
4644: a3,74,e2,34         ldw   R34,[R74+e2]     R34 = Perload;                    # 260 Volumetric Efficiency
4648: ef,c1,ef            call  360c             UUWordLu();
464b: 09,04,38            shlw  R38,4            R38 *= 10;
464e: a0,38,32            ldw   R32,R38          R32 = R38;
4651: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4654: 45,93,00,f4,38      ad3w  R38,Rf4,93       R38 = Fn1328;                     # Manage Fuel Air Fuel Table, 10 x 8 Table of multipliers as a function of engine speed N and LOA
                                                                                   D
4659: ef,8e,f0            call  36ea             UTabLookUp();
465c: b3,74,82,38         ldb   R38,[R74+82]     R38 = Mult_bp311;
4660: 7c,3b,38            ml2b  R38,R3b          R38 *= R3b;
4663: 5f,74,f4,39,38      ml3b  R38,R39,[R74+f4] R38 = R39 * Mfamul;
4668: 09,02,38            shlw  R38,2            R38 *= 4;
466b: 55,80,39,38         ad3b  R38,R39,80       R38 = R39 + 80;
466f: d3,03               jnc   4674             if ((uns) R38 >= 0)  {
4671: b1,ff,38            ldb   R38,ff           R38 = ff; }
4674: 11,39               clrb  R39              R39 = 0;
4676: 20,18               sjmp  4690             goto 4690; } }
4678: 32,26,07            jnb   B2,R26,4682      if (Nflg = 1)  {                  # selects which "WOT Fuel Multiplier vs RPM" Table to use
467b: 45,ee,00,fc,32      ad3w  R32,Rfc,ee       R32 = 9b6c;                       # WOT Fuel Multiplier vs RPM 1
4680: 20,08               sjmp  468a             goto 468a; }
4682: 30,24,0b            jnb   B0,R24,4690      if (Wot = 1)  {
4685: 45,02,01,fc,32      ad3w  R32,Rfc,102      R32 = Wot_fuel_mlt;               # WOT Fuel Multiplier vs RPM 2
468a: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
468d: ef,7c,ef            call  360c             UUWordLu(); }
4690: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
4693: 0c,05,3c            shrdw R3c,5            R3c /= 20;
4696: 88,00,3e            cmpw  R3e,R0           
4699: df,03               je    469e             if (R3e != 0)  {
469b: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; }
469e: 6f,72,e8,3c         ml2w  R3c,[R72+e8]     R3c *= Lammul;                    # LAMBSE modifier?
46a2: 98,3f,00            cmpb  R0,R3f           
46a5: df,05               je    46ac             if (0 != R3f)  {
46a7: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff;
46aa: 20,03               sjmp  46af             goto 46af; }
46ac: 0c,08,3c            shrdw R3c,8            R3c /= 100;
46af: 6f,fa,12,3c         ml2w  R3c,[Rfa+12]     R3c *= Olflmult;                  # fuel open loop multiplier (LAMBSE)
46b3: 98,3f,00            cmpb  R0,R3f           
46b6: df,05               je    46bd             if (0 != R3f)  {
46b8: bd,ff,3e            ldsbw R3e,ff           R3e = (int)ff;
46bb: 20,03               sjmp  46c0             goto 46c0; }
46bd: 0d,08,3c            shldw R3c,8            R3c *= 100;
46c0: 32,e7,15            jnb   B2,Re7,46d8      if (Hspflg = 1)  {                # high speed flag?
46c3: 45,73,00,fa,32      ad3w  R32,Rfa,73       R32 = 981b;                       # Table (vehicle speed - LAMBSE)
46c8: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = Mph_FiltH;                  # vehicle speed filtered(1) (MPH) 2BC is 8.8 format VSS
46cc: ef,e8,ee            call  35b7             UUbyteLu();
46cf: a0,3e,3c            ldw   R3c,R3e          R3c = R3e;
46d2: 09,08,38            shlw  R38,8            R38 *= 100;
46d5: 6c,38,3c            ml2w  R3c,R38          R3c *= R38; }
46d8: 88,00,3e            cmpw  R3e,R0           
46db: d7,02               jne   46df             if (R3e = 0)  {
46dd: 07,3e               incw  R3e              R3e++; }
46df: c3,74,8c,3e         stw   R3e,[R74+8c]     Lambse1 = R3e;                    # Desired fuel ratio for the left side bank of injectors
46e3: c3,74,8e,3e         stw   R3e,[R74+8e]     Lambse2 = R3e;                    # Desired fuel ratio for the right side bank of injectors
46e7: f0                  ret                    return;

#################################################################
# temp something?
#################################################################


  Sub14:
46e8: fe,5c,b1,36,34      sml3b R34,R36,Rb1      R34 = R36 * ACT;                  # RB1 = ACT (ACT = RB1 * 4)
46ed: 13,36               negb  R36              R36 = -R36;
46ef: 75,7f,36            ad2b  R36,7f           R36 += 7f;
46f2: fe,7c,b0,36         sml2b R36,Rb0          R36 *= ECT;
46f6: bc,b0,38            ldsbw R38,Rb0          R38 = (int)ECT;
46f9: 64,38,36            ad2w  R36,R38          R36 += R38;
46fc: 64,36,34            ad2w  R34,R36          R34 += R36;
46ff: f0                  ret                    return;

#################################################################
# Adaptive something
# Tasklist Routine at 2151, routine offset 2A
#################################################################


  Adapt?:
4700: 3f,a1,14            jb    B7,Ra1,4717      if (Cranking = 0)  {
4703: 3a,a1,11            jb    B2,Ra1,4717      if (Undsp = 0)  {                 # Run/Underspeed Flag. (1 = Underspeed or CRANK, 0 = Run)
4706: 9b,fc,64,b0         cmpb  Rb0,[Rfc+64]                                       # ? ROM 9AE2=55
470a: de,0b               jlt   4717             if (ECT >= MinECT_adp)  {         # jump if ECT < 170 degrees Farenheit
470c: 9b,fc,65,b0         cmpb  Rb0,[Rfc+65]                                       #  ROM 9AE3=71
4710: d2,05               jgt   4717             if (ECT <= MaxECT_adp)  {         # jump if ECT > 226 degrees Farenheit
4712: 91,01,a1            orb   Ra1,1            Adptmr_On = 1;                    # set Adaptive Fuel Time Flag
4715: 20,07               sjmp  471e             goto 471e; } } } }
############## not at operating temp(too hot or cold)
4717: c3,72,ba,00         stw   R0,[R72+ba]      Adptmr = 0;
471b: 71,fe,a1            an2b  Ra1,fe           Adptmr_On = 0;                    # Adaptive Fuel Time Flag
471e: 51,f8,c5,38         an3b  R38,Rc5,f8       R38 = Fmem_flags & f8;
4722: df,02               je    4726             if (R38 = 0) goto 4726;
4724: 20,e9               sjmp  480f             goto 480f;
4726: 3a,ee,0a            jb    B2,Ree,4733      if (Olflg = 1) goto 4733;
4729: a3,72,ba,38         ldw   R38,[R72+ba]     R38 = Adptmr;
472d: 8b,fc,68,38         cmpw  R38,[Rfc+68]     
4731: db,02               jc    4735             if ((uns) R38 >= ADAPTIM) goto 4735;
4733: 20,da               sjmp  480f             goto 480f;
4735: 33,ec,25            jnb   B3,Rec,475d      if (Refflg = 0) goto 475d;
4738: b3,72,d7,30         ldb   R30,[R72+d7]     R30 = Iscflg;
473c: 99,01,30            cmpb  R30,1            
473f: d7,f2               jne   4733             if (R30 != 1) goto 4733;
4741: b3,72,eb,30         ldb   R30,[R72+eb]     R30 = Isflag;
4745: c7,74,12,30         stb   R30,[R74+12]     Coltbu = R30;                     # the column no of the Adaptive Learning Cell to be updated
4749: 11,a6               clrb  Ra6              Nrmces = 0;
474b: c4,a7,30            stb   R30,Ra7          Ra7 = R30;
474e: a1,08,00,30         ldw   R30,8            R30 = 8;
4752: c7,74,13,30         stb   R30,[R74+13]     Rowtbu = R30;
4756: c4,a9,30            stb   R30,Ra9          Ra9 = R30;
4759: 11,a8               clrb  Ra8              Nrmrld = 0;
475b: 20,4f               sjmp  47ac             goto 47ac;
475d: a3,72,d2,38         ldw   R38,[R72+d2]     R38 = Rannum;
4761: 6d,03,01,38         ml2w  R38,103          R38 *= Ranmul;
4765: c3,72,d2,38         stw   R38,[R72+d2]     Rannum = R38;
4769: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = Emm_lscale;                 # ECC Load Scaling - emission load scaling
476e: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
4772: ef,97,ee            call  360c             UUWordLu();
4775: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
4778: 65,80,00,38         ad2w  R38,80           R38 += 80;
477c: bf,72,d2,3a         ldsbw R3a,[R72+d2]     R3a = (int)Rannum;
4780: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
4783: c7,74,13,39         stb   R39,[R74+13]     Rowtbu = R39;
4787: c4,30,39            stb   R39,R30          R30 = R39;
478a: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # Table  spark RPM scaling
478f: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4792: ef,77,ee            call  360c             UUWordLu();
4795: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
4798: 65,80,00,38         ad2w  R38,80           R38 += 80;
479c: bf,72,d3,3a         ldsbw R3a,[R72+d3]     R3a = (int)[153];
47a0: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
47a3: c7,74,12,39         stb   R39,[R74+12]     Coltbu = R39;                     # Adaptive Learning Cell to be updated
47a7: 99,08,30            cmpb  R30,8            
47aa: db,63               jc    480f             if ((uns) R30 >= 8) goto 480f;
47ac: 7d,0a,30            ml2b  R30,a            R30 *= a;
47af: 77,74,12,30         ad2b  R30,[R74+12]     R30 += Coltbu;                    # Adaptive Learning Cell to be updated
47b3: 45,82,03,fc,38      ad3w  R38,Rfc,382      R38 = Lcellindx;
47b8: 64,30,38            ad2w  R38,R30          R38 += R30;
47bb: b2,38,38            ldb   R38,[R38]        R38 = [R38];
47be: 98,38,00            cmpb  R0,R38           
47c1: d2,1e               jgt   47e1             if (0 > R38) goto 47e1;
47c3: 4b,74,0e,a8,38      sb3w  R38,Ra8,[R74+e]  R38 = Nrmrld - Lstrow;
47c8: db,02               jc    47cc             if (R38 > 0)  {
47ca: 03,38               negw  R38              R38 = -R38; }
47cc: 8b,fc,6c,38         cmpw  R38,[Rfc+6c]     
47d0: d9,0f               jgtu  47e1             if ((uns) R38 > [9aea] ) goto 47e1;
47d2: 4b,74,10,a6,38      sb3w  R38,Ra6,[R74+10] R38 = Nrmces - Lstcol;
47d7: db,02               jc    47db             if (R38 > 0)  {
47d9: 03,38               negw  R38              R38 = -R38; }
47db: 8b,fc,6e,38         cmpw  R38,[Rfc+6e]     
47df: d1,0a               jleu  47eb             if ((uns) R38 > [9aec] )  {
47e1: c3,74,0e,a8         stw   Ra8,[R74+e]      Lstrow = Nrmrld;
47e5: c3,74,10,a6         stw   Ra6,[R74+10]     Lstcol = Nrmces;
47e9: 20,24               sjmp  480f             goto 480f; }
47eb: a3,72,0c,38         ldw   R38,[R72+c]      R38 = Aefuel;
47ef: 8b,fc,72,38         cmpw  R38,[Rfc+72]     
47f3: d9,1a               jgtu  480f             if ((uns) R38 > [9af0] ) goto 480f;
47f5: a0,9e,38            ldw   R38,R9e          R38 = Eftr;
47f8: 37,39,02            jnb   B7,R39,47fd      if (B7_R39 = 1)  {
47fb: 03,38               negw  R38              R38 = -R38; }
47fd: 8b,fc,76,38         cmpw  R38,[Rfc+76]     
4801: db,0c               jc    480f             if ((uns) R38 >= [9af4]) goto 480f;
4803: 9b,fc,66,b1         cmpb  Rb1,[Rfc+66]                                       # min act for adaptive control
4807: da,06               jle   480f             if (ACT <= Minact_adp) goto 480f;
4809: 9b,fc,67,b1         cmpb  Rb1,[Rfc+67]                                       # max act for adaptive control
480d: de,11               jlt   4820             if (ACT >= Maxact_adp)  {
480f: c3,01,b8,07,00      stw   R0,[R0+7b8]      KLpct1L = 0;
4814: c3,01,ba,07,00      stw   R0,[R0+7ba]      KLpct1R = 0;
4819: c3,01,b2,07,00      stw   R0,[R0+7b2]      KEgoct1 = 0;
481e: 20,76               sjmp  4896             return; }
4820: 33,27,0c            jnb   B3,R27,482f      if (Swtfl1 = 1)  {
4823: b3,01,b2,07,36      ldb   R36,[R0+7b2]     R36 = KEgoct1;
4828: 17,36               incb  R36              R36++;
482a: c7,01,b2,07,36      stb   R36,[R0+7b2]     KEgoct1 = R36; }
482f: 30,27,0c            jnb   B0,R27,483e      if (Swtfl2 = 1)  {
4832: b3,01,b3,07,36      ldb   R36,[R0+7b3]     R36 = KEgoct2;
4837: 17,36               incb  R36              R36++;
4839: c7,01,b3,07,36      stb   R36,[R0+7b3]     KEgoct2 = R36; }
483e: bf,72,14,38         ldsbw R38,[R72+14]     R38 = (int)Bias;                  # computed HEGO bias
4842: fe,6d,10,00,38      sml2w R38,10           R38 *= 10;
4847: 65,00,80,38         ad2w  R38,8000         R38 += 8000;
484b: a3,fc,6a,3a         ldw   R3a,[Rfc+6a]     R3a = [9ae8];
484f: b3,01,e0,07,14      ldb   R14,[R0+7e0]     R14 = Kwuctr;
4854: 9b,fc,7a,14         cmpb  R14,[Rfc+7a]     
4858: db,06               jc    4860             if (R14 > [9af8])  {
485a: b3,fc,79,14         ldb   R14,[Rfc+79]     R14 = [9af7];
485e: 20,04               sjmp  4864             goto 4864; }
4860: b3,fc,78,14         ldb   R14,[Rfc+78]     R14 = [9af6];
4864: 9b,01,b2,07,14      cmpb  R14,[R0+7b2]     
4869: db,0f               jc    487a             if (R14 > KEgoct1)  {
486b: 01,32               clrw  R32              R32 = 0;
486d: 01,3e               clrw  R3e              R3e = 0;                          # KAM index = 0
486f: a1,04,07,40         ldw   R40,704          R40 = Ktmtb100;
4873: 51,80,ea,36         an3b  R36,Rea,80       R36 = Flags_ea & 80;
4877: ef,1d,00            call  4897             Sub15(); }                        # KAM Table[R3E] write something?
487a: 9b,01,b3,07,14      cmpb  R14,[R0+7b3]     
487f: db,15               jc    4896             if ((uns) R14 >= KEgoct2) return;
4881: ad,02,32            ldzbw R32,2            R32 = (uns)2;
4884: ad,01,3e            ldzbw R3e,1            R3e = (uns)1;                     # KAM index = 1
4887: a1,5a,07,40         ldw   R40,75a          R40 = Ktmtb200;
488b: 51,40,ea,36         an3b  R36,Rea,40       R36 = Flags_ea & 40;
488f: a3,fc,6a,3a         ldw   R3a,[Rfc+6a]     R3a = [9ae8];
4893: ef,01,00            call  4897             Sub15();                          # KAM Table[R3E] write something?
4896: f0                  ret                    return;

################################################################
# R3E = ? error?
################################################################


  Sub15:
4897: 64,30,40            ad2w  R40,R30          R40 += R30;
489a: 98,00,36            cmpb  R36,R0           
489d: df,49               je    48e8             if (R36 = 0) goto 48e8;
489f: 64,38,3a            ad2w  R3a,R38          R3a += R38;
48a2: a3,33,0a,02,42      ldw   R42,[R32+20a]    R42 = [R32+Lambse1];              # 20A - LAMBSE1( )[divide by 32768]
48a7: 88,3a,42            cmpw  R42,R3a          
48aa: d3,3b               jnc   48e7             if ((uns) R42 < R3a) return;
48ac: b3,3f,ba,07,3c      ldb   R3c,[R3e+7ba]    R3c = [R3e+KLpct1R];              # KAM - read value from KAM Table
48b1: 17,3c               incb  R3c              R3c++;
48b3: c7,3f,ba,07,3c      stb   R3c,[R3e+7ba]    [R3e+KLpct1R] = R3c;              # KAM - write value back to KAM Table
48b8: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = Lcellindx;                  # 9E00 - read index ROM Table value
48bd: 64,30,34            ad2w  R34,R30          R34 += R30;
48c0: b2,34,3d            ldb   R3d,[R34]        R3d = [R34];
48c3: 19,01,3d            shlb  R3d,1            R3d *= 2;
48c6: 98,3d,3c            cmpb  R3c,R3d          
48c9: d1,1c               jleu  48e7             if ((uns) R3c <= R3d) return;
48cb: b2,40,36            ldb   R36,[R40]        R36 = [R40];
48ce: 9b,fc,70,36         cmpb  R36,[Rfc+70]                                       # ROM adaptive control min
48d2: d1,13               jleu  48e7             if ((uns) R36 <= Adp_ctl_min) return;
48d4: 15,36               decb  R36              R36--;
48d6: c6,40,36            stb   R36,[R40]        [R40] = R36;
48d9: c7,3f,ba,07,00      stb   R0,[R3e+7ba]     [R3e+KLpct1R] = 0;                # KAM Table store
48de: a3,01,02,07,36      ldw   R36,[R0+702]     R36 = KCsuml;                     # KAM checksum
48e3: 05,36               decw  R36              R36--;                            # update KAM cksum and return
48e5: 20,49               sjmp  4930             goto 4930; }
48e7: f0                  ret                    return;

48e8: 03,3a               negw  R3a              R3a = -R3a;
48ea: 64,38,3a            ad2w  R3a,R38          R3a += R38;
48ed: a3,33,0a,02,42      ldw   R42,[R32+20a]    R42 = [R32+Lambse1];              # 20A - LAMBSE1( )[divide by 32768]
48f2: 88,3a,42            cmpw  R42,R3a          
48f5: d9,43               jgtu  493a             if ((uns) R42 <= R3a)  {          # return
48f7: b3,3f,b8,07,3c      ldb   R3c,[R3e+7b8]    R3c = [R3e+KLpct1L];              # KAM - read indexed KAM value
48fc: 17,3c               incb  R3c              R3c++;                            # incr value
48fe: c7,3f,b8,07,3c      stb   R3c,[R3e+7b8]    [R3e+KLpct1L] = R3c;              # KAM - store back into KAM loc
4903: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = Lcellindx;                  # 9E00
4908: 64,30,34            ad2w  R34,R30          R34 += R30;
490b: b2,34,3d            ldb   R3d,[R34]        R3d = [R34];                      # pull value from ROM Table
490e: 19,01,3d            shlb  R3d,1            R3d *= 2;                         # byte << 1 (times 2)
4911: 98,3d,3c            cmpb  R3c,R3d          
4914: d1,24               jleu  493a             if ((uns) R3c <= R3d) return;
4916: b2,40,36            ldb   R36,[R40]        R36 = [R40];
4919: 9b,fc,71,36         cmpb  R36,[Rfc+71]                                       # adaptive control max
491d: db,1b               jc    493a             if ((uns) R36 >= Adp_ctl_max) return;
491f: 17,36               incb  R36              R36++;
4921: c6,40,36            stb   R36,[R40]        [R40] = R36;
4924: c7,3f,b8,07,00      stb   R0,[R3e+7b8]     [R3e+KLpct1L] = 0;                # KAM - store value into same loc as above
4929: a3,01,02,07,36      ldw   R36,[R0+702]     R36 = KCsuml;                     # KAM checksum
492e: 07,36               incw  R36              R36++;                            # incr cksum to match incr to value
4930: c3,01,02,07,36      stw   R36,[R0+702]     KCsuml = R36;                     # KAM checksum
4935: c7,3f,b2,07,00      stb   R0,[R3e+7b2]     [R3e+KEgoct1] = 0; }
493a: f0                  ret                    return;


  Sub16:
493b: ad,80,3a            ldzbw R3a,80           R3a = (uns)80;
493e: ad,80,40            ldzbw R40,80           R40 = (uns)80;
4941: 3f,a1,25            jb    B7,Ra1,4969      if (Cranking = 1) goto 4969;
4944: 31,ed,03            jnb   B1,Red,494a      if (Legofg1 = 0) goto 494a;
4947: 38,ed,1f            jb    B0,Red,4969      if (Legofg2 = 1) goto 4969;
494a: 33,ec,1e            jnb   B3,Rec,496b      if (Refflg = 1)  {
494d: 37,26,06            jnb   B7,R26,4956      if (Hcamfg = 0) goto 4956;
4950: 9b,fc,7c,00         cmpb  R0,[Rfc+7c]      
4954: d7,15               jne   496b             if (0 = [9afa])  {
4956: af,72,eb,30         ldzbw R30,[R72+eb]     R30 = (uns)Isflag;
495a: 75,50,30            ad2b  R30,50           R30 += 50;
495d: 29,28               scall 4a87             Sub17();
495f: af,33,04,07,3a      ldzbw R3a,[R32+704]    R3a = (uns)[R32+Ktmtb100];        # KAM Table 1 Lo byte of ?
4964: af,33,5a,07,40      ldzbw R40,[R32+75a]    R40 = (uns)[R32+Ktmtb200];        # KAM Table 2 Hi byte of ?
4969: 20,90               sjmp  49fb             goto 49fb; } }
496b: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # spark RPM scaling
4970: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4973: ef,96,ec            call  360c             UUWordLu();
4976: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
4979: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = Emm_lscale;                 # ECC Load Scaling - emission load scaling
497e: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
4982: ef,87,ec            call  360c             UUWordLu();
4985: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
4988: b0,a9,30            ldb   R30,Ra9          R30 = Ra9;
498b: 7d,0a,30            ml2b  R30,a            R30 *= a;
498e: 74,a7,30            ad2b  R30,Ra7          R30 += Ra7;
4991: 28,f4               scall 4a87             Sub17();
4993: b3,33,04,07,3c      ldb   R3c,[R32+704]    R3c = [R32+Ktmtb100];             # KAM Table 1 Lo byte of ?
4998: b3,33,5a,07,40      ldb   R40,[R32+75a]    R40 = [R32+Ktmtb200];             # KAM Table 2 Hi byte of ?
499d: 07,30               incw  R30              R30++;
499f: 28,e6               scall 4a87             Sub17();
49a1: b3,33,04,07,3d      ldb   R3d,[R32+704]    R3d = [R32+Ktmtb100];             # KAM Table 1 Lo byte of ?
49a6: b3,33,5a,07,41      ldb   R41,[R32+75a]    R41 = [R32+Ktmtb200];             # KAM Table 2 Hi byte of ?
49ab: 99,07,a9            cmpb  Ra9,7            
49ae: d3,08               jnc   49b8             if ((uns) Ra9 >= 7)  {
49b0: a0,3c,3e            ldw   R3e,R3c          R3e = R3c;
49b3: a0,40,42            ldw   R42,R40          R42 = R40;
49b6: 20,1d               sjmp  49d5             goto 49d5; }
49b8: 75,09,30            ad2b  R30,9            R30 += 9;
49bb: 28,ca               scall 4a87             Sub17();
49bd: b3,33,04,07,3e      ldb   R3e,[R32+704]    R3e = [R32+Ktmtb100];             # KAM Table 1 Lo byte of ?
49c2: b3,33,5a,07,42      ldb   R42,[R32+75a]    R42 = [R32+Ktmtb200];             # KAM Table 2 Hi byte of ?
49c7: 07,30               incw  R30              R30++;
49c9: 28,bc               scall 4a87             Sub17();
49cb: b3,33,04,07,3f      ldb   R3f,[R32+704]    R3f = [R32+Ktmtb100];             # KAM Table 1 Lo byte of ?
49d0: b3,33,5a,07,43      ldb   R43,[R32+75a]    R43 = [R32+Ktmtb200];             # KAM Table 2 Hi byte of ?
49d5: ac,a6,30            ldzbw R30,Ra6          R30 = (uns)Nrmces;
49d8: ac,a8,32            ldzbw R32,Ra8          R32 = (uns)Nrmrld;
49db: ad,02,34            ldzbw R34,2            R34 = (uns)2;
49de: a1,40,00,38         ldw   R38,40           R38 = 40;
49e2: ef,05,ed            call  36ea             UTabLookUp();
49e5: ac,3b,40            ldzbw R40,R3b          R40 = (uns)R3b;
49e8: ac,a6,30            ldzbw R30,Ra6          R30 = (uns)Nrmces;
49eb: ac,a8,32            ldzbw R32,Ra8          R32 = (uns)Nrmrld;
49ee: ad,02,34            ldzbw R34,2            R34 = (uns)2;
49f1: a1,3c,00,38         ldw   R38,3c           R38 = 3c;
49f5: ef,f2,ec            call  36ea             UTabLookUp();
49f8: ac,3b,3a            ldzbw R3a,R3b          R3a = (uns)R3b;
49fb: 65,80,00,3a         ad2w  R3a,80           R3a += 80;
49ff: 65,80,00,40         ad2w  R40,80           R40 += 80;
4a03: c3,01,b4,07,3a      stw   R3a,[R0+7b4]     Kamrf1 = R3a;
4a08: c3,01,b6,07,40      stw   R40,[R0+7b6]     Kamrf2 = R40;
4a0d: 38,ed,09            jb    B0,Red,4a19      if (Legofg2 = 1) goto 4a19;
4a10: b3,fe,16,30         ldb   R30,[Rfe+16]     R30 = No_hegos;
4a14: 99,01,30            cmpb  R30,1            
4a17: d7,0c               jne   4a25             if (R30 = 1)  {                   # jmp if the no of HEGOs != 1
# One HEGO case
4a19: a3,01,b4,07,30      ldw   R30,[R0+7b4]     R30 = Kamrf1;
4a1e: c3,01,b6,07,30      stw   R30,[R0+7b6]     Kamrf2 = R30;
# Two HEGO case (zero hegos? )
4a23: 20,0d               sjmp  4a32             goto 4a32; }
4a25: 31,ed,0a            jnb   B1,Red,4a32      if (Legofg1 = 1)  {
4a28: a3,01,b6,07,30      ldw   R30,[R0+7b6]     R30 = Kamrf2;
4a2d: c3,01,b4,07,30      stw   R30,[R0+7b4]     Kamrf1 = R30; }
4a32: 45,18,00,f0,32      ad3w  R32,Rf0,18       R32 = 8c18;
4a37: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
4a3a: ef,6f,eb            call  35ac             subyteLU();
4a3d: 9b,72,c7,38         cmpb  R38,[R72+c7]     
4a41: d9,1a               jgtu  4a5d             if ((uns) R38 <= Multmr)  {
4a43: a3,72,e8,30         ldw   R30,[R72+e8]     R30 = Lammul;
4a47: 89,00,01,30         cmpw  R30,100          
4a4b: df,10               je    4a5d             if (R30 != 100)  {
4a4d: d9,04               jgtu  4a53             if ((uns) R30 <= 100)  {
4a4f: 07,30               incw  R30              R30++;
4a51: 20,02               sjmp  4a55             goto 4a55; }
4a53: 05,30               decw  R30              R30--;
4a55: c3,72,e8,30         stw   R30,[R72+e8]     Lammul = R30;
4a59: c7,72,c7,00         stb   R0,[R72+c7]      Multmr = 0; } }
4a5d: b3,fe,02,32         ldb   R32,[Rfe+2]      R32 = TRLOAD;
4a61: 99,04,32            cmpb  R32,4            
4a64: d3,20               jnc   4a86             if ((uns) R32 < 4) return;
4a66: 32,ee,1d            jnb   B2,Ree,4a86      if (Olflg = 0) return;
4a69: 3e,26,05            jb    B6,R26,4a71      if (Dndsup = 0)  {
4a6c: 91,02,ec            orb   Rec,2            Neuflg = 1;
4a6f: 20,15               sjmp  4a86             return; }
4a71: 31,ec,12            jnb   B1,Rec,4a86      if (Neuflg = 0) return;
4a74: 71,fd,ec            an2b  Rec,fd           Neuflg = 0;
4a77: 45,4a,02,fc,32      ad3w  R32,Rfc,24a      R32 = 9cc8;
4a7c: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4a7f: ef,7f,eb            call  3601             SUWordLU();
4a82: c3,72,e8,38         stw   R38,[R72+e8]     Lammul = R38; }
4a86: f0                  ret                    return;

################################################################


  Sub17:
4a87: a0,30,32            ldw   R32,R30          R32 = R30;
4a8a: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = Lcellindx;
4a8f: 64,30,34            ad2w  R34,R30          R34 += R30;
4a92: be,34,34            ldsbw R34,[R34]        R34 = (int)[R34];
4a95: 37,35,05            jnb   B7,R35,4a9d      if (B7_R35 = 0) return;
4a98: 03,34               negw  R34              R34 = -R34;
4a9a: a0,34,32            ldw   R32,R34          R32 = R34; }
4a9d: f0                  ret                    return;


  Sub18:
4a9e: a3,fc,2e,30         ldw   R30,[Rfc+2e]     R30 = [9aac];
4aa2: 09,01,30            shlw  R30,1            R30 *= 2;
4aa5: 99,02,31            cmpb  R31,2            
4aa8: d1,04               jleu  4aae             if ((uns) R31 > 2 )  {
4aaa: a1,00,02,30         ldw   R30,200          R30 = Mult_bp311; }
4aae: 09,06,30            shlw  R30,6            R30 *= 40;
4ab1: b3,fc,31,34         ldb   R34,[Rfc+31]     R34 = InJPP;
4ab5: 7f,fc,32,34         ml2b  R34,[Rfc+32]     R34 *= Cyl_wrap;                  # no of cyls (8)
4ab9: 7f,fe,07,34         ml2b  R34,[Rfe+7]      R34 *= PIPsC;
4abd: 6c,ae,34            ml2w  R34,Rae          R34 *= Rpmx4;
4ac0: 0c,05,34            shrdw R34,5            R34 /= 20;
4ac3: 88,00,36            cmpw  R36,R0           
4ac6: df,03               je    4acb             if (R36 != 0)  {
4ac8: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
4acb: 6c,3c,30            ml2w  R30,R3c          R30 *= R3c;
4ace: 8c,34,30            divw  R30,R34          R30 /= R34;
4ad1: d5,03               jnv   4ad6             if (OVF = 0) return;
4ad3: bd,ff,30            ldsbw R30,ff           R30 = (int)ff; }
4ad6: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 2C - calc injector pulse width?
#################################################################


  Calc_Fuel:
4ad7: 01,3e               clrw  R3e              R3e = 0;
4ad9: 37,a1,51            jnb   B7,Ra1,4b2d      if (Cranking = 1)  {
4adc: 38,24,30            jb    B0,R24,4b0f      if (Wot = 0)  {
4adf: 45,d2,00,fa,32      ad3w  R32,Rfa,d2       R32 = Crnk_pw_ect;                # Cranking Fuel Pulse Width vs ECT
4ae4: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4ae7: ef,17,eb            call  3601             SUWordLU();
4aea: af,74,80,36         ldzbw R36,[R74+80]     R36 = (uns)Bp;                    # barometric pressure
4aee: 6c,36,38            ml2w  R38,R36          R38 *= R36;
4af1: 8d,ef,00,38         divw  R38,ef           R38 /= ef;
4af5: d5,03               jnv   4afa             if (OVF = 1)  {
4af7: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
4afa: c0,42,38            stw   R38,R42          R42 = R38;                        # injector pulse width?
4afd: 45,ba,00,fa,32      ad3w  R32,Rfa,ba       R32 = Crnk_pw_time;               # fuel crank pw multiply time
4b02: af,72,cf,34         ldzbw R34,[R72+cf]     R34 = (uns)Crktmr;
4b06: ef,03,eb            call  360c             UUWordLu();
4b09: 4c,42,38,3c         ml3w  R3c,R38,R42      R3c = R38 * R42;
4b0d: 29,ae               scall 4cbd             Sub26(); }                        # R3CL * 4 and clamped
4b0f: a3,f4,46,22         ldw   R22,[Rf4+46]     R22 = Low_slope;                  # injector slope low
4b13: c3,76,1a,3e         stw   R3e,[R76+1a]     Bgful1 = R3e;
4b17: c3,76,1c,3e         stw   R3e,[R76+1c]     Bgful2 = R3e;
4b1b: 4c,22,3e,3c         ml3w  R3c,R3e,R22      R3c = R3e * R22;
4b1f: 29,9c               scall 4cbd             Sub26();                          # R3CL * 4 and clamped
4b21: c3,72,16,3e         stw   R3e,[R72+16]     Lbmf_inj1 = R3e;
4b25: c3,72,18,3e         stw   R3e,[R72+18]     Lbmf_inj2 = R3e;
4b29: 71,df,e7            an2b  Re7,df           Ffulflg = 0;
4b2c: f0                  ret                    return; }

4b2d: 3b,2f,df            jb    B3,R2f,4b0f      if (Nlmt_flg = 1) goto 4b0f;
4b30: 32,ee,05            jnb   B2,Ree,4b38      if (Olflg = 1)  {
4b33: ef,f6,f9            call  452c             Sub13();
4b36: 20,03               sjmp  4b3b             goto 4b3b; }
4b38: ef,8b,f7            call  42c6             Calc_Fuel_ratio();
4b3b: a3,74,8c,38         ldw   R38,[R74+8c]     R38 = Lambse1;                    # Desired fuel ratio for the left bank
4b3f: 69,00,80,38         sb2w  R38,8000         R38 -= 8000;
4b43: c3,74,84,38         stw   R38,[R74+84]     Dslmbs1 = R38;
4b47: a3,74,8e,38         ldw   R38,[R74+8e]     R38 = Lambse2;                    # Desired fuel ratio for the right bank
4b4b: 69,00,80,38         sb2w  R38,8000         R38 -= 8000;
4b4f: c3,74,86,38         stw   R38,[R74+86]     Dslmbs2 = R38;
4b53: 2d,e6               scall 493b             Sub16();
4b55: ef,35,04            call  4f8d             Sub29();
4b58: ef,a2,01            call  4cfd             Sub27();

#################################################################
# Tasklist Routine at 2151, routine offset 8E Fall thru?
#################################################################

  Sub19:
4b5b: 01,16               clrw  R16              R16 = 0;
4b5d: 28,26               scall 4b85             Sub20();
4b5f: af,fe,16,16         ldzbw R16,[Rfe+16]     R16 = (uns)No_hegos;
4b63: 31,16,02            jnb   B1,R16,4b68      if (B1_R16 = 1)  {
4b66: 28,1d               scall 4b85             Sub20(); }
4b68: 9b,f2,02,00         cmpb  R0,[Rf2+2]       
4b6c: d7,13               jne   4b81             if (0 = Bfulsw)  {
4b6e: 38,26,10            jb    B0,R26,4b81      if (Imfmflg = 0)  {               # MAF input range error?
4b71: 3b,c5,0d            jb    B3,Rc5,4b81      if (Mfmflag = 0)  {
4b74: 38,e7,0a            jb    B0,Re7,4b81      if (Fofflg = 0)  {
4b77: 3a,e7,07            jb    B2,Re7,4b81      if (Hspflg = 0)  {
4b7a: 3b,25,04            jb    B3,R25,4b81      if (Fam_flg = 0)  {
4b7d: 91,20,e7            orb   Re7,20           Ffulflg = 1;
4b80: f0                  ret                    return; } } } } } }

4b81: 71,df,e7            an2b  Re7,df           Ffulflg = 0;
4b84: f0                  ret                    return;


  Sub20:
4b85: ef,02,02            call  4d8a             Sub28();
4b88: b1,40,38            ldb   R38,40           R38 = 40;
4b8b: 32,a1,0b            jnb   B2,Ra1,4b99      if (Undsp = 1)  {
4b8e: 45,f6,00,fa,32      ad3w  R32,Rfa,f6       R32 = 989e;                       # Table 989E
4b93: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
4b96: ef,13,ea            call  35ac             subyteLU(); }
4b99: 5c,38,40,14         ml3b  R14,R40,R38      R14 = R40 * R38;
4b9d: a0,a2,40            ldw   R40,Ra2          R40 = AM;
4ba0: 28,c6               scall 4c68             Sub21();
4ba2: c3,17,82,01,42      stw   R42,[R16+182]    [R16+Baseff1] = R42;
4ba7: 28,d6               scall 4c7f             Sub22();
4ba9: d6,03               jge   4bae             if (R14 < 0)  {
4bab: 6c,00,40            ml2w  R40,R0           R40 *= 0; }
4bae: 28,d8               scall 4c88             Sub23();
4bb0: c3,17,34,02,42      stw   R42,[R16+234]    [R16+Fuelflow1] = R42;            # set flags effecting 7XXX ad reads ?
4bb5: a0,42,1e            ldw   R1e,R42          R1e = R42;
4bb8: 01,1c               clrw  R1c              R1c = 0;
4bba: 0c,04,1c            shrdw R1c,4            R1c /= 10;
4bbd: af,fe,07,18         ldzbw R18,[Rfe+7]      R18 = (uns)PIPsC;
4bc1: 6c,ae,18            ml2w  R18,Rae          R18 *= Rpmx4;
4bc4: 0c,03,18            shrdw R18,3            R18 /= 8;
4bc7: 8c,18,1c            divw  R1c,R18          R1c /= R18;
4bca: d5,03               jnv   4bcf             if (OVF = 1)  {
4bcc: bd,ff,1c            ldsbw R1c,ff           R1c = (int)ff; }
4bcf: c3,17,96,01,1c      stw   R1c,[R16+196]    [R16+Lbmf_inj1] = R1c;
4bd4: 45,56,02,f4,32      ad3w  R32,Rf4,256      R32 = 922c;                       # Table 922C
4bd9: af,74,93,34         ldzbw R34,[R74+93]     R34 = (uns)Vbat;                  # Battery Voltage Level * 16
4bdd: ef,2c,ea            call  360c             UUWordLu();
4be0: 6c,ae,38            ml2w  R38,Rae          R38 *= Rpmx4;
4be3: 0c,01,38            shrdw R38,1            R38 /= 2;
4be6: 6c,00,1c            ml2w  R1c,R0           R1c *= 0;
4be9: a3,f4,46,22         ldw   R22,[Rf4+46]     R22 = Low_slope;                  # injector slope low
4bed: 88,3a,42            cmpw  R42,R3a          
4bf0: d1,15               jleu  4c07             if ((uns) R42 > R3a )  {
4bf2: 28,b2               scall 4ca6             Sub24();
4bf4: a0,30,1c            ldw   R1c,R30          R1c = R30;
4bf7: a3,f4,48,22         ldw   R22,[Rf4+48]     R22 = Hi_slope;                   # injector slope high
# mult R3C long times 4 and clam max to FFFF -FFFF
4bfb: 28,a9               scall 4ca6             Sub24();
4bfd: 48,30,1c,1e         sb3w  R1e,R1c,R30      R1e = R1c - R30;
4c01: 68,3a,42            sb2w  R42,R3a          R42 -= R3a;
4c04: a8,38,40            sbbw  R40,R38          R40 -= R38 - CY; }
4c07: 28,a5               scall 4cae             Sub25();
4c09: 64,1c,30            ad2w  R30,R1c          R30 += R1c;
4c0c: d3,03               jnc   4c11             if ((uns) R30 >= 0)  {
4c0e: bd,ff,30            ldsbw R30,ff           R30 = (int)ff; }
4c11: c3,17,94,03,30      stw   R30,[R16+394]    [R16+Bgful1] = R30;
4c16: 6c,00,40            ml2w  R40,R0           R40 *= 0;
4c19: 11,14               clrb  R14              R14 = 0;
4c1b: 28,62               scall 4c7f             Sub22();
4c1d: d6,09               jge   4c28             if (R40 < 0)  {
4c1f: 17,14               incb  R14              R14++;
4c21: 02,42               cplw  R42              R42 = ~R42;
4c23: 03,40               negw  R40              R40 = -R40;
4c25: a4,00,42            adcw  R42,R0           R42 += CY; }
4c28: 28,5e               scall 4c88             Sub23();
4c2a: 28,82               scall 4cae             Sub25();
4c2c: a1,ff,7f,32         ldw   R32,7fff         R32 = 7fff;
4c30: 88,32,30            cmpw  R30,R32          
4c33: d1,03               jleu  4c38             if ((uns) R30 > R32 )  {
4c35: a0,32,30            ldw   R30,R32          R30 = R32; }
4c38: 30,14,02            jnb   B0,R14,4c3d      if (Isl_acon = 1)  {
4c3b: 03,30               negw  R30              R30 = -R30; }
4c3d: 64,1e,30            ad2w  R30,R1e          R30 += R1e;
4c40: d5,07               jnv   4c49             if (OVF = 1)  {
4c42: a0,32,30            ldw   R30,R32          R30 = R32;
4c45: d6,02               jge   4c49             if (R30 < 0)  {
4c47: 03,30               negw  R30              R30 = -R30; } }
4c49: c3,17,9c,03,30      stw   R30,[R16+39c]    [R16+Ffulc1] = R30;
4c4e: a0,a2,40            ldw   R40,Ra2          R40 = AM;
4c51: 28,15               scall 4c68             Sub21();
4c53: 28,33               scall 4c88             Sub23();
4c55: 28,57               scall 4cae             Sub25();
4c57: a3,74,d4,32         ldw   R32,[R74+d4]     R32 = Archg;
4c5b: fa                  di                     disable ints;
4c5c: ff                  nop                    
4c5d: c3,17,98,03,30      stw   R30,[R16+398]    [R16+Ffulm1] = R30;
4c62: c3,76,26,32         stw   R32,[R76+26]     Archg_bg = R32;
4c66: fb                  ei                     enable ints;
4c67: f0                  ret                    return;


  Sub21:
4c68: 6d,7c,11,40         ml2w  R40,117c         R40 *= 117c;
4c6c: 8f,17,0a,02,40      divw  R40,[R16+20a]    R40 /= [R16+Lambse1];
4c71: d5,03               jnv   4c76             if (OVF = 1)  {
4c73: bd,ff,40            ldsbw R40,ff           R40 = (int)ff; }
4c76: 6f,17,b4,07,40      ml2w  R40,[R16+7b4]    R40 *= [R16+Kamrf1];
4c7b: 0d,05,40            shldw R40,5            R40 *= 20;
4c7e: f0                  ret                    return;


  Sub22:
4c7f: 67,76,2a,40         ad2w  R40,[R76+2a]     R40 += Aeftrffl;
4c83: a7,76,28,42         adcw  R42,[R76+28]     R42 += Aeftrff + CY;
4c87: f0                  ret                    return;


  Sub23:
4c88: 99,07,43            cmpb  R43,7            
4c8b: d1,05               jleu  4c92             if ((uns) R43 > 7 )  {
4c8d: bd,ff,42            ldsbw R42,ff           R42 = (int)ff;
4c90: 20,03               sjmp  4c95             goto 4c95; }
4c92: 0d,05,40            shldw R40,5            R40 *= 20;
4c95: 4c,14,42,40         ml3w  R40,R42,R14      R40 = R42 * R14;
4c99: 99,1f,43            cmpb  R43,1f           
4c9c: d1,04               jleu  4ca2             if ((uns) R43 > 1f )  {
4c9e: bd,ff,42            ldsbw R42,ff           R42 = (int)ff;
4ca1: f0                  ret                    return; }

4ca2: 0d,03,40            shldw R40,3            R40 *= 8;
4ca5: f0                  ret                    return;


  Sub24:
4ca6: a0,38,3c            ldw   R3c,R38          R3c = R38;
4ca9: a0,3a,3e            ldw   R3e,R3a          R3e = R3a;
4cac: 20,06               sjmp  4cb4             goto 4cb4;

  Sub25:
4cae: a0,40,3c            ldw   R3c,R40          R3c = R40;
4cb1: a0,42,3e            ldw   R3e,R42          R3e = R42;
4cb4: 0c,04,3c            shrdw R3c,4            R3c /= 10;
4cb7: 8c,22,3c            divw  R3c,R22          R3c /= R22;
4cba: 2d,e2               scall 4a9e             Sub18();
4cbc: f0                  ret                    return;


  Sub26:
4cbd: 99,3f,3f            cmpb  R3f,3f                                             # clamp max R3F to 3FFF
4cc0: d1,04               jleu  4cc6             if ((uns) R3f > 3f )  {
4cc2: a1,ff,3f,3e         ldw   R3e,3fff         R3e = 3fff; }
4cc6: 0d,02,3c            shldw R3c,2            R3c *= 4;
4cc9: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 1E
# update fuel comsumption for DOL
#################################################################


  Update_flDOL:
4cca: 9b,74,ce,00         cmpb  R0,[R74+ce]                                        # Fuel Sum High
4cce: d2,2c               jgt   4cfc             if (0 <= Fuel_sum_h)  {
4cd0: af,fc,31,14         ldzbw R14,[Rfc+31]     R14 = (uns)InJPP;                 # No of injectors fired by each output port.
4cd4: 6d,7c,1e,14         ml2w  R14,1e7c         R14 *= 1e7c;
4cd8: 01,18               clrw  R18              R18 = 0;
4cda: a1,00,02,1a         ldw   R1a,200          R1a = Mult_bp311;
4cde: 8c,14,18            divw  R18,R14          R18 /= R14;
4ce1: fa                  di                     disable ints;
4ce2: a3,74,cc,14         ldw   R14,[R74+cc]     R14 = Fuel_sum_l;
4ce6: af,74,ce,16         ldzbw R16,[R74+ce]     R16 = (uns)Fuel_sum_h;
4cea: 8c,18,14            divw  R14,R18          R14 /= R18;
4ced: c3,74,cc,16         stw   R16,[R74+cc]     Fuel_sum_l = R16;
4cf1: c7,74,ce,00         stb   R0,[R74+ce]      Fuel_sum_h = 0;
4cf5: 09,01,14            shlw  R14,1            R14 *= 2;
4cf8: 64,14,c6            ad2w  Rc6,R14          Dol_count += R14;                 # add to Data Output Link Count
4cfb: fb                  ei                     enable ints; }
4cfc: f0                  ret                    return;

##########################################################


  Sub27:
4cfd: 11,3e               clrb  R3e              R3e = 0;
4cff: 3e,26,16            jb    B6,R26,4d18      if (Dndsup = 0)  {
4d02: 9b,f4,08,00         cmpb  R0,[Rf4+8]       
4d06: df,10               je    4d18             if (0 != Cintsw)  {
4d08: 45,3f,00,fc,30      ad3w  R30,Rfc,3f       R30 = 9abd;                       # 9ABD - NITMR3 - ATMR1 timed delay to enter Closed Loop fuel after Hot start, sec. Range of 0 to
                                                                                    255 sec., accuracy 1 sec.
4d0d: ef,3f,ea            call  374f             Check_Timers();
4d10: db,06               jc    4d18             if (R30 > 0)  {
4d12: b3,f4,09,3f         ldb   R3f,[Rf4+9]      R3f = Cintv;
4d16: 20,64               sjmp  4d7c             goto 4d7c; } } }
4d18: 33,ef,0c            jnb   B3,Ref,4d27      if (Idlflg = 1)  {
4d1b: 9b,fc,3e,00         cmpb  R0,[Rfc+3e]      
4d1f: df,06               je    4d27             if (0 != [9abc])  {
4d21: b3,fc,3d,3f         ldb   R3f,[Rfc+3d]     R3f = [9abb];
4d25: 20,55               sjmp  4d7c             goto 4d7c; } }
4d27: 30,ec,06            jnb   B0,Rec,4d30      if (Mfa_on = 1)  {
4d2a: b3,fc,3c,3f         ldb   R3f,[Rfc+3c]     R3f = [9aba];
4d2e: 20,4c               sjmp  4d7c             goto 4d7c; }
4d30: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # spark RPM scaling
4d35: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4d38: ef,d1,e8            call  360c             UUWordLu();
4d3b: 08,04,38            shrw  R38,4            R38 /= 10;
4d3e: b0,38,30            ldb   R30,R38          R30 = R38;
4d41: 45,72,01,f4,32      ad3w  R32,Rf4,172      R32 = Inj_lt_scl;                 # injector time load scaling
4d46: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
4d4a: ef,bf,e8            call  360c             UUWordLu();
4d4d: b0,38,32            ldb   R32,R38          R32 = R38;
4d50: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4d53: 45,8a,01,f4,38      ad3w  R38,Rf4,18a      R38 = Inj_time;                   # Injector Timing (crank degrees)(RPM vs Load)
4d58: ef,80,e9            call  36db             UTabLu16();
4d5b: 11,3c               clrb  R3c              R3c = 0;
4d5d: b0,3b,3d            ldb   R3d,R3b          R3d = R3b;
4d60: 08,01,3c            shrw  R3c,1            R3c /= 2;
4d63: 6f,f4,26,3c         ml2w  R3c,[Rf4+26]     R3c *= Idkmul;
4d67: 67,f4,28,3e         ad2w  R3e,[Rf4+28]     R3e += Inj_dly;                   # injector delay global = 0
4d6b: d6,02               jge   4d6f             if (R3e < 0)  {
4d6d: 01,3e               clrw  R3e              R3e = 0; }
4d6f: 89,00,2d,3e         cmpw  R3e,2d00         
4d73: d1,04               jleu  4d79             if ((uns) R3e > 2d00 )  {
4d75: a1,00,2d,3e         ldw   R3e,2d00         R3e = 2d00; }
4d79: 09,02,3e            shlw  R3e,2            R3e *= 4;
4d7c: ef,d5,e8            call  3654             Srolav3T(Injdly,3e,9800);
4d7f: 80,01,3e,00,58,d0   #args  
4d85: c3,72,00,3e         stw   R3e,[R72+0]      Injdly = R3e;                     # Save filtered sensor output
4d89: f0                  ret                    return;


  Sub28:
4d8a: a3,fc,46,1a         ldw   R1a,[Rfc+46]     R1a = [9ac4];
4d8e: 8b,74,de,1a         cmpw  R1a,[R74+de]                                       # engine load (VE? )
4d92: d1,05               jleu  4d99             if ((uns) R1a > Load )  {
4d94: 91,80,e8            orb   Re8,80           Dcelq1 = 1;
4d97: 20,12               sjmp  4dab             goto 4dab; }
4d99: 67,fc,48,1a         ad2w  R1a,[Rfc+48]     R1a += [9ac6];
4d9d: d3,03               jnc   4da2             if ((uns) R1a >= 0)  {
4d9f: bd,ff,1a            ldsbw R1a,ff           R1a = (int)ff; }
4da2: 8b,74,de,1a         cmpw  R1a,[R74+de]                                       # engine load (VE? )
4da6: db,03               jc    4dab             if (R1a > Load)  {
4da8: 71,7f,e8            an2b  Re8,7f           Dcelq1 = 0; }
4dab: b3,fe,02,20         ldb   R20,[Rfe+2]      R20 = TRLOAD;
4daf: 99,02,20            cmpb  R20,2            
4db2: d3,03               jnc   4db7             if ((uns) R20 < 2) goto 4db7;
4db4: 37,e7,05            jnb   B7,Re7,4dbc      if (Ndsflg = 1)  {
4db7: 91,40,e8            orb   Re8,40           Dcelq2 = 1;
4dba: 20,0e               sjmp  4dca             goto 4dca; }
4dbc: 99,04,20            cmpb  R20,4            
4dbf: db,06               jc    4dc7             if ((uns) R20 >= 4) goto 4dc7;
4dc1: 9b,fc,4e,cc         cmpb  Rcc,[Rfc+4e]     
4dc5: d3,03               jnc   4dca             if ((uns) Nddtim >= [9acc])  {
4dc7: 71,bf,e8            an2b  Re8,bf           Dcelq2 = 0; }
4dca: 9b,fc,52,cd         cmpb  Rcd,[Rfc+52]     
4dce: d1,05               jleu  4dd5             if ((uns) Nactmr > [9ad0] )  {
4dd0: 91,20,e8            orb   Re8,20           Dcelq3 = 1;
4dd3: 20,08               sjmp  4ddd             goto 4ddd; }
4dd5: 98,00,cd            cmpb  Rcd,R0           
4dd8: df,03               je    4ddd             if (Nactmr != 0)  {
4dda: 71,df,e8            an2b  Re8,df           Dcelq3 = 0; }
4ddd: 11,18               clrb  R18              R18 = 0;
4ddf: b3,72,e6,19         ldb   R19,[R72+e6]     R19 = Dsdrpm;
4de3: 08,02,18            shrw  R18,2            R18 /= 4;
4de6: 48,18,ae,18         sb3w  R18,Rae,R18      R18 = Rpmx4 - R18;
4dea: 8b,fc,56,18         cmpw  R18,[Rfc+56]     
4dee: da,05               jle   4df5             if ((uns) R18 < SHFRPM)  {
4df0: 91,10,e8            orb   Re8,10           Dcelq4 = 1;
4df3: 20,10               sjmp  4e05             goto 4e05; }
4df5: a3,fc,56,1a         ldw   R1a,[Rfc+56]     R1a = SHFRPM;
4df9: 6b,fc,58,1a         sb2w  R1a,[Rfc+58]     R1a -= SHMRPMH;
4dfd: 88,18,1a            cmpw  R1a,R18          
4e00: de,03               jlt   4e05             if (R1a >= R18)  {
4e02: 71,ef,e8            an2b  Re8,ef           Dcelq4 = 0; }
4e05: 8b,fc,4a,18         cmpw  R18,[Rfc+4a]     
4e09: da,05               jle   4e10             if ((uns) R18 < Minrpm_shut)  {
4e0b: 91,08,e8            orb   Re8,8            Dcelq5 = 1;
4e0e: 20,10               sjmp  4e20             goto 4e20; }
4e10: a3,fc,4a,1a         ldw   R1a,[Rfc+4a]     R1a = Minrpm_shut;                # min rpm decel fuel shutoff
4e14: 6b,fc,4c,1a         sb2w  R1a,[Rfc+4c]     R1a -= [9aca];
4e18: 88,18,1a            cmpw  R1a,R18          
4e1b: da,03               jle   4e20             if ((uns) R1a < R18)  {
4e1d: 71,f7,e8            an2b  Re8,f7           Dcelq5 = 0; }
4e20: b3,fc,5c,1a         ldb   R1a,[Rfc+5c]     R1a = DFSVS;
4e24: 9b,74,3f,1a         cmpb  R1a,[R74+3f]     
4e28: d9,05               jgtu  4e2f             if ((uns) R1a <= Mph_FiltH)  {
4e2a: 91,08,ca            orb   Rca,8            Dfsvs_hys_flag = 1;
4e2d: 20,0f               sjmp  4e3e             goto 4e3e; }
4e2f: 7b,fc,5d,1a         sb2b  R1a,[Rfc+5d]     R1a -= DFSVSH;
4e33: d3,09               jnc   4e3e             if ((uns) R1a >= 0)  {
4e35: 9b,74,3f,1a         cmpb  R1a,[R74+3f]     
4e39: d1,03               jleu  4e3e             if ((uns) R1a > Mph_FiltH )  {
4e3b: 71,f7,ca            an2b  Rca,f7           Dfsvs_hys_flag = 0; } }
4e3e: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
4e42: 8b,fc,5e,34         cmpw  R34,[Rfc+5e]     
4e46: db,05               jc    4e4d             if (R34 > [9adc])  {
4e48: 91,04,ca            orb   Rca,4            Dfldl_hys_flag = 1;
4e4b: 20,09               sjmp  4e56             goto 4e56; }
4e4d: 8b,fc,60,34         cmpw  R34,[Rfc+60]     
4e51: d1,03               jleu  4e56             if ((uns) R34 > [9ade] )  {
4e53: 71,fb,ca            an2b  Rca,fb           Dfldl_hys_flag = 0; }
4e56: 91,08,a1            orb   Ra1,8            Dmflg = 1;                        # Decel fuel low load timer enabled flag, 1 = Count up timer.
4e59: 37,d0,03            jnb   B7,Rd0,4e5f      if (Cl_thrtl = 0) goto 4e5f;
4e5c: 3a,ca,07            jb    B2,Rca,4e66      if (Dfldl_hys_flag = 0)  {
4e5f: 71,f7,a1            an2b  Ra1,f7           Dmflg = 0;
4e62: c7,72,d0,00         stb   R0,[R72+d0]      Dltmr = 0; }
4e66: 51,f8,c5,32         an3b  R32,Rc5,f8       R32 = Fmem_flags & f8;
4e6a: d7,74               jne   4ee0             if (R32 = 0)  {
4e6c: 45,6a,03,fc,32      ad3w  R32,Rfc,36a      R32 = Ol_fuel_mult;               # Open Loop Fuel Multiplier vs RPM
4e71: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
4e74: ef,95,e7            call  360c             UUWordLu();
4e77: a0,38,40            ldw   R40,R38          R40 = R38;
4e7a: 33,e8,63            jnb   B3,Re8,4ee0      if (Dcelq5 = 1)  {
4e7d: 38,ec,60            jb    B0,Rec,4ee0      if (Mfa_on = 0)  {
4e80: 3d,2a,5d            jb    B5,R2a,4ee0      if (Self_test = 0)  {
4e83: 9b,fc,45,b0         cmpb  Rb0,[Rfc+45]                                       # min ect decel fuel shutoff (140.0DegF)
4e87: d6,06               jge   4e8f             if (ECT >= Minect_shut) goto 4e8f;
4e89: 9b,f4,0d,c8         cmpb  Rc8,[Rf4+d]      
4e8d: d1,51               jleu  4ee0             if ((uns) Atmr1 > Agb )  {
4e8f: 33,a1,0a            jnb   B3,Ra1,4e9c      if (Dmflg = 0) goto 4e9c;
4e92: b3,72,d0,1a         ldb   R1a,[R72+d0]     R1a = Dltmr;
4e96: 9b,fc,62,1a         cmpb  R1a,[Rfc+62]     
4e9a: d3,3c               jnc   4ed8             if ((uns) R1a < [9ae0]) goto 4ed8;
4e9c: 37,d0,14            jnb   B7,Rd0,4eb3      if (Cl_thrtl = 0) goto 4eb3;
4e9f: 3f,e7,11            jb    B7,Re7,4eb3      if (Ndsflg = 1) goto 4eb3;
4ea2: 34,e8,0e            jnb   B4,Re8,4eb3      if (Dcelq4 = 0) goto 4eb3;
4ea5: 99,03,20            cmpb  R20,3            
4ea8: d9,09               jgtu  4eb3             if ((uns) R20 > 3 ) goto 4eb3;
4eaa: b3,fc,4f,1a         ldb   R1a,[Rfc+4f]     R1a = [9acd];
4eae: 98,cc,1a            cmpb  R1a,Rcc          
4eb1: d9,25               jgtu  4ed8             if ((uns) R1a > Nddtim ) goto 4ed8;
4eb3: 37,e8,2a            jnb   B7,Re8,4ee0      if (Dcelq1 = 1)  {
4eb6: 36,e8,27            jnb   B6,Re8,4ee0      if (Dcelq2 = 1)  {
4eb9: 33,ca,24            jnb   B3,Rca,4ee0      if (Dfsvs_hys_flag = 1)  {
4ebc: 9b,fc,63,00         cmpb  R0,[Rfc+63]      
4ec0: d7,16               jne   4ed8             if (0 != [9ae1]) goto 4ed8;
4ec2: 37,d0,1b            jnb   B7,Rd0,4ee0      if (Cl_thrtl = 1)  {
4ec5: b3,72,aa,1a         ldb   R1a,[R72+aa]     R1a = Cttmr;
4ec9: 9b,fc,50,1a         cmpb  R1a,[Rfc+50]     
4ecd: d3,11               jnc   4ee0             if ((uns) R1a >= [9ace])  {
4ecf: 3d,e8,06            jb    B5,Re8,4ed8      if (Dcelq3 = 1) goto 4ed8;
4ed2: 9b,fc,51,1a         cmpb  R1a,[Rfc+51]     
4ed6: d1,08               jleu  4ee0             if ((uns) R1a > [9acf] )  {
4ed8: 91,02,ca            orb   Rca,2            Declflg = 1;
4edb: b1,01,b3            ldb   Rb3,1            Ppctr = 1;
4ede: 20,07               sjmp  4ee7             goto 4ee7; } } } } } } } } } } }
4ee0: a1,80,00,40         ldw   R40,80           R40 = 80;
4ee4: 71,fd,ca            an2b  Rca,fd           Declflg = 0;
4ee7: 71,fd,27            an2b  R27,fd           Dfsflg = 0;
4eea: 89,00,00,40         cmpw  R40,0            
4eee: d7,03               jne   4ef3             if (R40 != 0) return;
4ef0: 91,02,27            orb   R27,2            Dfsflg = 1; }
4ef3: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset E
#################################################################


  Do_accelpump:
4ef4: 01,38               clrw  R38              R38 = 0;
4ef6: 37,a1,02            jnb   B7,Ra1,4efb      if (Cranking = 0) goto 4efb;
4ef9: 20,89               sjmp  4f84             goto 4f84;
4efb: b3,74,20,30         ldb   R30,[R74+20]     R30 = Tar;                        # scale and translated TAR
4eff: 9b,f4,34,30         cmpb  R30,[Rf4+34]     
4f03: d1,f4               jleu  4ef9             if ((uns) R30 <= Aetar) goto 4ef9;
4f05: 35,29,10            jnb   B5,R29,4f18      if (Aeoflg = 0) goto 4f18;
4f08: a3,74,de,42         ldw   R42,[R74+de]     R42 = Load;                       # engine load (VE? )
4f0c: 6b,74,9e,42         sb2w  R42,[R74+9e]     R42 -= Aeload;
4f10: d3,06               jnc   4f18             if ((uns) R42 < 0) goto 4f18;
4f12: 8b,f4,32,42         cmpw  R42,[Rf4+32]     
4f16: d1,6c               jleu  4f84             if ((uns) R42 > Aeacld )  {
4f18: 45,9e,00,f0,32      ad3w  R32,Rf0,9e       R32 = Fn019B;                     # Table 8C9E fuel tp scaling
4f1d: b3,74,20,34         ldb   R34,[R74+20]     R34 = Tar;                        # scale and translated TAR
4f21: ef,93,e6            call  35b7             UUbyteLu();
4f24: b0,38,30            ldb   R30,R38          R30 = R38;
4f27: 45,a8,00,f0,32      ad3w  R32,Rf0,a8       R32 = Fn020B;                     # Table 8CA8 fuel XX scaling (what is XX?)
4f2c: b3,f4,35,36         ldb   R36,[Rf4+35]     R36 = Frctae;
4f30: ef,b5,f7            call  46e8             Sub14();
4f33: 0a,07,34            asrw  R34,7            R34 /= 80;
4f36: ef,73,e6            call  35ac             subyteLU();
4f39: b0,38,32            ldb   R32,R38          R32 = R38;
4f3c: ad,08,34            ldzbw R34,8            R34 = (uns)8;
4f3f: 45,f5,01,f4,38      ad3w  R38,Rf4,1f5      R38 = Accelrich;                  # accel pump rate - (Deg/sec vs ECT)
4f44: ef,94,e7            call  36db             UTabLu16();
4f47: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
4f4a: 45,eb,01,f4,32      ad3w  R32,Rf4,1eb      R32 = Tpsaclrich;                 # Accelerator Enrichment Multiplier vs TP
4f4f: 4b,72,a6,aa,34      sb3w  R34,Raa,[R72+a6] R34 = TP - TPS_Min;               # RAA is Throttle position - 126 - RATCH=Closed TP
4f54: db,02               jc    4f58             if (R34 > 0)  {
4f56: 01,34               clrw  R34              R34 = 0; }
4f58: 08,08,34            shrw  R34,8            R34 /= 100;
4f5b: ef,59,e6            call  35b7             UUbyteLu();
4f5e: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
4f61: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
4f65: 45,a6,01,f0,32      ad3w  R32,Rf0,1a6      R32 = Fn378;                      # Table 90A6
4f6a: ef,4a,e6            call  35b7             UUbyteLu();
4f6d: 11,39               clrb  R39              R39 = 0;
4f6f: 6c,38,3c            ml2w  R3c,R38          R3c *= R38;
4f72: 0d,03,3c            shldw R3c,3            R3c *= 8;
4f75: a3,f4,2c,38         ldw   R38,[Rf4+2c]     R38 = Gaclmult;                   # accel pump multiplier
4f79: 6c,3e,38            ml2w  R38,R3e          R38 *= R3e;
4f7c: 98,00,3a            cmpb  R3a,R0           
4f7f: df,03               je    4f84             if (R3a != 0)  {
4f81: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; } }
4f84: 6d,22,02,38         ml2w  R38,222          R38 *= Egrper;
4f88: c3,72,0c,3a         stw   R3a,[R72+c]      Aefuel = R3a;
4f8c: f0                  ret                    return;


  Sub29:
4f8d: b3,f4,3e,18         ldb   R18,[Rf4+3e]     R18 = Meftra;
4f91: 3f,a1,09            jb    B7,Ra1,4f9d      if (Cranking = 1) goto 4f9d;
4f94: 3a,a1,06            jb    B2,Ra1,4f9d      if (Undsp = 1) goto 4f9d;
4f97: 9b,f4,3a,c8         cmpb  Rc8,[Rf4+3a]     
4f9b: db,07               jc    4fa4             if (Atmr1 > Tfctm)  {
4f9d: 71,f7,28            an2b  R28,f7           Efflg1 = 0;
4fa0: 01,38               clrw  R38              R38 = 0;
4fa2: 21,23               sjmp  50c7             goto 50c7; }
4fa4: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = Ectflscale;                 # Table 8CD2
4fa9: b3,f4,2a,36         ldb   R36,[Rf4+2a]     R36 = Alpha;
4fad: ef,38,f7            call  46e8             Sub14();
4fb0: 0a,07,34            asrw  R34,7            R34 /= 80;
4fb3: ef,f6,e5            call  35ac             subyteLU();
4fb6: ac,38,a6            ldzbw Ra6,R38          Nrmces = (uns)R38;
4fb9: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = Ldscale;                    # Table 8CFA load scaling
4fbe: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
4fc2: ef,47,e6            call  360c             UUWordLu();
4fc5: 08,04,38            shrw  R38,4            R38 /= 10;
4fc8: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
4fcb: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
4fce: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
4fd1: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4fd4: 45,ba,02,fc,38      ad3w  R38,Rfc,2ba      R38 = ECT_fuel;                   # Table 9D38
4fd9: ef,ff,e6            call  36db             UTabLu16();
4fdc: 5f,f4,3c,3b,40      ml3b  R40,R3b,[Rf4+3c] R40 = R3b * Mteftc;
4fe1: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
4fe4: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
4fe7: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4fea: 45,6a,02,fc,38      ad3w  R38,Rfc,26a      R38 = 9ce8;                       # Table 9CE8
4fef: ef,e9,e6            call  36db             UTabLu16();
4ff2: 5f,f4,3b,3b,3a      ml3b  R3a,R3b,[Rf4+3b] R3a = R3b * Mteisf;
4ff7: 08,01,3a            shrw  R3a,1            R3a /= 2;
4ffa: 33,28,14            jnb   B3,R28,5011      if (Efflg1 = 0) goto 5011;
4ffd: 31,27,29            jnb   B1,R27,5029      if (Dfsflg = 1)  {
5000: af,fc,44,38         ldzbw R38,[Rfc+44]     R38 = (uns)[9ac2];
5004: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
5007: 0d,09,38            shldw R38,9            R38 *= 200;
500a: d3,0e               jnc   501a             if ((uns) R38 >= 0)  {
500c: bd,ff,3a            ldsbw R3a,ff           R3a = (int)ff;
500f: 20,09               sjmp  501a             goto 501a;
5011: b3,f4,3d,14         ldb   R14,[Rf4+3d]     R14 = Tfcisw;
5015: 38,14,02            jb    B0,R14,501a      if (Isl_acon = 0)  {
5018: 01,3a               clrw  R3a              R3a = 0; } }
501a: c3,74,14,00         stw   R0,[R74+14]      Aisfl = 0;
501e: c3,74,16,3a         stw   R3a,[R74+16]     Aisf = R3a;
5022: 01,38               clrw  R38              R38 = 0;
5024: 91,08,28            orb   R28,8            Efflg1 = 1;
5027: 20,9e               sjmp  50c7             goto 50c7; }
5029: 4b,74,18,06,34      sb3w  R34,R6,[R74+18]  R34 = IO_Timer - Deltim;
502e: c3,74,18,06         stw   R6,[R74+18]      Deltim = IO_Timer;
5032: 6d,44,28,34         ml2w  R34,2844         R34 *= 2844;
5036: a0,36,34            ldw   R34,R36          R34 = R36;
5039: fe,6c,9e,34         sml2w R34,R9e          R34 *= Eftr;
503d: 67,74,14,34         ad2w  R34,[R74+14]     R34 += Aisfl;
5041: a7,74,16,36         adcw  R36,[R74+16]     R36 += Aisf + CY;
5045: c3,74,14,34         stw   R34,[R74+14]     Aisfl = R34;
5049: c3,74,16,36         stw   R36,[R74+16]     Aisf = R36;
504d: 11,18               clrb  R18              R18 = 0;
504f: 3b,ec,4e            jb    B3,Rec,50a0      if (Refflg = 0)  {
5052: 9b,72,d7,00         cmpb  R0,[R72+d7]      
5056: de,48               jlt   50a0             if (0 >= Iscflg)  {
5058: df,11               je    506b             if (0 = Iscflg) goto 506b;
505a: af,72,e6,30         ldzbw R30,[R72+e6]     R30 = (uns)Dsdrpm;
505e: 09,06,30            shlw  R30,6            R30 *= 40;
5061: 48,30,ae,30         sb3w  R30,Rae,R30      R30 = Rpmx4 - R30;
5065: 8b,f4,38,30         cmpw  R30,[Rf4+38]     
5069: de,35               jlt   50a0             if (R30 >= Tfsmn)  {
506b: 8b,74,16,3a         cmpw  R3a,[R74+16]     
506f: df,2f               je    50a0             if (R3a != Aisf)  {
5071: 4b,74,16,3a,34      sb3w  R34,R3a,[R74+16] R34 = R3a - Aisf;
5076: d9,02               jgtu  507a             if ((uns) R34 <= 0)  {
5078: 03,34               negw  R34              R34 = -R34; }
507a: 01,36               clrw  R36              R36 = 0;
507c: 0d,08,34            shldw R34,8            R34 *= 100;
507f: 88,00,3a            cmpw  R3a,R0           
5082: d7,05               jne   5089             if (R3a = 0)  {
5084: a0,36,34            ldw   R34,R36          R34 = R36;
5087: 20,03               sjmp  508c             goto 508c; }
5089: 8c,3a,34            divw  R34,R3a          R34 /= R3a;
508c: 8b,f4,40,34         cmpw  R34,[Rf4+40]     
5090: d1,0e               jleu  50a0             if ((uns) R34 > Tfcded )  {
5092: b3,f4,3e,18         ldb   R18,[Rf4+3e]     R18 = Meftra;
5096: 8b,74,16,3a         cmpw  R3a,[R74+16]     
509a: db,04               jc    50a0             if (R3a > Aisf)  {
509c: b3,f4,3f,18         ldb   R18,[Rf4+3f]     R18 = Meftrd; } } } } } }
50a0: 11,42               clrb  R42              R42 = 0;
50a2: 6b,74,16,3a         sb2w  R3a,[R74+16]     R3a -= Aisf;
50a6: db,04               jc    50ac             if (R3a > 0)  {
50a8: 17,42               incb  R42              R42++;
50aa: 03,3a               negw  R3a              R3a = -R3a; }
50ac: af,f4,36,38         ldzbw R38,[Rf4+36]     R38 = (uns)Kft;
50b0: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
50b3: 0d,01,38            shldw R38,1            R38 *= 2;
50b6: 8c,40,38            divw  R38,R40          R38 /= R40;
50b9: dd,03               jv    50be             if (OVF = 1) goto 50be;
50bb: 37,39,04            jnb   B7,R39,50c2      if (B7_R39 = 1)  {
50be: a1,ff,7f,38         ldw   R38,7fff         R38 = 7fff; }
50c2: 30,42,02            jnb   B0,R42,50c7      if (B0_R42 = 1)  {
50c5: 03,38               negw  R38              R38 = -R38; }
50c7: c0,9e,38            stw   R38,R9e          Eftr = R38;
50ca: 7d,78,18            ml2b  R18,78           R18 *= 78;
50cd: fe,6c,18,38         sml2w R38,R18          R38 *= R18;
50d1: 0d,01,38            shldw R38,1            R38 *= 2;
50d4: c3,72,08,3a         stw   R3a,[R72+8]      Eftrff = R3a;
50d8: 0e,01,38            asrdw R38,1            R38 /= 2;
50db: a3,72,0c,18         ldw   R18,[R72+c]      R18 = Aefuel;
50df: 08,01,18            shrw  R18,1            R18 /= 2;
50e2: 64,18,3a            ad2w  R3a,R18          R3a += R18;
50e5: c3,76,28,3a         stw   R3a,[R76+28]     Aeftrff = R3a;
50e9: c3,76,2a,38         stw   R38,[R76+2a]     Aeftrffl = R38;
50ed: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 2E
# Update fuel pump enable. Skip if flag set.
# turn pump off if more than 1 sec elapsed since last PIP occurred
#################################################################


  Update_fpump:
50ee: 38,d9,11            jb    B0,Rd9,5102      if (Vip_fp_override = 0)  {
50f1: a3,72,be,14         ldw   R14,[R72+be]     R14 = Tslpip;
50f5: 89,00,04,14         cmpw  R14,400          
50f9: d3,04               jnc   50ff             if ((uns) R14 >= 400)  {          # 1024 = 1 second
50fb: 71,7f,46            an2b  R46,7f           Pump = 0;
50fe: f0                  ret                    return; }

50ff: 91,80,46            orb   R46,80           Pump = 1; }
5102: f0                  ret                    return;

#################################################################


  Sub30:
5103: 3f,a1,28            jb    B7,Ra1,512e      if (Cranking = 1) goto 512e;
5106: 51,fa,c5,38         an3b  R38,Rc5,fa       R38 = Fmem_flags & fa;
510a: d7,22               jne   512e             if (R38 != 0) goto 512e;
510c: 45,1f,00,fa,30      ad3w  R30,Rfa,1f       R30 = 97c7;                       # Table 97C7
5111: ef,3b,e6            call  374f             Check_Timers();
5114: db,18               jc    512e             if ((uns) R30 >= 0) goto 512e;
5116: 38,d0,15            jb    B0,Rd0,512e      if (B0_Apt = 1) goto 512e;        # WOT flag
5119: 3e,e6,16            jb    B6,Re6,5132      if (Pfehp_flg = 0)  {
511c: a3,72,a8,38         ldw   R38,[R72+a8]     R38 = EVP_Def;
5120: 6b,fa,28,38         sb2w  R38,[Rfa+28]     R38 -= EGRDB;
5124: db,02               jc    5128             if (R38 > 0)  {
5126: 01,38               clrw  R38              R38 = 0; }
5128: 8b,72,96,38         cmpw  R38,[R72+96]                                       # compare to raw EVP AD value
512c: d3,04               jnc   5132             if ((uns) R38 >= EVP_Raw)  {
512e: 71,fe,28            an2b  R28,fe           Egren = 0;
5131: f0                  ret                    return; } }

5132: 91,01,28            orb   R28,1            Egren = 1;
5135: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 30
# EVP something 
#################################################################


  Calc_EVP:
5136: b3,fa,31,14         ldb   R14,[Rfa+31]     R14 = Egr_type;                   # 97D9 EGR Type contents = 00 - egr type ( 0=sonic, 1=PFE, 2=none)
513a: 30,14,03            jnb   B0,R14,5140      if (Isl_acon = 1)  {              # jmp if sonic or no EGR
513d: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # PFEHP FLG - sonic h/w present from calibration data
5140: 31,14,0c            jnb   B1,R14,514f      if (Isl_neut = 1)  {              # jmp if EGR = none or sonic
5143: 75,02,9a            ad2b  R9a,2            Bg_point += 2;                    # BG POINT
5146: c7,74,0a,00         stb   R0,[R74+a]       Em = 0;                           # 288 EM - EGR Mass Flow = zero
514a: c7,72,ee,00         stb   R0,[R72+ee]      Egract = 0;                       # 16E - EGRACT - Actual EGR percent = 100*EM/AMPEM.
514e: f0                  ret                    return; }

514f: 37,a1,03            jnb   B7,Ra1,5155      if (Cranking = 0) goto 5155;
5152: e7,0d,01            jump  5262             goto 5262;
5155: 3e,e6,03            jb    B6,Re6,515b      if (Pfehp_flg = 1) goto 515b;     # PFEHP FLG - sonic h/w present from calibration data
5158: e7,99,00            jump  51f4             goto 51f4;
515b: 45,08,01,fa,32      ad3w  R32,Rfa,108      R32 = 98b0;                       # Table 98B0 - BP correction for exhaust backpressure calculation, "Hg
5160: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
5164: ef,50,e4            call  35b7             UUbyteLu();
5167: c7,74,81,38         stb   R38,[R74+81]     Bpcor = R38;                      # 1FF - BPCOR - BP corrected
516b: a3,01,b4,07,34      ldw   R34,[R0+7b4]     R34 = Kamrf1;                     # KAMRF1 - Adaptive Fuel strategy correction factor. It is composed of the value LTMTB1rc + .5
5170: 6c,a2,34            ml2w  R34,Ra2          R34 *= AM;                        # RA2 = AM -> Air mass flow, (lb/min)
5173: 0c,07,34            shrdw R34,7            R34 /= 80;
5176: 88,00,36            cmpw  R36,R0           
5179: df,03               je    517e             if (R36 != 0)  {
517b: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
517e: 45,12,01,fa,32      ad3w  R32,Rfa,112      R32 = 98ba;                       # Table 98BA - Upstream pressure as a function of (AM * KAMREF). (KAMREF = Adaptive fuel correcti
                                                                                   on factor), "H20.
5183: ef,86,e4            call  360c             UUWordLu();
5186: 6d,00,ef,38         ml2w  R38,ef00         R38 *= ef00;
518a: b3,74,81,37         ldb   R37,[R74+81]     R37 = Bpcor;                      # 1FF - BPCOR - BP corrected
518e: 11,36               clrb  R36              R36 = 0;
5190: 08,01,36            shrw  R36,1            R36 /= 2;
5193: 8c,36,38            divw  R38,R36          R38 /= R36;
5196: d5,03               jnv   519b             if (OVF = 1)  {
5198: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
519b: c0,40,38            stw   R38,R40          R40 = R38;
519e: a3,72,84,30         ldw   R30,[R72+84]     R30 = EPT_Filt;                   # 104 - EPTBAR - Rolling average of the synchronously sampled EPT sensor (time constant = TCEPT),
                                                                                    secs
51a2: 08,01,30            shrw  R30,1            R30 /= 2;
51a5: a3,01,ee,07,32      ldw   R32,[R0+7ee]     R32 = KEptzer;                    # filtered EVP saved in KAM
51aa: 08,01,32            shrw  R32,1            R32 /= 2;
51ad: 68,32,30            sb2w  R30,R32          R30 -= R32;
51b0: a3,fa,2c,32         ldw   R32,[Rfa+2c]     R32 = XFREPT;                     # 97D4 - XFREPT - Transfer function of EPT sensor, " H20/counts
51b4: fe,6c,32,30         sml2w R30,R32          R30 *= R32;
51b8: 28,d9               scall 5293             Sub31();
51ba: 48,32,40,34         sb3w  R34,R40,R32      R34 = R40 - R32;
51be: 3f,33,06            jb    B7,R33,51c7      if (B7_R33 = 1) goto 51c7;
51c1: db,09               jc    51cc             if (R34 > 0)  {
51c3: 01,34               clrw  R34              R34 = 0;
51c5: 20,05               sjmp  51cc             goto 51cc;
51c7: d3,03               jnc   51cc             if ((uns) R34 >= 0)  {
51c9: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; } }
51cc: c3,72,f6,34         stw   R34,[R72+f6]     Delpr = R34;                      # 176 - DELPR - Pressure drop across the control orifice, " H20 = PE - DP
51d0: 45,b6,01,fa,32      ad3w  R32,Rfa,1b6      R32 = 995e;                       # Table 995E - EGR mass flow as a function of DELPR, lb/min.
51d5: ef,34,e4            call  360c             UUWordLu();
51d8: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
51dc: 7d,4b,34            ml2b  R34,4b           R34 *= 4b;
51df: 65,75,3a,34         ad2w  R34,3a75         R34 += 3a75;
51e3: 6c,34,38            ml2w  R38,R34          R38 *= R34;
51e6: 09,01,3a            shlw  R3a,1            R3a *= 2;
51e9: d3,03               jnc   51ee             if ((uns) R3a >= 0)  {
51eb: b1,ff,3b            ldb   R3b,ff           R3b = ff; }
51ee: c7,74,0a,3b         stb   R3b,[R74+a]      Em = R3b;                         # 288 EM - EGR Mass Flow
51f2: 20,3e               sjmp  5232             goto 5232;
51f4: 11,38               clrb  R38              R38 = 0;
51f6: 51,f8,c5,34         an3b  R34,Rc5,f8       R34 = Fmem_flags & f8;
51fa: d7,32               jne   522e             if (R34 = 0)  {
51fc: b3,72,d7,34         ldb   R34,[R72+d7]     R34 = Iscflg;                     # 157 - ISCFLG - ISC MODE Flag (1 = RPM CONTROL Mode)
5200: 99,01,34            cmpb  R34,1            
5203: de,06               jlt   520b             if (R34 < 1) goto 520b;
5205: 8b,74,90,00         cmpw  R0,[R74+90]                                        # 20E - DELOPT - Filtered desired EGR valve position.
5209: df,23               je    522e             if (0 != Delopt)  {
520b: a3,72,f0,34         ldw   R34,[R72+f0]     R34 = Evp;                        # 170 - EVP - EGR valve position reading in A/D counts.
520f: 6b,72,a8,34         sb2w  R34,[R72+a8]     R34 -= EVP_Def;                   # 128 - EOFF - The EGR valve reading when the valve is fully closed in A/D counts
5213: db,02               jc    5217             if (R34 > 0)  {
5215: 01,34               clrw  R34              R34 = 0; }
5217: 45,5c,01,fa,32      ad3w  R32,Rfa,15c      R32 = 9904;                       # Table 9904 - EGR mass flow as a function of EGR valve position (EVP -EOFF).
521c: 08,08,34            shrw  R34,8            R34 /= 100;
521f: ef,ea,e3            call  360c             UUWordLu();
5222: 7f,74,80,38         ml2b  R38,[R74+80]     R38 *= Bp;                        # BP - barometric pressure
5226: 9d,ef,38            divb  R38,ef           R38 /= ef;
5229: d5,03               jnv   522e             if (OVF = 1)  {
522b: b1,ff,38            ldb   R38,ff           R38 = ff; } } }
522e: c7,74,0a,38         stb   R38,[R74+a]      Em = R38;                         # 288 EM - EGR Mass Flow
5232: b3,74,0a,34         ldb   R34,[R74+a]      R34 = Em;                         # 288 EM - EGR Mass Flow
5236: 7d,c8,34            ml2b  R34,c8           R34 *= c8;
5239: 01,36               clrw  R36              R36 = 0;
523b: 0d,04,34            shldw R34,4            R34 *= 10;
523e: 8c,a4,34            divw  R34,Ra4          R34 /= Ampem;
5241: dd,06               jv    5249             if (OVF = 1) goto 5249;
5243: 89,ff,00,34         cmpw  R34,ff           
5247: d1,03               jleu  524c             if ((uns) R34 > ff )  {
5249: b1,ff,34            ldb   R34,ff           R34 = ff; }
524c: af,72,ee,32         ldzbw R32,[R72+ee]     R32 = (uns)Egract;                # old AD sensor value - EGRACT - Actual EGR percent = 100*EM/AMPEM.
5250: c7,72,ee,34         stb   R34,[R72+ee]     Egract = R34;                     # save new over old value 16E - EGRACT - Actual EGR percent = 100*EM/AMPEM.
5254: 11,35               clrb  R35              R35 = 0;
5256: 36,e6,09            jnb   B6,Re6,5262      if (Pfehp_flg = 1)  {             # PFEHP FLG - sonic h/w present from calibration data
5259: ef,02,e4            call  365e             Srolav1T(97ee);
525c: 46,d0               #args  
525e: c7,72,ee,3e         stb   R3e,[R72+ee]     Egract = R3e; }                   # filtered sensor output - EGRACT - Actual EGR percent = 100*EM/AMPEM.
5262: 2e,9f               scall 5103             Sub30();
5264: 71,7f,24            an2b  R24,7f           Tsegre_On = 0;
5267: b3,fa,2a,38         ldb   R38,[Rfa+2a]     R38 = egrmpt;                     # EGRMPT - Calibration time delay to ramp EGR in, secs.
526b: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]                                        # 9E5F - CTLOW - Temperature of Engine Coolant at Cold Startup, deg F.
526f: d2,0f               jgt   5280             if (Tcstrt > CtLow) goto 5280;
5271: 30,28,10            jnb   B0,R28,5284      if (Egren = 1)  {
5274: 91,80,24            orb   R24,80           Tsegre_On = 1;                    # set TSEGRE FLG -
5277: 9b,74,e6,38         cmpb  R38,[R74+e6]                                       # 264 timer TSEGRE - Accumulated time EGR is enabled.
527b: d9,07               jgtu  5284             if ((uns) R38 <= Tsegre)  {
527d: 71,7f,24            an2b  R24,7f           Tsegre_On = 0;                    # clr TSEGRE FLG -
5280: c7,74,e6,38         stb   R38,[R74+e6]     Tsegre = R38; } }                 # set 264 timer TSEGRE
5284: 3e,e6,25            jb    B6,Re6,52ac      if (Pfehp_flg = 0)  {             # PFEHP FLG - sonic h/w present from calibration data
5287: 38,28,22            jb    B0,R28,52ac      if (Egren = 0)  {                 # EGREN - Flag which indicates EGR enabled
528a: c7,72,ef,00         stb   R0,[R72+ef]      Egrate = 0;                       # 16F - EGRATE - Desired EGR rate in percent
528e: c3,74,90,00         stw   R0,[R74+90]      Delopt = 0;                       # 20E - DELOPT - Filtered desired EGR valve position.
5292: f0                  ret                    return;


  Sub31:
5293: 89,00,e7,32         cmpw  R32,e700         
5297: d6,05               jge   529e             if (R32 < e700)  {
5299: a1,00,9c,32         ldw   R32,9c00         R32 = 9c00;
529d: f0                  ret                    return; }

529e: 89,80,0c,32         cmpw  R32,c80          
52a2: da,04               jle   52a8             if ((uns) R32 < c80)  {
52a4: a1,80,0c,32         ldw   R32,c80          R32 = c80; }
52a8: 09,02,32            shlw  R32,2            R32 *= 4;
52ab: f0                  ret                    return; } }

52ac: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # Table 8CDE Engine speed N normalizing function
52b1: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
52b4: ef,55,e3            call  360c             UUWordLu();
52b7: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
52ba: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = Ldscale;                    # Input = LOAD and Output = Normalized load
52bf: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
52c3: ef,46,e3            call  360c             UUWordLu();
52c6: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
52c9: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
52cc: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
52cf: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
52d2: 45,06,02,fa,38      ad3w  R38,Rfa,206      R38 = Sea_l_EGR;                  # Table 99AE - Sea level EGR Table.
52d7: ef,10,e4            call  36ea             UTabLookUp();
52da: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
52dd: af,74,83,38         ldzbw R38,[R74+83]     R38 = (uns)Mult_bp212A;           # 201 - MULT BP212A - ?
52e1: ef,66,05            call  584a             Scale_R3c();
52e4: a0,3c,42            ldw   R42,R3c          R42 = R3c;
52e7: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
52ea: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
52ed: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
52f0: 45,56,02,fa,38      ad3w  R38,Rfa,256      R38 = alt_EGR;                    # Table 99FE - Altitude EGR Table.
52f5: ef,f2,e3            call  36ea             UTabLookUp();
52f8: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
52fb: 45,50,01,fa,32      ad3w  R32,Rfa,150      R32 = 98f8;                       # Table 98F8 - EGRALT multiplier as a function of Barometric Pressure BP.
5300: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
5304: ef,b0,e2            call  35b7             UUbyteLu();
5307: 11,39               clrb  R39              R39 = 0;
5309: ef,3e,05            call  584a             Scale_R3c();
530c: 64,42,3c            ad2w  R3c,R42          R3c += R42;
530f: 45,3a,01,fa,32      ad3w  R32,Rfa,13a      R32 = 98e2;                       # Table 98E2 - Multiplier as a function of ECT.
5314: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5317: ef,97,e2            call  35b1             SSByteLU();
531a: b0,38,3a            ldb   R3a,R38          R3a = R38;
531d: 45,74,01,fa,32      ad3w  R32,Rfa,174      R32 = 991c;                       # Table 991C - Multiplier as a function of Air Charge Temperature ACT.
5322: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
5325: ef,84,e2            call  35ac             subyteLU();
5328: 7c,3a,38            ml2b  R38,R3a          R38 *= R3a;
532b: 6c,3c,38            ml2w  R38,R3c          R38 *= R3c;
532e: 0d,03,38            shldw R38,3            R38 *= 8;
5331: 11,38               clrb  R38              R38 = 0;
5333: b3,fa,25,39         ldb   R39,[Rfa+25]     R39 = Egr_mult;                   # 97CD X EGR Table multplier.
5337: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
533a: b3,74,e6,39         ldb   R39,[R74+e6]     R39 = Tsegre;                     # 264 TSEGRE - Accumulated time EGR is enabled (sec)
533e: 11,38               clrb  R38              R38 = 0;
5340: 9f,fa,2a,38         divb  R38,[Rfa+2a]     R38 /= egrmpt;                    # 97D2 - EGRMPT - Calibration time delay to ramp EGR in, sec.
5344: dd,08               jv    534e             if (OVF = 0)  {
5346: 11,39               clrb  R39              R39 = 0;
5348: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
534b: 0d,08,38            shldw R38,8            R38 *= 100; }
534e: 30,ec,4e            jnb   B0,Rec,539f      if (Mfa_on = 1)  {                # MFAFLG - Managed Fuel Air State flag, set to 1 if MFA is being used.
5351: a0,3a,3c            ldw   R3c,R3a          R3c = R3a;
5354: 45,46,01,f0,32      ad3w  R32,Rf0,146      R32 = Fn083;                      # generates Table entry point. Input = N and Output = Normalized N.
5359: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
535c: ef,ad,e2            call  360c             UUWordLu();
535f: a0,38,30            ldw   R30,R38          R30 = R38;
5362: 45,32,01,f0,32      ad3w  R32,Rf0,132      R32 = Fn082;                      # generates Table entry point. Input = LOAD and Output = Normalized Load.
5367: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
536b: ef,9e,e2            call  360c             UUWordLu();
536e: a0,38,32            ldw   R32,R38          R32 = R38;
5371: ad,04,34            ldzbw R34,4            R34 = (uns)4;
5374: 45,a6,02,fa,38      ad3w  R38,Rfa,2a6      R38 = 9a4e;                       # Table 9A4E - Managed fuel Air EGR Table. X -input = FN083 - Normalized Engine Speed, RPM Y -inp
                                                                                   ut = FN082 - Normalized load. Output = Multiplier.
5379: ef,6e,e3            call  36ea             UTabLookUp();
537c: b3,74,82,38         ldb   R38,[R74+82]     R38 = Mult_bp311;
5380: 7c,3b,38            ml2b  R38,R3b          R38 *= R3b;
5383: 5f,74,f4,39,38      ml3b  R38,R39,[R74+f4] R38 = R39 * Mfamul;
5388: 03,38               negw  R38              R38 = -R38;
538a: 65,00,20,38         ad2w  R38,2000         R38 += 2000;
538e: 37,39,02            jnb   B7,R39,5393      if (B7_R39 = 1)  {
5391: 01,38               clrw  R38              R38 = 0; }
5393: 6c,3c,38            ml2w  R38,R3c          R38 *= R3c;
5396: 0d,03,38            shldw R38,3            R38 *= 8;
5399: d3,04               jnc   539f             if ((uns) R38 >= 0)  {
539b: a1,ff,ff,3a         ldw   R3a,ffff         R3a = ffff; } }
539f: 77,fa,24,3a         ad2b  R3a,[Rfa+24]     R3a += [97cc];
53a3: b4,00,3b            adcb  R3b,R0           R3b += CY;
53a6: 98,00,3b            cmpb  R3b,R0           
53a9: df,03               je    53ae             if (R3b != 0)  {
53ab: b1,ff,3a            ldb   R3a,ff           R3a = ff; }
53ae: c7,72,ef,3a         stb   R3a,[R72+ef]     Egrate = R3a;
53b2: 3e,e6,63            jb    B6,Re6,5418      if (Pfehp_flg = 0)  {
53b5: 98,00,3a            cmpb  R3a,R0           
53b8: d7,06               jne   53c0             if (R3a = 0)  {
53ba: c3,74,90,00         stw   R0,[R74+90]      Delopt = 0;
53be: 20,57               sjmp  5417             return; }
53c0: 5d,a4,3a,38         ml3b  R38,R3a,a4       R38 = R3a * a4;
53c4: 6c,a4,38            ml2w  R38,Ra4          R38 *= Ampem;
53c7: 0c,05,38            shrdw R38,5            R38 /= 20;
53ca: a0,3a,38            ldw   R38,R3a          R38 = R3a;
53cd: 6d,bc,03,38         ml2w  R38,3bc          R38 *= Sparek1;
53d1: af,74,80,34         ldzbw R34,[R74+80]     R34 = (uns)Bp;                    # BP - barometric pressure
53d5: 8c,34,38            divw  R38,R34          R38 /= R34;
53d8: dd,15               jv    53ef             if (OVF = 1) goto 53ef;
53da: 45,7e,01,fa,32      ad3w  R32,Rfa,17e      R32 = 9926;                       # Table 9926
53df: a0,38,34            ldw   R34,R38          R34 = R38;
53e2: ef,27,e2            call  360c             UUWordLu();
53e5: 09,08,38            shlw  R38,8            R38 *= 100;
53e8: 47,72,a8,38,34      ad3w  R34,R38,[R72+a8] R34 = R38 + EVP_Def;
53ed: d3,03               jnc   53f2             if ((uns) R34 >= 0)  {
53ef: bd,c0,34            ldsbw R34,c0           R34 = (int)c0; }
53f2: a3,72,a8,42         ldw   R42,[R72+a8]     R42 = EVP_Def;
53f6: 8b,74,90,42         cmpw  R42,[R74+90]     
53fa: d3,04               jnc   5400             if ((uns) R42 >= Delopt)  {
53fc: c3,74,90,42         stw   R42,[R74+90]     Delopt = R42; }
5400: ef,51,e2            call  3654             Srolav3T(Delopt,34,97e8);         # FILTER old, new, factor
5403: 0e,02,34,00,40,d0   #args  
5409: 89,80,e6,3e         cmpw  R3e,e680                                           # check result
540d: d1,04               jleu  5413             if ((uns) R3e > e680 )  {
540f: a1,80,e6,3e         ldw   R3e,e680         R3e = e680; }                     # clamp value if nec.
5413: c3,74,90,3e         stw   R3e,[R74+90]     Delopt = R3e;                     # save filtered output
5417: f0                  ret                    return; }

5418: 7d,a4,3a            ml2b  R3a,a4           R3a *= a4;
541b: a0,a4,38            ldw   R38,Ra4          R38 = Ampem;
541e: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
5421: c0,3c,3a            stw   R3a,R3c          R3c = R3a;
5424: 99,07,3b            cmpb  R3b,7            
5427: d1,05               jleu  542e             if ((uns) R3b > 7 )  {
5429: bd,ff,3a            ldsbw R3a,ff           R3a = (int)ff;
542c: 20,03               sjmp  5431             goto 5431; }
542e: 0d,05,38            shldw R38,5            R38 *= 20;
5431: c7,72,fe,3b         stb   R3b,[R72+fe]     Desem = R3b;
5435: a3,fa,36,32         ldw   R32,[Rfa+36]     R32 = [97de];
5439: 67,fa,38,32         ad2w  R32,[Rfa+38]     R32 += [97e0];
543d: 88,32,3c            cmpw  R3c,R32          
5440: d3,03               jnc   5445             if ((uns) R3c >= R32)  {
5442: 91,10,a1            orb   Ra1,10           Egonflg = 1; }
5445: 8b,fa,36,3c         cmpw  R3c,[Rfa+36]     
5449: db,03               jc    544e             if (R3c > [97de])  {
544b: 71,ef,a1            an2b  Ra1,ef           Egonflg = 0; }
544e: 38,28,02            jb    B0,R28,5453      if (Egren = 1) goto 5453;
5451: 20,69               sjmp  54bc             goto 54bc;
5453: 3c,a1,02            jb    B4,Ra1,5458      if (Egonflg = 1) goto 5458;
5456: 20,70               sjmp  54c8             goto 54c8;
5458: a0,3a,34            ldw   R34,R3a          R34 = R3a;
545b: 45,de,01,fa,32      ad3w  R32,Rfa,1de      R32 = 9986;                       # Table 9986
5460: ef,a9,e1            call  360c             UUWordLu();
5463: 6d,00,ef,38         ml2w  R38,ef00         R38 *= ef00;
5467: b3,74,80,37         ldb   R37,[R74+80]     R37 = Bp;                         # BP - barometric pressure
546b: 11,36               clrb  R36              R36 = 0;
546d: 8c,36,38            divw  R38,R36          R38 /= R36;
5470: d5,03               jnv   5475             if (OVF = 1)  {
5472: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
5475: 08,02,38            shrw  R38,2            R38 /= 4;
5478: 08,02,40            shrw  R40,2            R40 /= 4;
547b: 48,38,40,32         sb3w  R32,R40,R38      R32 = R40 - R38;
547f: 2e,12               scall 5293             Sub31();
5481: c0,34,32            stw   R32,R34          R34 = R32;
5484: a3,72,f4,32         ldw   R32,[R72+f4]     R32 = Desdp;                      # orig value
5488: a3,fa,42,36         ldw   R36,[Rfa+42]     R36 = [97ea];
548c: ef,db,e1            call  366a             FilterX();
548f: c3,72,f4,3e         stw   R3e,[R72+f4]     Desdp = R3e;                      # filtered value
5493: a3,fa,2e,38         ldw   R38,[Rfa+2e]     R38 = [97d6];
5497: fe,6c,3e,38         sml2w R38,R3e          R38 *= R3e;
549b: 0d,02,38            shldw R38,2            R38 *= 4;
549e: a3,01,ee,07,36      ldw   R36,[R0+7ee]     R36 = KEptzer;                    # filtered EVP saved in KAM
54a3: 08,01,36            shrw  R36,1            R36 /= 2;
54a6: 64,36,3a            ad2w  R3a,R36          R3a += R36;
54a9: d5,05               jnv   54b0             if (OVF = 1)  {
54ab: bd,ff,3a            ldsbw R3a,ff           R3a = (int)ff;
54ae: 20,07               sjmp  54b7             goto 54b7; }
54b0: d6,02               jge   54b4             if (R3a < 0)  {
54b2: 01,3a               clrw  R3a              R3a = 0; }
54b4: 09,01,3a            shlw  R3a,1            R3a *= 2;
54b7: c3,72,fc,3a         stw   R3a,[R72+fc]     Conpr = R3a;
54bb: f0                  ret                    return;

54bc: c7,74,0a,00         stb   R0,[R74+a]       Em = 0;                           # 288 EM - EGR Mass Flow
54c0: c7,72,ee,00         stb   R0,[R72+ee]      Egract = 0;
54c4: c7,72,ef,00         stb   R0,[R72+ef]      Egrate = 0;
54c8: c7,72,fe,00         stb   R0,[R72+fe]      Desem = 0;
54cc: a3,72,84,30         ldw   R30,[R72+84]     R30 = EPT_Filt;                   # 104 - EPTBAR
54d0: c3,72,fc,30         stw   R30,[R72+fc]     Conpr = R30;                      # 17C - CONPR
54d4: c3,72,f4,40         stw   R40,[R72+f4]     Desdp = R40;                      # 174 - DESDP
54d8: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 32
# EGR stuff
#################################################################


  Calc_EGR:
54d9: 3e,e6,63            jb    B6,Re6,553f      if (Pfehp_flg = 0)  {             # PFE HP flag
54dc: 8b,74,90,00         cmpw  R0,[R74+90]                                        # 20E - DELOPT
54e0: db,52               jc    5534             if (0 > Delopt)  {
54e2: a3,fa,28,30         ldw   R30,[Rfa+28]     R30 = EGRDB;                      # 97D0 - EGRDED
54e6: 67,72,a8,30         ad2w  R30,[R72+a8]     R30 += EVP_Def;                   # 128 - EOFF
54ea: d3,03               jnc   54ef             if ((uns) R30 >= 0)  {
54ec: bd,c0,30            ldsbw R30,c0           R30 = (int)c0; }
54ef: 8b,72,f0,30         cmpw  R30,[R72+f0]                                       # 170 - EVP
54f3: d3,0c               jnc   5501             if ((uns) R30 < Evp) goto 5501;
54f5: 3f,29,0c            jb    B7,R29,5504      if (Egrflg = 0)  {                # jmp if EGRFLG
54f8: a3,fa,26,d2         ldw   Rd2,[Rfa+26]     Egrdc = EGRDCOFF;                 # 97CE - DCOFF
54fc: 91,80,29            orb   R29,80           Egrflg = 1;
54ff: 20,03               sjmp  5504             goto 5504;
5501: 71,7f,29            an2b  R29,7f           Egrflg = 0; }
5504: a3,74,90,34         ldw   R34,[R74+90]     R34 = Delopt;
5508: 08,01,34            shrw  R34,1            R34 /= 2;
550b: a3,72,f0,32         ldw   R32,[R72+f0]     R32 = Evp;
550f: 08,01,32            shrw  R32,1            R32 /= 2;
5512: 68,32,34            sb2w  R34,R32          R34 -= R32;
5515: c3,72,f2,34         stw   R34,[R72+f2]     Egrerr = R34;
5519: 45,9a,01,fa,32      ad3w  R32,Rfa,19a      R32 = 9942;                       # Table 9942
551e: ef,e5,e0            call  3606             SSWordLU();
5521: 64,d2,38            ad2w  R38,Rd2          R38 += Egrdc;                     # EGRDC
5524: dd,08               jv    552e             if (OVF = 1) goto 552e;
5526: da,0c               jle   5534             if ((uns) R38 < 0)  {
5528: 89,33,73,38         cmpw  R38,7333         
552c: d1,04               jleu  5532             if ((uns) R38 > 7333 )  {
552e: a1,33,73,38         ldw   R38,7333         R38 = 7333; }
5532: 20,05               sjmp  5539             goto 5539; } }
5534: 01,38               clrw  R38              R38 = 0;
5536: 71,7f,29            an2b  R29,7f           Egrflg = 0;                       # clr EGRFLG
5539: a0,38,d2            ldw   Rd2,R38          Egrdc = R38;
553c: e7,48,00            jump  5587             goto Update_EGR2; }
553f: 9b,72,fe,00         cmpb  R0,[R72+fe]      
5543: df,3a               je    557f             if (0 = Desem) goto 557f;
5545: 3f,29,07            jb    B7,R29,554f      if (Egrflg = 0)  {
5548: a3,fa,26,d2         ldw   Rd2,[Rfa+26]     Egrdc = EGRDCOFF;
554c: 91,80,29            orb   R29,80           Egrflg = 1; }
554f: a3,72,fc,30         ldw   R30,[R72+fc]     R30 = Conpr;
5553: 08,01,30            shrw  R30,1            R30 /= 2;
5556: a3,72,84,34         ldw   R34,[R72+84]     R34 = EPT_Filt;
555a: 08,01,34            shrw  R34,1            R34 /= 2;
555d: 68,30,34            sb2w  R34,R30          R34 -= R30;
5560: c3,72,fa,34         stw   R34,[R72+fa]     Preser = R34;
5564: 45,9a,01,fa,32      ad3w  R32,Rfa,19a      R32 = 9942;
5569: ef,9a,e0            call  3606             SSWordLU();
556c: 64,d2,38            ad2w  R38,Rd2          R38 += Egrdc;
556f: dd,08               jv    5579             if (OVF = 1) goto 5579;
5571: da,0f               jle   5582             if (R38 <= 0) goto 5582;
5573: 89,33,73,38         cmpw  R38,7333         
5577: d1,0b               jleu  5584             if ((uns) R38 > 7333 )  {
5579: a1,33,73,38         ldw   R38,7333         R38 = 7333;
557d: 20,05               sjmp  5584             goto 5584;
557f: 71,7f,29            an2b  R29,7f           Egrflg = 0;
5582: 01,38               clrw  R38              R38 = 0; }
5584: c0,d2,38            stw   R38,Rd2          Egrdc = R38;

#################################################################
# Tasklist Routine at 2151, routine offset 6E
# Fall thru ?
# Update EGR stuff

#################################################################


  Update_EGR2:
5587: 98,00,d3            cmpb  Rd3,R0           
558a: d7,0f               jne   559b             if (Rd3 = 0)  {
558c: c7,74,a3,00         stb   R0,[R74+a3]      Egrcnt = 0;
5590: c7,74,a4,00         stb   R0,[R74+a4]      Egrper = 0;
5594: f0                  ret                    return;



5595: 0a,17,2c,40,58      ??                                                       # Never gets here ?

559a: 6e                  byte   6e

559b: ad,06,30            ldzbw R30,6            R30 = (uns)6;
559e: 9b,31,94,55,d3      cmpb  Rd3,[R30+5594]   
55a3: d9,03               jgtu  55a8             if ((uns) Rd3 > [R30+5594] ) goto 55a8;
55a5: e0,30,f6            djnz  R30,559e         R30--;
                                                 if (R30 != 0) goto 559e;
55a8: 09,0b,30            shlw  R30,b            R30 *= 800;
55ab: c7,74,a3,31         stb   R31,[R74+a3]     Egrcnt = R31;
55af: 11,30               clrb  R30              R30 = 0;
55b1: 9c,d3,30            divb  R30,Rd3          R30 /= Rd3;
55b4: dd,05               jv    55bb             if (OVF = 1) goto 55bb;
55b6: 99,c0,30            cmpb  R30,c0           
55b9: d1,03               jleu  55be             if ((uns) R30 > c0 )  {
55bb: b1,c0,30            ldb   R30,c0           R30 = c0; }
55be: c7,74,a4,30         stb   R30,[R74+a4]     Egrper = R30;
55c2: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 34
# Update spark advance
#################################################################


  Update_advance:
55c3: 3f,a1,03            jb    B7,Ra1,55c9      if (Cranking = 1) goto 55c9;
55c6: 32,a1,05            jnb   B2,Ra1,55ce      if (Undsp = 1)  {
55c9: b1,28,c2            ldb   Rc2,28           Saf = 28;
55cc: 22,43               sjmp  5811             goto 5811; }
55ce: 3a,28,02            jb    B2,R28,55d3      if (Newsa = 1) goto 55d3;
55d1: 22,3e               sjmp  5811             goto 5811;
55d3: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = Rpmscale;                   # Table 8CDE spark RPM scaling
55d8: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
55db: ef,2e,e0            call  360c             UUWordLu();
55de: a0,38,a6            ldw   Ra6,R38          Nrmces = R38;
55e1: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = Ldscale;                    # Table 8CFA load scaling
55e6: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
55ea: ef,1f,e0            call  360c             UUWordLu();
55ed: a0,38,a8            ldw   Ra8,R38          Nrmrld = R38;
55f0: 01,18               clrw  R18              R18 = 0;
55f2: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = Mph_FiltH;                  # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
55f6: 7f,f8,18,34         ml2b  R34,[Rf8+18]     R34 *= [9448];
55fa: a0,ae,36            ldw   R36,Rae          R36 = Rpmx4;
55fd: 08,03,36            shrw  R36,3            R36 /= 8;
5600: 88,36,34            cmpw  R34,R36          
5603: db,14               jc    5619             if (R34 > R36)  {
5605: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
5608: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
560b: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
560e: 45,90,02,f8,38      ad3w  R38,Rf8,290      R38 = 96c0;                       # Table 96C0 - Torque Reduction Table (auto trans protection)
5613: ef,d4,e0            call  36ea             UTabLookUp();
5616: ac,3b,18            ldzbw R18,R3b          R18 = (uns)R3b; }
5619: 3f,d0,02            jb    B7,Rd0,561e      if (Cl_thrtl = 1) goto 561e;
561c: 20,83               sjmp  56a1             goto 56a1;
561e: 45,90,00,f8,32      ad3w  R32,Rf8,90       R32 = 94c0;                       # Table Closed Throttle Spark advance (added, ECT->adv)
5623: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5626: ef,88,df            call  35b1             SSByteLU();
5629: bc,38,42            ldsbw R42,R38          R42 = (int)R38;
562c: 45,7c,00,f8,32      ad3w  R32,Rf8,7c       R32 = 94ac;                       # Table 94AC - Closed Throttle Base spark advance (RPM->adv)
5631: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
5634: ef,cf,df            call  3606             SSWordLU();
5637: 64,38,42            ad2w  R42,R38          R42 += R38;
563a: 67,f8,02,42         ad2w  R42,[Rf8+2]      R42 += Cl_th_spkadd;              # 9032 spark adder closed throttle
563e: a3,f8,06,38         ldw   R38,[Rf8+6]      R38 = [9436];
5642: 88,38,ae            cmpw  Rae,R38          
5645: d1,03               jleu  564a             if ((uns) Rpmx4 > R38 )  {
5647: 91,10,ed            orb   Red,10           Hcsdq = 1; }
564a: 6b,f8,08,38         sb2w  R38,[Rf8+8]      R38 -= [9438];
564e: 88,38,ae            cmpw  Rae,R38          
5651: db,03               jc    5656             if (Rpmx4 > R38)  {
5653: 71,ef,ed            an2b  Red,ef           Hcsdq = 0; }
5656: 34,ed,23            jnb   B4,Red,567c      if (Hcsdq = 1)  {
5659: 45,38,01,f8,32      ad3w  R32,Rf8,138      R32 = 9568;                       # Table 9568 Time since startup kicker time delay, sec. Input is TCSTRT, max repetition 6.
565e: b0,ad,34            ldb   R34,Rad          R34 = Tcstrt;
5661: ef,48,df            call  35ac             subyteLU();
5664: 98,38,c8            cmpb  Rc8,R38          
5667: db,13               jc    567c             if (Atmr1 > R38)  {
5669: 45,9e,00,f8,32      ad3w  R32,Rf8,9e       R32 = 94ce;                       # Table 94CE (BP is input)
566e: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
5672: ef,3f,df            call  35b4             USByteLU();
5675: 16,38               sexb  R38              R38 = (int)R38;
5677: 68,38,42            sb2w  R42,R38          R42 -= R38;
567a: 20,16               sjmp  5692             goto 5692; } }
567c: 32,26,13            jnb   B2,R26,5692      if (Nflg = 1)  {
567f: 67,f8,12,42         ad2w  R42,[Rf8+12]     R42 += [9442];
5683: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = Ctntmr;
5687: 45,1e,01,f8,32      ad3w  R32,Rf8,11e      R32 = 954e;                       # Table 954E Idle Spark subtractor, deg.
568c: ef,28,df            call  35b7             UUbyteLu();
568f: 68,38,42            sb2w  R42,R38          R42 -= R38; }
5692: 48,18,42,3c         sb3w  R3c,R42,R18      R3c = R42 - R18;
5696: af,72,d6,38         ldzbw R38,[R72+d6]     R38 = (uns)Spkmul;
569a: 29,ae               scall 584a             Scale_R3c();
569c: a0,3c,42            ldw   R42,R3c          R42 = R3c;
569f: 21,6a               sjmp  580b             goto 580b;
56a1: 30,d0,48            jnb   B0,Rd0,56ec      if (B0_Apt = 1)  {                # check WOT flag
56a4: 45,d4,00,f8,32      ad3w  R32,Rf8,d4       R32 = Wotadvrpm;                  # Table 9504 - WOT spark advance vs RPM
56a9: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
56ac: ef,5d,df            call  360c             UUWordLu();
56af: a0,38,42            ldw   R42,R38          R42 = R38;
56b2: 45,f8,00,f8,32      ad3w  R32,Rf8,f8       R32 = Wotadvbap;                  # Table 9528 - Spark Advance vs. BP
56b7: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
56bb: ef,f6,de            call  35b4             USByteLU();
56be: 16,38               sexb  R38              R38 = (int)R38;
56c0: 64,38,42            ad2w  R42,R38          R42 += R38;
56c3: 45,02,01,f8,32      ad3w  R32,Rf8,102      R32 = Wotadvect;                  # Table 9532 - WOT Spark Advance vs ECT
56c8: b0,b0,34            ldb   R34,Rb0          R34 = ECT;                        # INPUT: Engine Coolant Temp
56cb: ef,e3,de            call  35b1             SSByteLU();
56ce: 16,38               sexb  R38              R38 = (int)R38;                   # OUTPUT: ECT advance increment
56d0: 64,38,42            ad2w  R42,R38          R42 += R38;
56d3: 45,10,01,f8,32      ad3w  R32,Rf8,110      R32 = Wotadvact;                  # Table 9540 - WOT Spark Advance vs ACT
56d8: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
56db: ef,d3,de            call  35b1             SSByteLU();
56de: 16,38               sexb  R38              R38 = (int)R38;
56e0: 64,38,42            ad2w  R42,R38          R42 += R38;
56e3: 67,f8,0a,42         ad2w  R42,[Rf8+a]      R42 += Wotspkad;                  # 943A spark adder WOT
56e7: 68,18,42            sb2w  R42,R18          R42 -= R18;
56ea: 21,0d               sjmp  57f9             goto 57f9; }                      # done
56ec: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
56ef: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
56f2: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
56f5: 45,94,01,f8,38      ad3w  R38,Rf8,194      R38 = Sealspk;                    # Table 95C4 - Altitude Base spark (RPM vs LOAD)
56fa: ef,ed,df            call  36ea             UTabLookUp();
56fd: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
5700: af,74,83,38         ldzbw R38,[R74+83]     R38 = (uns)Mult_bp212A;
5704: 29,44               scall 584a             Scale_R3c();
5706: a0,3c,42            ldw   R42,R3c          R42 = R3c;
5709: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
570c: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
570f: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5712: 45,e4,01,f8,38      ad3w  R38,Rf8,1e4      R38 = Atlospk;                    # Table 9614 - limp mode spark timing Table (Deg BTDC)(RPM vs LOAD)
5717: ef,d0,df            call  36ea             UTabLookUp();
571a: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
571d: 45,c8,00,f8,32      ad3w  R32,Rf8,c8       R32 = 94f8;                       # Table 94F8 LOMALT Table multiplier as a function of Barometric Pressure, BP.(0 at sea level 1.0
                                                                                    at 'high' altitude
5722: b3,74,80,34         ldb   R34,[R74+80]     R34 = Bp;                         # BP - barometric pressure
5726: ef,8e,de            call  35b7             UUbyteLu();
5729: 11,39               clrb  R39              R39 = 0;
572b: 29,1d               scall 584a             Scale_R3c();
572d: 64,3c,42            ad2w  R42,R3c          R42 += R3c;
5730: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
5733: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
5736: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5739: 45,44,01,f8,38      ad3w  R38,Rf8,144      R38 = Basespk;                    # Table 9574 - base spark timing Table (Deg BTDC)(RPM vs LOAD)
573e: ef,a9,df            call  36ea             UTabLookUp();
5741: ac,3b,34            ldzbw R34,R3b          R34 = (uns)R3b;
5744: 48,34,42,3c         sb3w  R3c,R42,R34      R3c = R42 - R34;
5748: 01,3a               clrw  R3a              R3a = 0;
574a: b3,72,c5,39         ldb   R39,[R72+c5]     R39 = Lugtmr;
574e: 11,38               clrb  R38              R38 = 0;
5750: af,f8,0f,36         ldzbw R36,[Rf8+f]      R36 = (uns)[943f];
5754: 8c,36,38            divw  R38,R36          R38 /= R36;
5757: 08,01,38            shrw  R38,1            R38 /= 2;
575a: 28,ee               scall 584a             Scale_R3c();
575c: 44,34,3c,42         ad3w  R42,R3c,R34      R42 = R3c + R34;
5760: a0,a6,30            ldw   R30,Ra6          R30 = Nrmces;
5763: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
5766: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5769: 45,34,02,f8,38      ad3w  R38,Rf8,234      R38 = 9664;                       # X -input = Normalized engine speed on RPM - FN070, Y -input = Normalized LOAD - FN071, Output =
                                                                                    Spark advance adder for EGR, deg per 1 percent EGR.
576e: ef,79,df            call  36ea             UTabLookUp();
5771: ac,3b,38            ldzbw R38,R3b          R38 = (uns)R3b;
5774: 7f,72,ee,38         ml2b  R38,[R72+ee]     R38 *= Egract;
5778: 08,06,38            shrw  R38,6            R38 /= 40;
577b: 64,38,42            ad2w  R42,R38          R42 += R38;
577e: 45,46,01,f0,32      ad3w  R32,Rf0,146      R32 = Fn083;                      # generates Table entry point. Input = N and Output = Normalized N.
5783: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
5786: ef,83,de            call  360c             UUWordLu();
5789: a0,38,30            ldw   R30,R38          R30 = R38;
578c: 45,32,01,f0,32      ad3w  R32,Rf0,132      R32 = Fn082;                      # generates Table entry point. Input = LOAD and Output = Normalized Load.
5791: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
5795: ef,74,de            call  360c             UUWordLu();
5798: a0,38,32            ldw   R32,R38          R32 = R38;
579b: ad,04,34            ldzbw R34,4            R34 = (uns)4;
579e: 45,84,02,f8,38      ad3w  R38,Rf8,284      R38 = 96b4;                       # Table 96B4 - Spark adv from engine speed N and LOAD.
57a3: ef,44,df            call  36ea             UTabLookUp();
57a6: bc,3b,3c            ldsbw R3c,R3b          R3c = (int)R3b;
57a9: af,74,82,38         ldzbw R38,[R74+82]     R38 = (uns)Mult_bp311;
57ad: 28,9b               scall 584a             Scale_R3c();
57af: af,74,f4,38         ldzbw R38,[R74+f4]     R38 = (uns)Mfamul;
57b3: 28,95               scall 584a             Scale_R3c();
57b5: 64,3c,42            ad2w  R42,R3c          R42 += R3c;
57b8: 45,58,00,f8,32      ad3w  R32,Rf8,58       R32 = 9488;                       # Table 9488 ECT normalizing function.
57bd: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
57c0: ef,3e,de            call  3601             SUWordLU();
57c3: a0,38,30            ldw   R30,R38          R30 = R38;
57c6: a0,a8,32            ldw   R32,Ra8          R32 = Nrmrld;
57c9: ad,07,34            ldzbw R34,7            R34 = (uns)7;
57cc: 45,e0,02,f8,38      ad3w  R38,Rf8,2e0      R38 = 9710;                       # Table 9710 (ECT,LOAD) = Part throttle spark modifier Table. X -input = Normalized ECT (FN033) Y
                                                                                    -input = Normalized LOAD (FN071).
57d1: ef,13,df            call  36e7             STabLookup();
57d4: bc,3b,3a            ldsbw R3a,R3b          R3a = (int)R3b;
57d7: 64,3a,42            ad2w  R42,R3a          R42 += R3a;
57da: 45,be,00,f8,32      ad3w  R32,Rf8,be       R32 = Ptadvact;                   # Spark advance
57df: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
57e2: ef,cc,dd            call  35b1             SSByteLU();
57e5: 16,38               sexb  R38              R38 = (int)R38;
57e7: 44,38,42,3c         ad3w  R3c,R42,R38      R3c = R42 + R38;
57eb: 68,18,3c            sb2w  R3c,R18          R3c -= R18;
57ee: af,f8,0e,38         ldzbw R38,[Rf8+e]      R38 = (uns)[943e];
57f2: 28,56               scall 584a             Scale_R3c();
57f4: 47,f8,04,3c,42      ad3w  R42,R3c,[Rf8+4]  R42 = R3c + Ptspkad;              # 9434 spark adder for part throttle

# Code section to retard timing if overspeed (via VSS) with Table HSS_retard (mph).

57f9: 32,e7,0f            jnb   B2,Re7,580b      if (Hspflg = 1)  {                # If overspeed
57fc: 45,65,00,fa,32      ad3w  R32,Rfa,65       R32 = HSS_retard;                 # Table 980D High Speed Spark retard, mph.
5801: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = Mph_FiltH;                  # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
5805: ef,af,dd            call  35b7             UUbyteLu();
5808: 68,38,42            sb2w  R42,R38          R42 -= R38; }                     # retard spark
580b: a0,42,c2            ldw   Rc2,R42          Saf = R42;
580e: 71,fb,28            an2b  R28,fb           Newsa = 0;
5811: 91,80,ed            orb   Red,80           Lugtmr_up = 1;
5814: 71,bf,ed            an2b  Red,bf           Lugtmr_dwn = 0;
5817: b3,72,c5,38         ldb   R38,[R72+c5]     R38 = Lugtmr;
581b: 9b,f8,0f,38         cmpb  R38,[Rf8+f]      
581f: d3,03               jnc   5824             if ((uns) R38 >= [943f])  {
5821: 71,7f,ed            an2b  Red,7f           Lugtmr_up = 0; }
5824: 38,24,22            jb    B0,R24,5849      if (Wot = 1) return;
5827: 45,aa,00,f8,32      ad3w  R32,Rf8,aa       R32 = LOM_spark;                  # Table 94DA LOM Load function to activate LOM spark strategy. Input: RPM and Output: load.
582c: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
582f: ef,da,dd            call  360c             UUWordLu();
5832: 8b,74,de,38         cmpw  R38,[R74+de]     
5836: d3,11               jnc   5849             if ((uns) R38 < Load) return;
5838: b3,f8,10,38         ldb   R38,[Rf8+10]     R38 = [9440];
583c: 30,38,04            jnb   B0,R38,5843      if (B0_R38 = 1)  {
583f: c7,72,c5,00         stb   R0,[R72+c5]      Lugtmr = 0; }
5843: 71,7f,ed            an2b  Red,7f           Lugtmr_up = 0;
5846: 91,40,ed            orb   Red,40           Lugtmr_dwn = 1; }
5849: f0                  ret                    return;


  Scale_R3c:
584a: fe,6c,38,3c         sml2w R3c,R38          R3c *= R38;
584e: 0e,07,3c            asrdw R3c,7            R3c /= 80;
5851: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 4
# Update Dwell - skip subr entirely if TFI Controlled Dwell
#################################################################


  Update_dwell:
5852: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
5856: df,57               je    58af             if (0 != Tfi_dwell)  {
5858: b3,f8,2a,36         ldb   R36,[Rf8+2a]     R36 = DWLWF;                      # Weighting factor for ECT and ACT on Base Dwell
585c: ef,89,ee            call  46e8             Sub14();
585f: 0a,07,34            asrw  R34,7            R34 /= 80;
5862: 45,18,03,f8,32      ad3w  R32,Rf8,318      R32 = Min_Low_dwell;              # Min low speed dwell
5867: 9b,f8,2b,34         cmpb  R34,[Rf8+2b]     
586b: da,05               jle   5872             if ((uns) R34 < [945b])  {
586d: 45,30,03,f8,32      ad3w  R32,Rf8,330      R32 = Min_Hi_dwell; }             # Min high speed dwell
5872: af,74,93,34         ldzbw R34,[R74+93]     R34 = (uns)Vbat;                  # Battery Voltage Level * 16
5876: ef,93,dd            call  360c             UUWordLu();
5879: c3,74,c0,38         stw   R38,[R74+c0]     Dwlbse = R38;                     # Base amount of DWELL
587d: 6d,73,cb,38         ml2w  R38,cb73         R38 *= cb73;                      # convert to IOtime ticks ?
5881: c3,74,bc,3a         stw   R3a,[R74+bc]     Dwlbst = R3a;
5885: a3,74,be,38         ldw   R38,[R74+be]     R38 = Dwell;
5889: 6d,49,9d,38         ml2w  R38,9d49         R38 *= 9d49;
588d: c3,74,c2,3a         stw   R3a,[R74+c2]     Dwellms = R3a;
5891: af,fe,07,32         ldzbw R32,[Rfe+7]      R32 = (uns)PIPsC;
5895: 01,3a               clrw  R3a              R3a = 0;
5897: a3,f8,1c,38         ldw   R38,[Rf8+1c]     R38 = [944c];
589b: 8c,32,38            divw  R38,R32          R38 /= R32;
589e: c3,74,c6,38         stw   R38,[R74+c6]     Ppereng = R38;
58a2: 01,3a               clrw  R3a              R3a = 0;
58a4: a3,f8,1e,38         ldw   R38,[Rf8+1e]     R38 = [944e];
58a8: 8c,32,38            divw  R38,R32          R38 /= R32;
58ab: c3,74,c8,38         stw   R38,[R74+c8]     Poffeng = R38; }
58af: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 42
# Idle Speed controls
#################################################################


  Update_Idle:
58b0: 34,2b,01            jnb   B4,R2b,58b4      if (Disable_isc = 1)  {           # Ignore if disable flag set
58b3: f0                  ret                    return; }

58b4: b3,f2,48,42         ldb   R42,[Rf2+48]     R42 = Dasmph;
58b8: 57,f2,49,42,40      ad3b  R40,R42,[Rf2+49] R40 = R42 + Dasmhyst;             # Dashpot hysteresis
58bd: d3,03               jnc   58c2             if ((uns) R40 >= 0)  {
58bf: b1,ff,40            ldb   R40,ff           R40 = ff; }                       # clamp value to max of FF
# R40 = 11 defined by ROM
58c2: 9b,74,3f,40         cmpb  R40,[R74+3f]     
58c6: d1,0b               jleu  58d3             if ((uns) R40 <= Mph_FiltH) goto 58d3;
58c8: 9b,74,3f,42         cmpb  R42,[R74+3f]     
58cc: d3,08               jnc   58d6             if ((uns) R42 >= Mph_FiltH)  {
58ce: 71,f7,e7            an2b  Re7,f7           Flg_dasmnq = 0;
58d1: 20,03               sjmp  58d6             goto 58d6;
58d3: 91,08,e7            orb   Re7,8            Flg_dasmnq = 1; }
58d6: 37,a1,2f            jnb   B7,Ra1,5908      if (Cranking = 1)  {
58d9: a3,72,a6,3a         ldw   R3a,[R72+a6]     R3a = TPS_Min;
58dd: c3,72,da,3a         stw   R3a,[R72+da]     Dstpbr = R3a;
58e1: 01,14               clrw  R14              R14 = 0;
58e3: a3,72,be,3a         ldw   R3a,[R72+be]     R3a = Tslpip;                     # time since last PIP recieved
58e7: 89,00,08,3a         cmpw  R3a,800                                            # 8 seconds
58eb: db,0e               jc    58fb             if (R3a > 800)  {
58ed: 45,84,03,f4,32      ad3w  R32,Rf4,384      R32 = Crankisc;                   # isc duty cycle during crank
58f2: b0,ad,34            ldb   R34,Rad          R34 = Tcstrt;
58f5: ef,b4,dc            call  35ac             subyteLU();
58f8: b0,38,15            ldb   R15,R38          R15 = R38; }
58fb: c0,b8,14            stw   R14,Rb8          Iscdty = R14;
58fe: a3,fe,26,3a         ldw   R3a,[Rfe+26]     R3a = IFAM;
5902: c3,72,de,3a         stw   R3a,[R72+de]     Fam = R3a;
5906: 20,12               sjmp  591a             goto 591a; }
5908: 33,c5,17            jnb   B3,Rc5,5922      if (Mfmflag = 1)  {
590b: 34,c5,14            jnb   B4,Rc5,5922      if (Tfmflag = 1)  {
590e: a3,f6,7c,b8         ldw   Rb8,[Rf6+7c]     Iscdty = [9424];                  # ISCDTY - ROM 9AFA FCAMSW
5912: b3,f6,7e,42         ldb   R42,[Rf6+7e]     R42 = [9426];
5916: c7,72,e6,42         stb   R42,[R72+e6]     Dsdrpm = R42;
591a: b1,7f,3a            ldb   R3a,7f           R3a = 7f;
591d: c7,72,d6,3a         stb   R3a,[R72+d6]     Spkmul = R3a;
5921: f0                  ret                    return; } }

5922: a3,fa,3e,1c         ldw   R1c,[Rfa+3e]     R1c = [97e6];
5926: 35,2a,16            jnb   B5,R2a,593f      if (Self_test = 0) goto 593f;     # jump if normal strategy - not self test mode
5929: a3,72,6e,40         ldw   R40,[R72+6e]     R40 = Rviprpm;
592d: 6b,f4,74,40         sb2w  R40,[Rf4+74]     R40 -= Nubase;                    # Idle Speed in neutral = 672rpm
5931: 8b,f3,90,00,00      cmpw  R0,[Rf2+90]      
5936: df,77               je    59af             if (0 != Vtcdsn)  {
5938: a3,f3,90,00,1c      ldw   R1c,[Rf2+90]     R1c = Vtcdsn;
593d: 20,70               sjmp  59af             goto 59af;
593f: 45,c4,01,f0,32      ad3w  R32,Rf0,1c4      R32 = Fn825A;                     # Table 90C4
5944: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5947: ef,62,dc            call  35ac             subyteLU();
594a: a0,38,40            ldw   R40,R38          R40 = R38;
594d: 45,d4,01,f0,32      ad3w  R32,Rf0,1d4      R32 = Fn825B;                     # Table 90D4
5952: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
5955: ef,54,dc            call  35ac             subyteLU();
5958: 64,38,40            ad2w  R40,R38          R40 += R38;
595b: 32,e8,0f            jnb   B2,Re8,596d      if (Ctnflg = 1)  {
595e: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = Ctntmr;
5962: 45,2a,01,f8,32      ad3w  R32,Rf8,12a      R32 = 955a;                       # Table 955A
5967: ef,4d,dc            call  35b7             UUbyteLu();
596a: 64,38,40            ad2w  R40,R38          R40 += R38; }
596d: 9b,f5,91,00,c8      cmpb  Rc8,[Rf4+91]     
5972: db,06               jc    597a             if (Atmr1 > Bzztm)  {
5974: 67,f4,78,40         ad2w  R40,[Rf4+78]     R40 += Bzzrpm;
5978: 20,03               sjmp  597d             goto 597d; }
597a: 3c,2f,15            jb    B4,R2f,5992      if (Ptscr = 0)  {
597d: 9b,f5,90,00,c8      cmpb  Rc8,[Rf4+90]     
5982: db,0e               jc    5992             if (Atmr1 > Tkdtm)  {
5984: 45,ea,02,f4,32      ad3w  R32,Rf4,2ea      R32 = 92c0;                       # Table 92C0
5989: b0,ad,34            ldb   R34,Rad          R34 = Tcstrt;
598c: ef,1d,dc            call  35ac             subyteLU();
598f: 64,38,40            ad2w  R40,R38          R40 += R38; } }
5992: 31,e6,1a            jnb   B1,Re6,59af      if (Hwflag = 1)  {                # jump if heated windshield not on
5995: 30,e6,17            jnb   B0,Re6,59af      if (Hwflgl = 1)  {
5998: 3e,26,14            jb    B6,R26,59af      if (Dndsup = 0)  {
599b: a3,f0,04,30         ldw   R30,[Rf0+4]      R30 = [8c04];
599f: 6b,f4,74,30         sb2w  R30,[Rf4+74]     R30 -= Nubase;                    # Idle Speed in neutral = 672rpm
59a3: db,02               jc    59a7             if (R30 > 0)  {
59a5: 01,30               clrw  R30              R30 = 0; }
59a7: 88,30,40            cmpw  R40,R30          
59aa: db,03               jc    59af             if (R40 > R30)  {
59ac: a0,30,40            ldw   R40,R30          R40 = R30; } } } } }
59af: 08,01,40            shrw  R40,1            R40 /= 2;
59b2: 98,00,41            cmpb  R41,R0           
59b5: df,03               je    59ba             if (R41 != 0)  {
59b7: ad,ff,40            ldzbw R40,ff           R40 = (uns)ff; }
59ba: b0,40,35            ldb   R35,R40          R35 = R40;
59bd: 11,34               clrb  R34              R34 = 0;
59bf: 8b,72,e4,34         cmpw  R34,[R72+e4]     
59c3: db,15               jc    59da             if (R34 > Desnlo)  {
59c5: a3,72,e4,32         ldw   R32,[R72+e4]     R32 = Desnlo;
59c9: ef,92,dc            call  365e             Srolav1T(1c);
59cc: 1c,00               #args  
59ce: c3,72,e4,3e         stw   R3e,[R72+e4]     Desnlo = R3e;                     # filtered DESNLO
59d2: c0,40,3e            stw   R3e,R40          R40 = R3e;
59d5: 08,07,40            shrw  R40,7            R40 /= 80;
59d8: 20,07               sjmp  59e1             goto 59e1; }
59da: c3,72,e4,34         stw   R34,[R72+e4]     Desnlo = R34;
59de: 09,01,40            shlw  R40,1            R40 *= 2;
59e1: 91,80,26            orb   R26,80           Hcamfg = 1;
59e4: 88,00,40            cmpw  R40,R0           
59e7: d7,03               jne   59ec             if (R40 = 0)  {
59e9: 71,7f,26            an2b  R26,7f           Hcamfg = 0; }
59ec: b3,72,eb,14         ldb   R14,[R72+eb]     R14 = Isflag;
59f0: c7,72,ec,14         stb   R14,[R72+ec]     Islast = R14;
59f4: 01,3e               clrw  R3e              R3e = 0;
59f6: a3,72,de,16         ldw   R16,[R72+de]     R16 = Fam;
59fa: 36,26,09            jnb   B6,R26,5a06      if (Dndsup = 0) goto 5a06;
59fd: b3,fe,02,30         ldb   R30,[Rfe+2]      R30 = TRLOAD;
5a01: 99,03,30            cmpb  R30,3                                              # check if in neutral or in gear ( in ROM! = 3 )Maybe this is manual vs automatic
5a04: d9,09               jgtu  5a0f             if ((uns) R30 <= 3)  {
5a06: 91,02,3e            orb   R3e,2            Isf_neut = 1;
5a09: 67,f4,74,40         ad2w  R40,[Rf4+74]     R40 += Nubase;                    # F4 = 8FD6 so 74+8FD6 = 904A = Idle Speed in neutral (0054H = 84 and 84 * 8 = 672rpm
5a0d: 20,04               sjmp  5a13             goto 5a13; }
5a0f: 67,f4,76,40         ad2w  R40,[Rf4+76]     R40 += Neu_rpm;
5a13: 3b,ea,03            jb    B3,Rea,5a19      if (Accflg = 1) goto 5a19;
5a16: 32,ea,03            jnb   B2,Rea,5a1c      if (Aciflg = 1)  {
5a19: 91,01,3e            orb   R3e,1            Isf_acon = 1; }
5a1c: 38,3e,0b            jb    B0,R3e,5a2a      if (Isf_acon = 1) goto 5a2a;
5a1f: a3,f5,8c,00,30      ldw   R30,[Rf4+8c]     R30 = Dactm;
5a24: 8b,74,98,30         cmpw  R30,[R74+98]     
5a28: d1,04               jleu  5a2e             if ((uns) R30 > Acctmr )  {
5a2a: 67,f4,7a,40         ad2w  R40,[Rf4+7a]     R40 += Dnac; }
5a2e: 34,27,12            jnb   B4,R27,5a43      if (Powsfg = 1)  {
5a31: 57,f6,14,00,30      ad3b  R30,R0,[Rf6+14]  R30 = Pspshp;
5a36: df,0b               je    5a43             if (R30 != 0)  {
5a38: 67,f5,8e,00,40      ad2w  R40,[Rf4+8e]     R40 += Dnpows;
5a3d: 91,80,26            orb   R26,80           Hcamfg = 1;
5a40: 91,01,3f            orb   R3f,1            Isf_pson = 1; } }
5a43: 39,3e,14            jb    B1,R3e,5a5a      if (Isf_neut = 0)  {
5a46: b3,72,cd,30         ldb   R30,[R72+cd]     R30 = Atmr3;                      # time since entering 'running' mode
5a4a: 9b,fa,1e,30         cmpb  R30,[Rfa+1e]     
5a4e: d1,0a               jleu  5a5a             if ((uns) R30 > [97c6] )  {
5a50: 8b,f4,7c,40         cmpw  R40,[Rf4+7c]     
5a54: d1,04               jleu  5a5a             if ((uns) R40 > Isclpd )  {
5a56: a3,f4,7c,40         ldw   R40,[Rf4+7c]     R40 = Isclpd; } } }
5a5a: 31,3e,07            jnb   B1,R3e,5a64      if (Isf_neut = 1)  {
5a5d: 45,c6,03,f4,32      ad3w  R32,Rf4,3c6      R32 = Neu_aflw;
5a62: 20,05               sjmp  5a69             goto 5a69; }
5a64: 45,ba,03,f4,32      ad3w  R32,Rf4,3ba      R32 = Drv_aflw;
5a69: a0,40,34            ldw   R34,R40          R34 = R40;
5a6c: 08,01,34            shrw  R34,1            R34 /= 2;
5a6f: 99,00,35            cmpb  R35,0            
5a72: d1,03               jleu  5a77             if ((uns) R35 > 0 )  {
5a74: b1,ff,34            ldb   R34,ff           R34 = ff; }
5a77: ef,3d,db            call  35b7             UUbyteLu();
5a7a: a0,38,20            ldw   R20,R38          R20 = R38;
5a7d: 45,76,02,f4,32      ad3w  R32,Rf4,276      R32 = ISC_ECT_SC;
5a82: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5a85: ef,24,db            call  35ac             subyteLU();
5a88: ac,38,30            ldzbw R30,R38          R30 = (uns)R38;
5a8b: 09,04,30            shlw  R30,4            R30 *= 10;
5a8e: 45,7e,00,fc,32      ad3w  R32,Rfc,7e       R32 = HCAMSW;                     # Table 9AFC
5a93: af,72,cd,34         ldzbw R34,[R72+cd]     R34 = (uns)Atmr3;                 #  time since entering 'running' mode
5a97: ef,72,db            call  360c             UUWordLu();
5a9a: a0,38,32            ldw   R32,R38          R32 = R38;
5a9d: ad,07,34            ldzbw R34,7            R34 = (uns)7;
5aa0: 45,90,03,f4,38      ad3w  R38,Rf4,390      R38 = ECT_AM_Mult;                # Table 9366 - (ECT,ATMR3) = Airflow multiplier vs. ECT and ATMR3
5aa5: ef,42,dc            call  36ea             UTabLookUp();
5aa8: 7c,3b,20            ml2b  R20,R3b          R20 *= R3b;
5aab: 08,02,20            shrw  R20,2            R20 /= 4;
5aae: 30,3e,05            jnb   B0,R3e,5ab6      if (Isf_acon = 1)  {
5ab1: 67,f5,86,00,20      ad2w  R20,[Rf4+86]     R20 += Acppm; }
5ab6: 30,3f,05            jnb   B0,R3f,5abe      if (Isf_pson = 1)  {
5ab9: 67,f5,8a,00,20      ad2w  R20,[Rf4+8a]     R20 += Psppm; }
5abe: 31,14,0a            jnb   B1,R14,5acb      if (Isl_neut = 0) goto 5acb;
5ac1: 39,3e,14            jb    B1,R3e,5ad8      if (Isf_neut = 0)  {
5ac4: 67,f5,82,00,16      ad2w  R16,[Rf4+82]     R16 += Ndppm;
5ac9: 20,0d               sjmp  5ad8             goto 5ad8;
5acb: 31,3e,0a            jnb   B1,R3e,5ad8      if (Isf_neut = 1)  {
5ace: 6b,f5,84,00,16      sb2w  R16,[Rf4+84]     R16 -= Dnppm;
5ad3: db,03               jc    5ad8             if (R16 > 0)  {
5ad5: a0,00,16            ldw   R16,R0           R16 = 0; } } }
5ad8: 30,14,0f            jnb   B0,R14,5aea      if (Isl_acon = 0) goto 5aea;
5adb: 38,3e,14            jb    B0,R3e,5af2      if (Isf_acon = 0)  {
5ade: 6b,f5,88,00,16      sb2w  R16,[Rf4+88]     R16 -= Dacppm;
5ae3: db,0d               jc    5af2             if (R16 > 0)  {
5ae5: a0,00,16            ldw   R16,R0           R16 = 0;
5ae8: 20,08               sjmp  5af2             goto 5af2;
5aea: 30,3e,05            jnb   B0,R3e,5af2      if (Isf_acon = 1)  {
5aed: 67,f5,86,00,16      ad2w  R16,[Rf4+86]     R16 += Acppm; } } }
5af2: 30,3f,15            jnb   B0,R3f,5b0a      if (Isf_pson = 0) goto 5b0a;
5af5: 3a,ec,15            jb    B2,Rec,5b0d      if (Psflag = 0)  {
5af8: 67,f5,8a,00,16      ad2w  R16,[Rf4+8a]     R16 += Psppm;
5afd: 91,04,ec            orb   Rec,4            Psflag = 1;
5b00: c3,72,e0,00         stw   R0,[R72+e0]      Ibgpsi = 0;
5b04: c7,72,ea,00         stb   R0,[R72+ea]      Bgcnt = 0;
5b08: 20,03               sjmp  5b0d             goto 5b0d;
5b0a: 71,fb,ec            an2b  Rec,fb           Psflag = 0; }
5b0d: 31,e6,0a            jnb   B1,Re6,5b1a      if (Hwflag = 1)  {
5b10: 30,e6,07            jnb   B0,Re6,5b1a      if (Hwflgl = 1)  {
5b13: 3e,26,04            jb    B6,R26,5b1a      if (Dndsup = 0)  {
5b16: 67,f6,0c,20         ad2w  R20,[Rf6+c]      R20 += [93b4]; } } }
5b1a: c7,72,eb,3e         stb   R3e,[R72+eb]     Isflag = R3e;
5b1e: c3,72,de,16         stw   R16,[R72+de]     Fam = R16;
5b22: 08,01,40            shrw  R40,1            R40 /= 2;
5b25: 98,00,41            cmpb  R41,R0           
5b28: df,03               je    5b2d             if (R41 != 0)  {
5b2a: ad,ff,40            ldzbw R40,ff           R40 = (uns)ff; }
5b2d: c7,72,e6,40         stb   R40,[R72+e6]     Dsdrpm = R40;
5b31: 09,06,40            shlw  R40,6            R40 *= 40;
5b34: a3,72,da,32         ldw   R32,[R72+da]     R32 = Dstpbr;
5b38: a0,aa,34            ldw   R34,Raa          R34 = TP;                         # RAA is Throttle position
5b3b: a3,fa,3c,36         ldw   R36,[Rfa+3c]     R36 = [97e4];
5b3f: 88,32,34            cmpw  R34,R32          
5b42: d9,04               jgtu  5b48             if ((uns) R34 <= R32)  {
5b44: a3,fa,3a,36         ldw   R36,[Rfa+3a]     R36 = [97e2]; }
5b48: ef,18,db            call  3663             Urolav();
5b4b: c3,72,da,3e         stw   R3e,[R72+da]     Dstpbr = R3e;
5b4f: 37,d0,24            jnb   B7,Rd0,5b76      if (Cl_thrtl = 0) goto 5b76;
5b52: 45,54,03,f4,32      ad3w  R32,Rf4,354      R32 = Dash_dec;                   # dashpot decrement rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))
5b57: a3,72,dc,34         ldw   R34,[R72+dc]     R34 = Daspot;
5b5b: 33,e7,09            jnb   B3,Re7,5b67      if (Flg_dasmnq = 0) goto 5b67;
5b5e: a3,f2,4a,3e         ldw   R3e,[Rf2+4a]     R3e = Dasmin;
5b62: 88,3e,34            cmpw  R34,R3e          
5b65: d1,49               jleu  5bb0             if ((uns) R34 > R3e )  {
5b67: a0,34,3e            ldw   R3e,R34          R3e = R34;
5b6a: ef,9f,da            call  360c             UUWordLu();
5b6d: 68,38,3e            sb2w  R3e,R38          R3e -= R38;
5b70: db,3e               jc    5bb0             if (R3e > 0)  {
5b72: 01,3e               clrw  R3e              R3e = 0;
5b74: 20,3a               sjmp  5bb0             goto 5bb0;
5b76: a3,f4,60,42         ldw   R42,[Rf4+60]     R42 = Delhys;
5b7a: 67,72,a6,42         ad2w  R42,[R72+a6]     R42 += TPS_Min;                   # 126 - RATCH=Closed TP
5b7e: d3,03               jnc   5b83             if ((uns) R42 >= 0)  {
5b80: bd,c0,42            ldsbw R42,c0           R42 = (int)c0; }
5b83: 68,42,3e            sb2w  R3e,R42          R3e -= R42;
5b86: db,02               jc    5b8a             if (R3e > 0)  {
5b88: 01,3e               clrw  R3e              R3e = 0; }
5b8a: a3,f4,5c,3c         ldw   R3c,[Rf4+5c]     R3c = Dasptk;
5b8e: 6c,3e,3c            ml2w  R3c,R3e          R3c *= R3e;
5b91: 45,70,03,f4,32      ad3w  R32,Rf4,370      R32 = Dash_max;                   # Table 9346 Max Dashpot clip Dashpot clip(lbs/min) vs RPM
5b96: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
5b99: ef,70,da            call  360c             UUWordLu();
5b9c: 99,20,3f            cmpb  R3f,20           
5b9f: db,0c               jc    5bad             if ((uns) R3f >= 20) goto 5bad;
5ba1: 0d,02,3c            shldw R3c,2            R3c *= 4;
5ba4: 67,f4,5e,3e         ad2w  R3e,[Rf4+5e]     R3e += Daspto;
5ba8: 88,38,3e            cmpw  R3e,R38          
5bab: d1,03               jleu  5bb0             if ((uns) R3e > R38 )  {
5bad: a0,38,3e            ldw   R3e,R38          R3e = R38; } } }
5bb0: c3,72,dc,3e         stw   R3e,[R72+dc]     Daspot = R3e;
5bb4: c0,1c,3e            stw   R3e,R1c          R1c = R3e;
5bb7: 3f,d0,13            jb    B7,Rd0,5bcd      if (Cl_thrtl = 0)  {
5bba: c3,72,e2,ae         stw   Rae,[R72+e2]     Nlast = Rpmx4;
5bbe: 11,3a               clrb  R3a              R3a = 0;
5bc0: c7,72,c6,00         stb   R0,[R72+c6]      Isctmr = 0;
5bc4: b1,7f,3c            ldb   R3c,7f           R3c = 7f;
5bc7: c7,72,d6,3c         stb   R3c,[R72+d6]     Spkmul = R3c;
5bcb: 20,a1               sjmp  5c6e             goto 5c6e; }
5bcd: b1,01,3a            ldb   R3a,1            R3a = 1;
5bd0: 35,2a,07            jnb   B5,R2a,5bda      if (Self_test = 1)  {             # jump if normal strategy - not self test mode
5bd3: 88,1c,00            cmpw  R0,R1c           
5bd6: d7,02               jne   5bda             if (0 != R1c) goto 5bda;
5bd8: 20,94               sjmp  5c6e             goto 5c6e; }
5bda: b3,fe,02,16         ldb   R16,[Rfe+2]      R16 = TRLOAD;                     # 9E5C
5bde: 99,03,16            cmpb  R16,3            
5be1: d7,03               jne   5be6             if (R16 != 3) goto 5be6;
5be3: 3e,26,42            jb    B6,R26,5c28      if (Dndsup = 1) goto 5c28;
5be6: b3,f4,66,30         ldb   R30,[Rf4+66]     R30 = Minmph;
5bea: 9b,74,3f,30         cmpb  R30,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
5bee: d3,38               jnc   5c28             if ((uns) R30 < Mph_FiltH) goto 5c28;
5bf0: 88,00,1c            cmpw  R1c,R0           
5bf3: d7,33               jne   5c28             if (R1c != 0) goto 5c28;
5bf5: 47,f4,62,40,38      ad3w  R38,R40,[Rf4+62] R38 = R40 + Rpmctl;
5bfa: 88,38,ae            cmpw  Rae,R38          
5bfd: d9,02               jgtu  5c01             if ((uns) Rpmx4 > R38 ) goto 5c01;
5bff: 20,6d               sjmp  5c6e             goto 5c6e;
5c01: 9b,72,d7,00         cmpb  R0,[R72+d7]      
5c05: de,37               jlt   5c3e             if (0 >= Iscflg)  {
5c07: b3,72,c6,38         ldb   R38,[R72+c6]     R38 = Isctmr;                     # 146 = Isctmr
5c0b: 9b,f4,6d,38         cmpb  R38,[Rf4+6d]     
5c0f: d3,17               jnc   5c28             if ((uns) R38 < Isctm) goto 5c28;
5c11: 4b,72,e2,ae,38      sb3w  R38,Rae,[R72+e2] R38 = Rpmx4 - Nlast;
5c16: db,02               jc    5c1a             if (R38 > 0)  {
5c18: 03,38               negw  R38              R38 = -R38; }
5c1a: 8b,f4,64,38         cmpw  R38,[Rf4+64]     
5c1e: d1,1e               jleu  5c3e             if ((uns) R38 > Ndif )  {
5c20: c3,72,e2,ae         stw   Rae,[R72+e2]     Nlast = Rpmx4;
5c24: c7,72,c6,00         stb   R0,[R72+c6]      Isctmr = 0;                       # zero Isctmr
5c28: a0,1c,34            ldw   R34,R1c          R34 = R1c;
5c2b: 08,06,34            shrw  R34,6            R34 /= 40;
5c2e: 45,f8,02,f4,32      ad3w  R32,Rf4,2f8      R32 = 92ce;                       # Table 92CE
5c33: ef,81,d9            call  35b7             UUbyteLu();
5c36: c7,72,d6,38         stb   R38,[R72+d6]     Spkmul = R38;
5c3a: 13,3a               negb  R3a              R3a = -R3a;
5c3c: 20,30               sjmp  5c6e             goto 5c6e; } }
5c3e: 99,03,16            cmpb  R16,3            
5c41: d3,03               jnc   5c46             if ((uns) R16 < 3) goto 5c46;
5c43: 36,26,25            jnb   B6,R26,5c6b      if (Dndsup = 1)  {
5c46: af,f4,6e,38         ldzbw R38,[Rf4+6e]     R38 = (uns)Lowlod;
5c4a: 33,ea,09            jnb   B3,Rea,5c56      if (Accflg = 1)  {
5c4d: 77,f4,6f,38         ad2b  R38,[Rf4+6f]     R38 += Aclod;
5c51: d3,03               jnc   5c56             if ((uns) R38 >= 0)  {
5c53: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; } }
5c56: 09,06,38            shlw  R38,6            R38 *= 40;
5c59: 8b,74,de,38         cmpw  R38,[R74+de]                                       # engine load (VE? )
5c5d: d3,0c               jnc   5c6b             if ((uns) R38 >= Load)  {
5c5f: c3,72,e2,ae         stw   Rae,[R72+e2]     Nlast = Rpmx4;
5c63: c7,72,c6,00         stb   R0,[R72+c6]      Isctmr = 0;                       # zero 146 timer - ISCTMR
5c67: 13,3a               negb  R3a              R3a = -R3a;
5c69: 20,03               sjmp  5c6e             goto 5c6e; } }
5c6b: b1,02,3a            ldb   R3a,2            R3a = 2;
5c6e: c7,72,d7,3a         stb   R3a,[R72+d7]     Iscflg = R3a;
5c72: af,72,eb,32         ldzbw R32,[R72+eb]     R32 = (uns)Isflag;
5c76: a3,72,d4,38         ldw   R38,[R72+d4]     R38 = Ipsibr;
5c7a: 0a,01,38            asrw  R38,1            R38 /= 2;
5c7d: 08,01,1c            shrw  R1c,1            R1c /= 2;
5c80: 3f,e9,06            jb    B7,Re9,5c89      if (Ctptfg = 1) goto 5c89;
5c83: 9b,72,ec,32         cmpb  R32,[R72+ec]     
5c87: df,13               je    5c9c             if (R32 != Islast)  {
5c89: c3,72,e0,00         stw   R0,[R72+e0]      Ibgpsi = 0;
5c8d: c7,72,ea,00         stb   R0,[R72+ea]      Bgcnt = 0;
5c91: 88,00,38            cmpw  R38,R0           
5c94: d6,06               jge   5c9c             if (R38 < 0)  {
5c96: 01,38               clrw  R38              R38 = 0;
5c98: c3,72,d4,38         stw   R38,[R72+d4]     Ipsibr = R38; } }
5c9c: 09,01,32            shlw  R32,1            R32 *= 2;
5c9f: 01,3c               clrw  R3c              R3c = 0;
5ca1: 3f,28,08            jb    B7,R28,5cac      if (Kam_error = 0)  {
5ca4: a3,33,e4,07,3c      ldw   R3c,[R32+7e4]    R3c = [R32+KIsckam0L];
5ca9: 0a,01,3c            asrw  R3c,1            R3c /= 2; }
5cac: 64,1c,20            ad2w  R20,R1c          R20 += R1c;
5caf: 64,38,20            ad2w  R20,R38          R20 += R38;
5cb2: 64,3c,20            ad2w  R20,R3c          R20 += R3c;
5cb5: a0,20,3e            ldw   R3e,R20          R3e = R20;
5cb8: d6,02               jge   5cbc             if (R20 < 0)  {
5cba: 01,3e               clrw  R3e              R3e = 0; }
5cbc: 09,01,20            shlw  R20,1            R20 *= 2;
5cbf: c3,72,d8,20         stw   R20,[R72+d8]     Desmaf = R20;
5cc3: 09,01,3e            shlw  R3e,1            R3e *= 2;
5cc6: b3,72,d7,1e         ldb   R1e,[R72+d7]     R1e = Iscflg;
5cca: a3,72,e0,1c         ldw   R1c,[R72+e0]     R1c = Ibgpsi;
5cce: 45,b0,02,f4,32      ad3w  R32,Rf4,2b0      R32 = 9286;                       # Table 9286
5cd3: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
5cd6: ef,33,d9            call  360c             UUWordLu();
5cd9: 64,38,3e            ad2w  R3e,R38          R3e += R38;
5cdc: d3,03               jnc   5ce1             if ((uns) R3e >= 0)  {
5cde: bd,ff,3e            ldsbw R3e,ff           R3e = (int)ff; }
5ce1: 6b,f4,58,3e         sb2w  R3e,[Rf4+58]     R3e -= Ithbma;
5ce5: db,02               jc    5ce9             if (R3e > 0)  {
5ce7: 01,3e               clrw  R3e              R3e = 0; }
5ce9: 98,00,1e            cmpb  R1e,R0           
5cec: da,3b               jle   5d29             if (R1e <= 0) goto 5d29;
5cee: 07,1c               incw  R1c              R1c++;
5cf0: d3,02               jnc   5cf4             if ((uns) R1c >= 0)  {
5cf2: 05,1c               decw  R1c              R1c--; }
5cf4: c3,72,e0,1c         stw   R1c,[R72+e0]     Ibgpsi = R1c;
5cf8: 11,16               clrb  R16              R16 = 0;
5cfa: 48,ae,40,14         sb3w  R14,R40,Rae      R14 = R40 - Rpmx4;
5cfe: db,02               jc    5d02             if (R14 > 0)  {
5d00: 17,16               incb  R16              R16++; }
5d02: 3e,26,07            jb    B6,R26,5d0c      if (Dndsup = 0)  {
5d05: 45,1c,03,f4,32      ad3w  R32,Rf4,31c      R32 = 92f2;                       # Table 92F2
5d0a: 20,05               sjmp  5d11             goto 5d11; }
5d0c: 45,00,03,f4,32      ad3w  R32,Rf4,300      R32 = 92d6;                       # Table 92D6
5d11: a0,14,34            ldw   R34,R14          R34 = R14;
5d14: ef,ea,d8            call  3601             SUWordLU();
5d17: c7,72,d6,38         stb   R38,[R72+d6]     Spkmul = R38;
5d1b: a0,14,34            ldw   R34,R14          R34 = R14;
5d1e: 30,16,02            jnb   B0,R16,5d23      if (Vsc_flg1 = 1)  {
5d21: 03,14               negw  R14              R14 = -R14; }
5d23: 8b,f4,68,14         cmpw  R14,[Rf4+68]     
5d27: d9,02               jgtu  5d2b             if ((uns) R14 > Rpmded ) goto 5d2b;
5d29: 20,c6               sjmp  5df1             goto 5df1;
5d2b: c7,72,c6,00         stb   R0,[R72+c6]      Isctmr = 0;                       # zero Isctmr timer?
5d2f: a3,fe,44,38         ldw   R38,[Rfe+44]     R38 = [9e9e];
5d33: 3d,2a,08            jb    B5,R2a,5d3e      if (Self_test = 0)  {
5d36: 45,38,03,f4,32      ad3w  R32,Rf4,338      R32 = 930e;                       # Table 930E
5d3b: ef,c3,d8            call  3601             SUWordLU(); }
5d3e: 88,38,1c            cmpw  R1c,R38          
5d41: db,02               jc    5d45             if ((uns) R1c >= R38) goto 5d45;
5d43: 20,ac               sjmp  5df1             goto 5df1;
5d45: 01,1c               clrw  R1c              R1c = 0;
5d47: c3,72,e0,1c         stw   R1c,[R72+e0]     Ibgpsi = R1c;
5d4b: 3d,2a,14            jb    B5,R2a,5d62      if (Self_test = 0)  {
5d4e: 89,70,7d,b8         cmpw  Rb8,7d70         
5d52: d3,0e               jnc   5d62             if ((uns) Iscdty >= 7d70)  {
5d54: 4b,f4,62,40,32      sb3w  R32,R40,[Rf4+62] R32 = R40 - Rpmctl;
5d59: d1,07               jleu  5d62             if ((uns) R32 > 0 )  {
5d5b: 88,ae,32            cmpw  R32,Rae          
5d5e: d1,02               jleu  5d62             if ((uns) R32 <= Rpmx4) goto 5d62;
5d60: 20,8f               sjmp  5df1             goto 5df1; } } }
5d62: 35,2a,06            jnb   B5,R2a,5d6b      if (Self_test = 1)  {             # jump if normal strategy - not self test mode
5d65: a1,00,40,38         ldw   R38,4000         R38 = 4000;
5d69: 20,0f               sjmp  5d7a             goto 5d7a; }
5d6b: b3,74,21,34         ldb   R34,[R74+21]     R34 = N_byte;                     # 29F - N byte
5d6f: 45,dc,02,f4,32      ad3w  R32,Rf4,2dc      R32 = 92b2;                       # Table 92B2
5d74: ef,40,d8            call  35b7             UUbyteLu();
5d77: 09,08,38            shlw  R38,8            R38 *= 100;
5d7a: 6c,14,38            ml2w  R38,R14          R38 *= R14;
5d7d: 35,2a,0d            jnb   B5,R2a,5d8d      if (Self_test = 0) goto 5d8d;     # jump if normal strategy - not self test mode
5d80: a3,fe,40,38         ldw   R38,[Rfe+40]     R38 = [9e9a];
5d84: 38,16,21            jb    B0,R16,5da8      if (Vsc_flg1 = 0)  {
5d87: a3,fe,42,38         ldw   R38,[Rfe+42]     R38 = [9e9c];
5d8b: 20,1b               sjmp  5da8             goto 5da8;
5d8d: 3e,26,0d            jb    B6,R26,5d9d      if (Dndsup = 1) goto 5d9d;
5d90: a3,f4,4e,38         ldw   R38,[Rf4+4e]     R38 = Kpsind;
5d94: 38,16,11            jb    B0,R16,5da8      if (Vsc_flg1 = 0)  {
5d97: a3,f4,4c,38         ldw   R38,[Rf4+4c]     R38 = Kpsinu;
5d9b: 20,0b               sjmp  5da8             goto 5da8;
5d9d: a3,f4,52,38         ldw   R38,[Rf4+52]     R38 = Kpsidd;
5da1: 38,16,04            jb    B0,R16,5da8      if (Vsc_flg1 = 0)  {
5da4: a3,f4,50,38         ldw   R38,[Rf4+50]     R38 = Kpsidu; } } }
5da8: 6c,3a,38            ml2w  R38,R3a          R38 *= R3a;
5dab: 99,02,3b            cmpb  R3b,2            
5dae: d3,06               jnc   5db6             if ((uns) R3b >= 2)  {
5db0: a1,ff,7f,3a         ldw   R3a,7fff         R3a = 7fff;
5db4: 20,03               sjmp  5db9             goto 5db9; }
5db6: 0d,06,38            shldw R38,6            R38 *= 40;
5db9: a3,f4,54,34         ldw   R34,[Rf4+54]     R34 = Psibrm;
5dbd: a3,f4,56,36         ldw   R36,[Rf4+56]     R36 = Psibrn;
5dc1: 35,2a,08            jnb   B5,R2a,5dcc      if (Self_test = 1)  {             # jump if normal strategy - not self test mode
5dc4: a3,fe,3c,34         ldw   R34,[Rfe+3c]     R34 = [9e96];
5dc8: a3,fe,3e,36         ldw   R36,[Rfe+3e]     R36 = [9e98]; }
5dcc: 30,16,02            jnb   B0,R16,5dd1      if (Vsc_flg1 = 1)  {
5dcf: 03,3a               negw  R3a              R3a = -R3a; }
5dd1: 67,72,d4,3a         ad2w  R3a,[R72+d4]     R3a += Ipsibr;
5dd5: d5,04               jnv   5ddb             if (OVF = 0) goto 5ddb;
5dd7: d6,09               jge   5de2             if (R3a >= 0) goto 5de2;
5dd9: 20,0f               sjmp  5dea             goto 5dea;
5ddb: de,08               jlt   5de5             if (R3a < 0) goto 5de5;
5ddd: 88,34,3a            cmpw  R3a,R34          
5de0: da,0b               jle   5ded             if ((uns) R3a < R34)  {
5de2: a0,34,3a            ldw   R3a,R34          R3a = R34;
5de5: 88,36,3a            cmpw  R3a,R36          
5de8: d6,03               jge   5ded             if (R3a < R36)  {
5dea: a0,36,3a            ldw   R3a,R36          R3a = R36; } }
5ded: c3,72,d4,3a         stw   R3a,[R72+d4]     Ipsibr = R3a;
5df1: a0,3e,32            ldw   R32,R3e          R32 = R3e;
5df4: 4d,ef,00,3e,34      ml3w  R34,R3e,ef       R34 = R3e * ef;
5df9: af,74,80,3e         ldzbw R3e,[R74+80]     R3e = (uns)Bp;                    # BP - barometric pressure
5dfd: 8c,3e,34            divw  R34,R3e          R34 /= R3e;
5e00: 8b,f4,5a,34         cmpw  R34,[Rf4+5a]                                       # 9030 - DEBYCP ?
5e04: db,04               jc    5e0a             if (R34 > Debycp)  {
5e06: a3,f4,5a,34         ldw   R34,[Rf4+5a]     R34 = Debycp; }                   # 9030 - DEBYCP ?
5e0a: 8b,f4,5a,32         cmpw  R32,[Rf4+5a]                                       # 9030 - DEBYCP ?
5e0e: db,04               jc    5e14             if (R32 > Debycp)  {
5e10: a3,f4,5a,32         ldw   R32,[Rf4+5a]     R32 = Debycp; }                   # 9030 - DEBYCP ?
5e14: c3,74,e4,32         stw   R32,[R74+e4]     Debyma_fm = R32;
5e18: 45,80,02,f4,32      ad3w  R32,Rf4,280      R32 = 9256;                       # Table 9256
5e1d: ef,ec,d7            call  360c             UUWordLu();
5e20: a0,38,40            ldw   R40,R38          R40 = R38;
5e23: af,fe,46,38         ldzbw R38,[Rfe+46]     R38 = (uns)[9ea0];
5e27: 3d,2a,0c            jb    B5,R2a,5e36      if (Self_test = 0)  {             # jump if running self tests
5e2a: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
5e2e: 45,c4,02,f4,32      ad3w  R32,Rf4,2c4      R32 = 929a;                       # Table 929A Crank Pulse Width Multiplier vs time in crank mode
5e33: ef,d6,d7            call  360c             UUWordLu(); }
5e36: 09,08,38            shlw  R38,8            R38 *= 100;
5e39: 6c,40,38            ml2w  R38,R40          R38 *= R40;
5e3c: 0d,01,38            shldw R38,1            R38 *= 2;
5e3f: db,06               jc    5e47             if ((uns) R38 >= 0) goto 5e47;
5e41: 89,00,80,3a         cmpw  R3a,8000         
5e45: d1,04               jleu  5e4b             if ((uns) R3a > 8000 )  {
5e47: a1,00,80,3a         ldw   R3a,8000         R3a = 8000; }
5e4b: c0,b8,3a            stw   R3a,Rb8          Iscdty = R3a;
5e4e: 99,01,1e            cmpb  R1e,1            
5e51: d7,70               jne   5ec3             if (R1e != 1) return;
5e53: b3,72,c6,38         ldb   R38,[R72+c6]     R38 = Isctmr;                     # 146 timer - ISCTMR
5e57: 9b,f4,70,38         cmpb  R38,[Rf4+70]     
5e5b: d3,66               jnc   5ec3             if ((uns) R38 < Updisc) return;
5e5d: 3f,26,63            jb    B7,R26,5ec3      if (Hcamfg = 1) return;
5e60: a3,72,d4,3c         ldw   R3c,[R72+d4]     R3c = Ipsibr;
5e64: 88,00,3c            cmpw  R3c,R0           
5e67: df,5a               je    5ec3             if (R3c = 0) return;
5e69: 3f,28,57            jb    B7,R28,5ec3      if (Kam_error = 1) return;
5e6c: af,72,eb,32         ldzbw R32,[R72+eb]     R32 = (uns)Isflag;                # 16B - ISFlag - index of some sort?
5e70: 09,01,32            shlw  R32,1            R32 *= 2;                         # index to word offset
5e73: a3,33,e4,07,38      ldw   R38,[R32+7e4]    R38 = [R32+KIsckam0L];
5e78: af,f4,71,3a         ldzbw R3a,[Rf4+71]     R3a = (uns)Updatm;                # 9047 - UPDATM
5e7c: 88,3a,1c            cmpw  R1c,R3a          
5e7f: d3,42               jnc   5ec3             if ((uns) R1c < R3a) return;
5e81: c3,72,e0,00         stw   R0,[R72+e0]      Ibgpsi = 0;                       # 160 - IBGPSI
5e85: a3,01,ec,07,34      ldw   R34,[R0+7ec]     R34 = KIsksum;                    # KAM Table 2 checksum
5e8a: 88,00,3c            cmpw  R3c,R0           
5e8d: d2,14               jgt   5ea3             if (R3c > 0) goto 5ea3;
5e8f: 8b,f4,56,38         cmpw  R38,[Rf4+56]                                       # 902C - PSIBRN
5e93: da,2e               jle   5ec3             if (R38 <= Psibrn) return;
5e95: 05,38               decw  R38              R38--;
5e97: 05,34               decw  R34              R34--;                            # CkSum
5e99: 8b,f4,54,3c         cmpw  R3c,[Rf4+54]                                       # 902A - PSIBR M
5e9d: d6,16               jge   5eb5             if (R3c < Psibrm)  {
5e9f: 07,3c               incw  R3c              R3c++;
5ea1: 20,12               sjmp  5eb5             goto 5eb5;
5ea3: 8b,f4,54,38         cmpw  R38,[Rf4+54]                                       # 902A - PSIBR M
5ea7: d6,1a               jge   5ec3             if (R38 >= Psibrm) return;
5ea9: 07,38               incw  R38              R38++;
5eab: 07,34               incw  R34              R34++;                            # CkSum
5ead: 8b,f4,56,3c         cmpw  R3c,[Rf4+56]                                       # 902C - PSIBRN
5eb1: da,02               jle   5eb5             if ((uns) R3c < Psibrn)  {
5eb3: 05,3c               decw  R3c              R3c--; } }
5eb5: c3,33,e4,07,38      stw   R38,[R32+7e4]    [R32+KIsckam0L] = R38;            # ISCKAMOL
5eba: c3,72,d4,3c         stw   R3c,[R72+d4]     Ipsibr = R3c;                     # 154 IPSIBR
5ebe: c3,01,ec,07,34      stw   R34,[R0+7ec]     KIsksum = R34; }                  # KAM Table 2 checksum ISKSUM
5ec3: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 44
# SCCS stuff checks VBAT
#################################################################


  Upd_VSC:
5ec4: b1,02,30            ldb   R30,2            R30 = 2;
5ec7: 9b,f2,47,30         cmpb  R30,[Rf2+47]                                       # 8EA0 SCCS Frequency - Desired VSC Frequency, Hz
5ecb: d7,0a               jne   5ed7             if (R30 != Vstype) goto 5ed7;
5ecd: b3,74,93,30         ldb   R30,[R74+93]     R30 = Vbat;                       # 211 Battery Voltage Level * 16
5ed1: 9b,f2,45,30         cmpb  R30,[Rf2+45]                                       # 8E9E = 26(38)HLDRNG - Error deadband for no pulses required.
5ed5: d9,07               jgtu  5ede             if ((uns) R30 <= Lowbat)  {       # jmp battery voltage > ROM limit
# Battery voltage insufficient
5ed7: b1,80,b5            ldb   Rb5,80           Vsc_flagsb = 80;                  # SCCS force OFF BUTTON only
5eda: 11,a0               clrb  Ra0              Vsc_states = 0;                   # SCCS state clear all
# Battery voltage is OK
5edc: 20,02               sjmp  5ee0             goto 5ee0; }
5ede: 28,07               scall 5ee7             Upd_SCCS();                       # Update Vehicle Speed Control(VSC)SCCS
5ee0: 28,8f               scall 5f71             Sub32();
5ee2: 29,a3               scall 6087             Sub33();
5ee4: 29,e9               scall 60cf             Sub34();
5ee6: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 6A
# Read Cruise control buttons (SCCS)
# Update Vehicle Speed Control(VSC)
# set VSC bits in RB5 & RA0 based on ABS voltage **CHANGE** on AD channel 4 (SCCS)
#################################################################


  Upd_SCCS:
5ee7: a3,72,98,38         ldw   R38,[R72+98]     R38 = Vsc_Raw;                    # AD channel 4 118 Cruise control buttons - Vehicle Speed Control Command Switch
5eeb: 4b,76,32,38,3a      sb3w  R3a,R38,[R76+32] R3a = R38 - Ivsccs_lst;           # difference to old value of buttons
5ef0: db,02               jc    5ef4             if (R3a > 0)  {
5ef2: 03,3a               negw  R3a              R3a = -R3a; }                     # ABS difference
5ef4: 8b,f2,12,3a         cmpw  R3a,[Rf2+12]                                       # 8E6C - Min change in IVSCCS to reset the debounce timer
5ef8: d1,0c               jleu  5f06             if ((uns) R3a > Debamp )  {
5efa: c3,76,32,38         stw   R38,[R76+32]     Ivsccs_lst = R38;                 # 3AC IVSCCS LST - Previous valid SCCS input
5efe: a3,f2,30,3a         ldw   R3a,[Rf2+30]     R3a = Debtim;                     # 8E8A - DEBTIM - Debounce time delay, seconds
5f02: c3,74,2a,3a         stw   R3a,[R74+2a]     Debtmr = R3a; }                   # 2A8 timer? DEBOUNCE timer
5f06: 8b,74,2a,00         cmpw  R0,[R74+2a]                                        # zero 2A8 timer? DEBOUNCE timer
5f0a: d7,04               jne   5f10             if (0 = Debtmr)  {
5f0c: c3,74,36,38         stw   R38,[R74+36]     Vsccs = R38; }                    # input, debounced counts
5f10: a3,74,36,38         ldw   R38,[R74+36]     R38 = Vsccs;
5f14: 71,02,b5            an2b  Rb5,2            B0_Vsc_flagsb = 0;
                                                 B2_Vsc_flagsb = 0;
                                                 SCCS_Resume = 0;
                                                 SCCS_Accel = 0;
                                                 SCCS_Coast = 0;
                                                 SCCS_On = 0;
                                                 SCCS_Off = 0;                     # check for SCCS error
5f17: 8b,f2,14,38         cmpw  R38,[Rf2+14]                                       # 8E6E - HI OFF - Input VSC command Switch input range, counts
5f1b: db,04               jc    5f21             if (R38 > Hi_off)  {
5f1d: 91,80,b5            orb   Rb5,80           SCCS_Off = 1;                     # set RB5 bit 7 OFF BUTTON
5f20: f0                  ret                    return; }

5f21: 8b,f2,16,38         cmpw  R38,[Rf2+16]                                       # 8E70 - LOW ON - Input VSCCS input range, counts.
5f25: d1,04               jleu  5f2b             if ((uns) R38 > Low_on )  {
5f27: 91,80,a0            orb   Ra0,80           On_state = 1;                     # set RA0 bit 7 ON STATE
5f2a: f0                  ret                    return; }

5f2b: 8b,f2,18,38         cmpw  R38,[Rf2+18]                                       # 8E72 - LCOAST - Input VSCCS input range, counts.
5f2f: d1,0a               jleu  5f3b             if ((uns) R38 > Lcoast )  {
5f31: 8b,f2,1a,38         cmpw  R38,[Rf2+1a]                                       # 8E74 - HCOAST - Input VSCCS input range, counts.
5f35: db,04               jc    5f3b             if (R38 > Hcoast)  {
5f37: 91,20,b5            orb   Rb5,20           SCCS_Coast = 1;                   # set RB5 bit 5 COAST BUTTON
5f3a: f0                  ret                    return; } }

5f3b: 8b,f2,1c,38         cmpw  R38,[Rf2+1c]                                       # 8E76 - LACCEL - Input VSCCS input range, counts.
5f3f: d1,0a               jleu  5f4b             if ((uns) R38 > Laccel )  {
5f41: 8b,f2,1e,38         cmpw  R38,[Rf2+1e]                                       # 8E78 - HACCEL - Input VSCCS input range, counts.
5f45: db,04               jc    5f4b             if (R38 > Haccel)  {
5f47: 91,10,b5            orb   Rb5,10           SCCS_Accel = 1;                   # set RB5 bit 4 ACCELORATE BUTTON
5f4a: f0                  ret                    return; } }

5f4b: 8b,f2,20,38         cmpw  R38,[Rf2+20]                                       # 8E7A - LRESUM - Input VSCCS input range, counts.
5f4f: d1,0a               jleu  5f5b             if ((uns) R38 > Lresum )  {
5f51: 8b,f2,22,38         cmpw  R38,[Rf2+22]                                       # 8E7C - HRESUM - Input VSCCS input range, counts.
5f55: db,04               jc    5f5b             if (R38 > Hresum)  {
5f57: 91,08,b5            orb   Rb5,8            SCCS_Resume = 1;                  # set RB5 bit 3 RESUME BUTTON
5f5a: f0                  ret                    return; } }

5f5b: 8b,f2,24,38         cmpw  R38,[Rf2+24]                                       # 8E7E - LOHOLD - Input VSCCS input range, counts.
5f5f: d1,09               jleu  5f6a             if ((uns) R38 > Lohold )  {
5f61: 8b,f2,26,38         cmpw  R38,[Rf2+26]                                       # 8E80 - HIHOLD - Input VSCCS input range, counts.
5f65: db,03               jc    5f6a             if (R38 > Hihold)  {
5f67: 11,b5               clrb  Rb5              Vsc_flagsb = 0;                   # clr all bits in RB5
5f69: f0                  ret                    return; } }

5f6a: 91,02,b5            orb   Rb5,2            SCCS_error = 1;                   # set RB5 bit 1 button voltage range error
5f6d: 71,7f,a0            an2b  Ra0,7f           On_state = 0;                     # clr RA0 bit 7 clr ON state
5f70: f0                  ret                    return;

################################################################


  Sub32:
5f71: 30,2a,0a            jnb   B0,R2a,5f7e      if (Vscdt = 1)  {                 # jump if not VIP mode flag : VSCDT
5f74: a0,ae,3c            ldw   R3c,Rae          R3c = Rpmx4;
5f77: 09,02,3c            shlw  R3c,2            R3c *= 4;                         # x4
5f7a: c3,74,2e,3c         stw   R3c,[R74+2e]     Mph_FiltA = R3c; }                # SCCS vehicle speed in MPH filtered 2
5f7e: a3,74,2e,3c         ldw   R3c,[R74+2e]     R3c = Mph_FiltA;                  # SCCS vehicle speed in MPH filtered 2
5f82: 37,a0,03            jnb   B7,Ra0,5f88      if (On_state = 0) goto 5f88;      # SCCS on state
5f85: 37,b5,07            jnb   B7,Rb5,5f8f      if (SCCS_Off = 1)  {              # SCCS OFF buttob
5f88: 11,a0               clrb  Ra0              Vsc_states = 0;
5f8a: c3,74,30,00         stw   R0,[R74+30]      Res_speed = 0;
5f8e: f0                  ret                    return; }

5f8f: 38,2a,50            jb    B0,R2a,5fe2      if (Vscdt = 1) goto 5fe2;         # jump if VIP mode flag : VSCDT
5f92: a3,f2,32,38         ldw   R38,[Rf2+32]     R38 = Minvsp;
5f96: 88,38,3c            cmpw  R3c,R38          
5f99: db,03               jc    5f9e             if (R3c > R38)  {
5f9b: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5f9e: 67,f2,3a,38         ad2w  R38,[Rf2+3a]     R38 += Mphh;
5fa2: db,08               jc    5fac             if (R38 > 0)  {
5fa4: 88,38,3c            cmpw  R3c,R38          
5fa7: d1,03               jleu  5fac             if ((uns) R3c > R38 )  {
5fa9: 71,df,c4            an2b  Rc4,df           Vscq1 = 0; } }
5fac: 31,b5,03            jnb   B1,Rb5,5fb2      if (SCCS_error = 1)  {            # SCCS Button voltage range error
5faf: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5fb2: a3,f2,36,38         ldw   R38,[Rf2+36]     R38 = Vsnmax;
5fb6: 88,ae,38            cmpw  R38,Rae          
5fb9: db,03               jc    5fbe             if (R38 > Rpmx4)  {
5fbb: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5fbe: 3d,c4,1d            jb    B5,Rc4,5fde      if (Vscq1 = 1) goto 5fde;
5fc1: a3,f2,34,38         ldw   R38,[Rf2+34]     R38 = Maxvsp;
5fc5: 88,38,3c            cmpw  R3c,R38          
5fc8: d1,03               jleu  5fcd             if ((uns) R3c > R38 )  {
5fca: 91,10,c4            orb   Rc4,10           Vscq2 = 1; }
5fcd: 6b,f2,3a,38         sb2w  R38,[Rf2+3a]     R38 -= Mphh;
5fd1: d3,08               jnc   5fdb             if ((uns) R38 >= 0)  {
5fd3: 88,38,3c            cmpw  R3c,R38          
5fd6: db,03               jc    5fdb             if (R3c > R38)  {
5fd8: 71,ef,c4            an2b  Rc4,ef           Vscq2 = 0; } }
5fdb: 34,c4,07            jnb   B4,Rc4,5fe5      if (Vscq2 = 0) goto 5fe5;
5fde: 71,a0,a0            an2b  Ra0,a0           Vsc_pulse = 0;
                                                 Acc_req = 0;
                                                 Hold_state = 0;
                                                 Resum_state = 0;
                                                 Accel_state = 0;
                                                 Coast_state = 0;
5fe1: f0                  ret                    return;

5fe2: 31,ea,19            jnb   B1,Rea,5ffe      if (Biflg = 1)  {                 # BIFLG = If equal to 1, Brake is on.
5fe5: 39,ea,09            jb    B1,Rea,5ff1      if (Biflg = 1) goto 5ff1;         # BIFLG = If equal to 1, Brake is on.
5fe8: 3f,e7,13            jb    B7,Re7,5ffe      if (Ndsflg = 0)  {
5feb: 9b,fe,02,00         cmpb  R0,[Rfe+2]                                         # 9E5C
5fef: df,0d               je    5ffe             if (0 != TRLOAD)  {
5ff1: b1,a0,a0            ldb   Ra0,a0           Vsc_states = a0;
5ff4: 51,38,b5,00         an3b  R0,Rb5,38        R0 = Vsc_flagsb & 38;             # ck SCCS buttons: RESUME, COAST, ACCELL
5ff8: df,03               je    5ffd             if (R0 = 0) return;
5ffa: 91,02,b5            orb   Rb5,2            SCCS_error = 1; }                 # set SCCS button Range error
5ffd: f0                  ret                    return; } } }

5ffe: 35,b5,05            jnb   B5,Rb5,6006      if (SCCS_Coast = 1)  {            # SCCS COAST button
6001: b1,c0,a0            ldb   Ra0,c0           Vsc_states = c0;
6004: 20,06               sjmp  600c             goto 600c; }
6006: 36,a0,0c            jnb   B6,Ra0,6015      if (Coast_state = 1)  {
6009: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
600c: c3,74,32,3c         stw   R3c,[R74+32]     Set_speed = R3c;
6010: c3,74,30,3c         stw   R3c,[R74+30]     Res_speed = R3c;
6014: f0                  ret                    return; }

6015: 34,b5,0c            jnb   B4,Rb5,6024      if (SCCS_Accel = 1)  {            # SCCS ACCEL button
6018: 3c,a0,04            jb    B4,Ra0,601f      if (Accel_state = 0)  {
601b: c3,74,32,3c         stw   R3c,[R74+32]     Set_speed = R3c; }
601f: b1,91,a0            ldb   Ra0,91           Vsc_states = 91;
6022: 20,0a               sjmp  602e             goto 602e; }
6024: 34,a0,0c            jnb   B4,Ra0,6033      if (Accel_state = 1)  {
6027: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
602a: c3,74,32,3c         stw   R3c,[R74+32]     Set_speed = R3c;
602e: c3,74,30,3c         stw   R3c,[R74+30]     Res_speed = R3c;
6032: f0                  ret                    return; }

6033: 3b,a0,1b            jb    B3,Ra0,6051      if (Resum_state = 0)  {
6036: 3d,d9,10            jb    B5,Rd9,6049      if (Vvsfl1 = 1) goto 6049;
6039: 33,b5,15            jnb   B3,Rb5,6051      if (SCCS_Resume = 1)  {           # SCCS RESUME button
603c: 35,a0,12            jnb   B5,Ra0,6051      if (Brake_state = 1)  {
603f: a3,74,30,38         ldw   R38,[R74+30]     R38 = Res_speed;
6043: 8b,f2,32,38         cmpw  R38,[Rf2+32]     
6047: d1,08               jleu  6051             if ((uns) R38 > Minvsp )  {
6049: b1,89,a0            ldb   Ra0,89           Vsc_states = 89;
604c: c3,74,32,3c         stw   R3c,[R74+32]     Set_speed = R3c;
6050: f0                  ret                    return; } } } }

6051: 33,a0,0a            jnb   B3,Ra0,605e      if (Resum_state = 1)  {
6054: 8b,74,30,3c         cmpw  R3c,[R74+30]     
6058: db,04               jc    605e             if (R3c > Res_speed)  {
605a: b1,8b,a0            ldb   Ra0,8b           Vsc_states = 8b;
605d: f0                  ret                    return; } }

605e: 33,a0,0c            jnb   B3,Ra0,606d      if (Resum_state = 1)  {
6061: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
6064: a3,74,30,38         ldw   R38,[R74+30]     R38 = Res_speed;
6068: c3,74,32,38         stw   R38,[R74+32]     Set_speed = R38;
606c: f0                  ret                    return; }

606d: 32,a0,16            jnb   B2,Ra0,6086      if (Hold_state = 1)  {
6070: a3,74,32,38         ldw   R38,[R74+32]     R38 = Set_speed;
6074: 68,3c,38            sb2w  R38,R3c          R38 -= R3c;
6077: d3,06               jnc   607f             if ((uns) R38 < 0) goto 607f;
6079: 8b,f2,38,38         cmpw  R38,[Rf2+38]     
607d: d9,04               jgtu  6083             if ((uns) R38 <= Mphded)  {
607f: 91,01,a0            orb   Ra0,1            Vsc_pulse = 1;
6082: f0                  ret                    return; }

6083: b1,a0,a0            ldb   Ra0,a0           Vsc_states = a0; }
6086: f0                  ret                    return;


  Sub33:
6087: 3c,b5,03            jb    B4,Rb5,608d      if (SCCS_Accel = 1) goto 608d;    # SCCS ACCEL button
608a: 31,a0,3d            jnb   B1,Ra0,60ca      if (Acc_req = 1)  {
608d: 4b,f2,3c,3c,32      sb3w  R32,R3c,[Rf2+3c] R32 = R3c - Aclded;
6092: db,03               jc    6097             if (R32 > 0)  {
6094: a0,00,32            ldw   R32,R0           R32 = 0; }
6097: 8b,74,32,32         cmpw  R32,[R74+32]     
609b: d1,06               jleu  60a3             if ((uns) R32 > Set_speed )  {
609d: c3,74,32,3c         stw   R3c,[R74+32]     Set_speed = R3c;
60a1: 20,27               sjmp  60ca             goto 60ca; }
60a3: 4b,74,2c,06,38      sb3w  R38,R6,[R74+2c]  R38 = IO_Timer - Ltime;
60a8: 30,2a,07            jnb   B0,R2a,60b2      if (Vscdt = 1)  {                 # jump if not VIP mode flag : VSCDT
60ab: a3,f3,64,01,30      ldw   R30,[Rf2+164]    R30 = Vacrr;
60b0: 20,04               sjmp  60b6             goto 60b6; }
60b2: a3,f2,3e,30         ldw   R30,[Rf2+3e]     R30 = Aclinc;
60b6: 6d,44,28,38         ml2w  R38,2844         R38 *= 2844;
60ba: 6c,3a,30            ml2w  R30,R3a          R30 *= R3a;
60bd: 67,74,32,32         ad2w  R32,[R74+32]     R32 += Set_speed;
60c1: d3,03               jnc   60c6             if ((uns) R32 >= 0)  {
60c3: bd,ff,32            ldsbw R32,ff           R32 = (int)ff; }
60c6: c3,74,32,32         stw   R32,[R74+32]     Set_speed = R32; }
60ca: c3,74,2c,06         stw   R6,[R74+2c]      Ltime = IO_Timer;
60ce: f0                  ret                    return;


  Sub34:
60cf: 30,2a,1d            jnb   B0,R2a,60ef      if (Vscdt = 1)  {                 # jump if not VIP mode flag : VSCDT
60d2: 3d,d9,04            jb    B5,Rd9,60d9      if (Vvsfl1 = 0)  {
60d5: b1,ff,9b            ldb   R9b,ff           Vsc_count = ff;
60d8: f0                  ret                    return; }

60d9: a3,f3,5a,01,14      ldw   R14,[Rf2+15a]    R14 = Vstgn;
60de: a3,f3,5c,01,18      ldw   R18,[Rf2+15c]    R18 = Vvhgn;
60e3: a3,f3,5e,01,38      ldw   R38,[Rf2+15e]    R38 = Vtpgn;
60e8: a3,f3,70,01,42      ldw   R42,[Rf2+170]    R42 = Vdcbia;
60ed: 20,10               sjmp  60ff             goto 60ff; }
60ef: a3,f2,2a,14         ldw   R14,[Rf2+2a]     R14 = Setgn;
60f3: a3,f2,2c,18         ldw   R18,[Rf2+2c]     R18 = Vehgn;
60f7: a3,f2,2e,38         ldw   R38,[Rf2+2e]     R38 = Tapgn;
60fb: a3,f2,28,42         ldw   R42,[Rf2+28]     R42 = Dcbias;
60ff: 30,a0,21            jnb   B0,Ra0,6123      if (Vsc_pulse = 0) goto 6123;
6102: 6f,74,32,14         ml2w  R14,[R74+32]     R14 *= Set_speed;
6106: 64,42,16            ad2w  R16,R42          R16 += R42;
6109: 6f,74,2e,18         ml2w  R18,[R74+2e]     R18 *= Mph_FiltA;                 # SCCS vehicle speed in MPH filtered 2
610d: 68,1a,16            sb2w  R16,R1a          R16 -= R1a;
6110: d3,11               jnc   6123             if ((uns) R16 < 0) goto 6123;
6112: 4b,72,a6,aa,18      sb3w  R18,Raa,[R72+a6] R18 = TP - TPS_Min;               # RAA is Throttle position, 126 - RATCH=Closed TP
6117: db,02               jc    611b             if (R18 > 0)  {
6119: 01,18               clrw  R18              R18 = 0; }
611b: 6c,38,18            ml2w  R18,R38          R18 *= R38;
611e: 68,1a,16            sb2w  R16,R1a          R16 -= R1a;
6121: db,02               jc    6125             if (R16 > 0)  {
6123: 01,16               clrw  R16              R16 = 0; }
6125: a0,16,14            ldw   R14,R16          R14 = R16;
6128: 08,01,16            shrw  R16,1            R16 /= 2;
612b: c3,74,38,16         stw   R16,[R74+38]     Vsc_error = R16;
612f: 11,16               clrb  R16              R16 = 0;
6131: 6b,f2,40,14         sb2w  R14,[Rf2+40]     R14 -= Hldref;
6135: d9,04               jgtu  613b             if ((uns) R14 <= 0)  {
6137: 03,14               negw  R14              R14 = -R14;
6139: 17,16               incb  R16              R16++; }
613b: 89,80,00,14         cmpw  R14,80           
613f: d1,03               jleu  6144             if ((uns) R14 > 80 )  {
6141: b1,80,14            ldb   R14,80           R14 = 80; }
6144: 9b,f2,44,14         cmpb  R14,[Rf2+44]     
6148: d9,02               jgtu  614c             if ((uns) R14 <= Hldrng)  {
614a: 11,14               clrb  R14              R14 = 0; }
614c: c7,74,3c,14         stb   R14,[R74+3c]     Vsc_dc = R14;                     # set 2BB - timer?
6150: a1,d0,07,38         ldw   R38,7d0          R38 = 7d0;
6154: 9f,f2,46,38         divb  R38,[Rf2+46]     R38 /= Vscfrq;
6158: 5c,38,14,18         ml3b  R18,R14,R38      R18 = R14 * R38;
615c: 65,80,00,18         ad2w  R18,80           R18 += 80;
6160: 30,38,02            jnb   B0,R38,6165      if (B0_R38 = 1)  {
6163: 17,38               incb  R38              R38++; }
6165: 18,01,38            shrb  R38,1            R38 /= 2;
6168: fa                  di                     disable ints;
6169: ff                  nop                    
616a: 30,16,05            jnb   B0,R16,6172      if (Vsc_flg1 = 0) goto 6172;
616d: 3e,c4,05            jb    B6,Rc4,6175      if (Vsc_vac_active = 1) goto 6175;
6170: 20,12               sjmp  6184             goto 6184;
6172: 3e,c4,0f            jb    B6,Rc4,6184      if (Vsc_vac_active = 0)  {
6175: 95,40,c4            xorb  Rc4,40           Vsc_vac_active ^= 1;
6178: 71,fe,46            an2b  R46,fe           Scvac = 0;                        # LSO output line 0 OFF (Speed Control Vacuum)
617b: 91,10,46            orb   R46,10           Scvnt = 1;                        # LSO output line 4 ON (Speed Control Vent)
617e: 71,f7,c4            an2b  Rc4,f7           Vsc_state = 0;
6181: b1,01,9b            ldb   R9b,1            Vsc_count = 1; }
6184: c7,74,3b,19         stb   R19,[R74+3b]     Vsc_on_count = R19;
6188: 78,19,38            sb2b  R38,R19          R38 -= R19;
618b: c7,74,3a,38         stb   R38,[R74+3a]     Vsc_off_count = R38;
618f: fb                  ei                     enable ints;
6190: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 3A
#################################################################


  Upd_air_mgt:
6191: b3,f6,17,38         ldb   R38,[Rf6+17]     R38 = [93bf];
6195: b3,f6,16,39         ldb   R39,[Rf6+16]     R39 = [93be];
6199: 98,38,b0            cmpb  Rb0,R38          
619c: da,0a               jle   61a8             if ((uns) ECT < R38)  {
619e: 98,39,b1            cmpb  Rb1,R39                                            # RB1 = ACT (ACT = RB1 * 4)
61a1: da,05               jle   61a8             if ((uns) ACT < R39)  {
61a3: 91,08,29            orb   R29,8            Taq1 = 1;
61a6: 20,1f               sjmp  61c7             goto 61c7; } }
61a8: 7b,f6,18,38         sb2b  R38,[Rf6+18]     R38 -= [93c0];
61ac: d5,03               jnv   61b1             if (OVF = 1)  {
61ae: b1,80,38            ldb   R38,80           R38 = 80; }
61b1: 98,38,b0            cmpb  Rb0,R38          
61b4: de,0e               jlt   61c4             if (ECT < R38) goto 61c4;
61b6: 7b,f6,18,39         sb2b  R39,[Rf6+18]     R39 -= [93c0];
61ba: d5,03               jnv   61bf             if (OVF = 1)  {
61bc: b1,80,39            ldb   R39,80           R39 = 80; }
61bf: 98,39,b1            cmpb  Rb1,R39                                            # RB1 = ACT (ACT = RB1 * 4)
61c2: d6,03               jge   61c7             if (ACT < R39)  {
61c4: 71,f7,29            an2b  R29,f7           Taq1 = 0; }
61c7: 91,80,25            orb   R25,80           Chkair_flag = 1;
61ca: 3b,29,1f            jb    B3,R29,61ec      if (Taq1 = 1) goto 61ec;
61cd: 31,ed,11            jnb   B1,Red,61e1      if (Legofg1 = 0) goto 61e1;
61d0: b3,fe,16,30         ldb   R30,[Rfe+16]     R30 = No_hegos;                   # 9E70 no of HEGOs
61d4: 99,01,30            cmpb  R30,1            
61d7: df,13               je    61ec             if (R30 = 1) goto 61ec;
61d9: 99,02,30            cmpb  R30,2            
61dc: d7,03               jne   61e1             if (R30 != 2) goto 61e1;
61de: 38,ed,0b            jb    B0,Red,61ec      if (Legofg2 = 1) goto 61ec;
61e1: 99,01,d0            cmpb  Rd0,1            
61e4: d7,09               jne   61ef             if (Apt = 1)  {
61e6: 9b,f6,15,cb         cmpb  Rcb,[Rf6+15]                                       # timer?
61ea: d3,03               jnc   61ef             if ((uns) Awotmr >= [93bd])  {
61ec: 71,7f,25            an2b  R25,7f           Chkair_flag = 0; } }
61ef: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = Thrmhp;                     # 9E65 thermactor present switch = 1.0
61f3: 99,01,30            cmpb  R30,1            
61f6: df,0c               je    6204             if (R30 != 1)  {
61f8: 91,40,25            orb   R25,40           Chkair = 1;
61fb: 3f,25,03            jb    B7,R25,6201      if (Chkair_flag = 0)  {
61fe: 71,bf,25            an2b  R25,bf           Chkair = 0; }
6201: e7,b0,00            jump  62b4             return; }
6204: 71,7f,ca            an2b  Rca,7f           Usaflg = 0;
6207: 51,b8,c5,30         an3b  R30,Rc5,b8       R30 = Fmem_flags & b8;            # clr bits 6, 2, 1, 0
620b: df,08               je    6215             if (R30 != 0)  {
620d: 71,ef,47            an2b  R47,ef           Iac = 0;                          # R47 bit 4 OFF (Air Management 2)
6210: 71,f7,47            an2b  R47,f7           Sbs1 = 0;                         # R47 bit 3 OFF (Air Management 1)
6213: 27,e3               sjmp  61f8             goto 61f8; }
6215: a3,f6,2c,38         ldw   R38,[Rf6+2c]     R38 = [93d4];
6219: 4b,f6,2e,38,3a      sb3w  R3a,R38,[Rf6+2e] R3a = R38 - [93d6];
621e: db,02               jc    6222             if (R3a > 0)  {
6220: 01,3a               clrw  R3a              R3a = 0; }
6222: 8b,74,de,3a         cmpw  R3a,[R74+de]                                       # engine load (VE? )
6226: d1,05               jleu  622d             if ((uns) R3a > Load )  {
6228: 91,02,29            orb   R29,2            Taq6 = 1;
622b: 20,09               sjmp  6236             goto 6236; }
622d: 8b,74,de,38         cmpw  R38,[R74+de]                                       # engine load (VE? )
6231: db,03               jc    6236             if (R38 > Load)  {
6233: 71,fd,29            an2b  R29,fd           Taq6 = 0; }
6236: 3f,a1,10            jb    B7,Ra1,6249      if (Cranking = 1) goto 6249;
6239: 37,25,0d            jnb   B7,R25,6249      if (Chkair_flag = 0) goto 6249;
623c: 45,0e,00,f6,30      ad3w  R30,Rf6,e        R30 = 93b6;                       # 93B6
6241: ef,0b,d5            call  374f             Check_Timers();
6244: db,03               jc    6249             if ((uns) R30 >= 0) goto 6249;
6246: 32,e7,0b            jnb   B2,Re7,6254      if (Hspflg = 1)  {
6249: 71,bf,25            an2b  R25,bf           Chkair = 0;
624c: 71,ef,47            an2b  R47,ef           Iac = 0;                          # R47 bit 4 OFF (Air Management 2)
624f: 71,f7,47            an2b  R47,f7           Sbs1 = 0;                         # R47 bit 3 OFF (Air Management 1)
6252: 20,60               sjmp  62b4             return; }
6254: 45,26,00,f6,30      ad3w  R30,Rf6,26       R30 = 93ce;                       # 93CE
6259: ef,f3,d4            call  374f             Check_Timers();
625c: db,4a               jc    62a8             if ((uns) R30 >= 0) goto 62a8;
625e: 9b,f6,1f,c8         cmpb  Rc8,[Rf6+1f]     
6262: d9,0b               jgtu  626f             if ((uns) Atmr1 > [93c7] ) goto 626f;
6264: 99,01,d0            cmpb  Rd0,1            
6267: d7,06               jne   626f             if (Apt != 1) goto 626f;
6269: 9b,f6,2b,cb         cmpb  Rcb,[Rf6+2b]                                       # timer?
626d: d3,39               jnc   62a8             if ((uns) Awotmr < [93d3]) goto 62a8;
626f: 33,eb,0a            jnb   B3,Reb,627c      if (Ctaflg = 0) goto 627c;
6272: b3,72,b8,38         ldb   R38,[R72+b8]     R38 = Ctatmr;                     # 138 timer?
6276: 9b,f6,1e,38         cmpb  R38,[Rf6+1e]     
627a: db,2c               jc    62a8             if ((uns) R38 >= [93c6]) goto 62a8;
627c: 32,eb,10            jnb   B2,Reb,628f      if (Hmtmr_On = 0) goto 628f;
627f: b3,72,b7,38         ldb   R38,[R72+b7]     R38 = Hmtmr;                      # 137 timer?
6283: 9b,f6,20,38         cmpb  R38,[Rf6+20]     
6287: d9,06               jgtu  628f             if ((uns) R38 > [93c8] ) goto 628f;
6289: 9b,f6,1f,c8         cmpb  Rc8,[Rf6+1f]     
628d: d1,19               jleu  62a8             if ((uns) Atmr1 <= [93c7]) goto 62a8;
628f: 91,40,25            orb   R25,40           Chkair = 1;
6292: 9b,f6,37,ce         cmpb  Rce,[Rf6+37]                                       # RCE timer?
6296: d9,b4               jgtu  624c             if ((uns) Mfatmr > [93df] ) goto 624c;
6298: 39,29,08            jb    B1,R29,62a3      if (Taq6 = 0)  {
629b: 9b,f6,30,cd         cmpb  Rcd,[Rf6+30]                                       # timer?
629f: d1,02               jleu  62a3             if ((uns) Nactmr <= [93d8]) goto 62a3;
62a1: 27,a9               sjmp  624c             goto 624c; }
62a3: 71,ef,47            an2b  R47,ef           Iac = 0;                          # R47 bit 4 OFF (Air Management 2)
62a6: 20,09               sjmp  62b1             goto 62b1;
62a8: 91,80,ca            orb   Rca,80           Usaflg = 1;
62ab: 71,bf,25            an2b  R25,bf           Chkair = 0;
62ae: 91,10,47            orb   R47,10           Iac = 1;                          # R47 bit 4 ON (Air Management 2)
62b1: 91,08,47            orb   R47,8            Sbs1 = 1;                         # R47 bit 3 ON (Air Management 1)
62b4: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 3C
#################################################################


  Upd_HiFan:
62b5: 9b,f6,39,00         cmpb  R0,[Rf6+39]                                        # 93E1 - ECADHP
62b9: df,79               je    6334             if (0 != EcadHP)  {               # return if h/w not present
62bb: 9b,f6,3a,b0         cmpb  Rb0,[Rf6+3a]                                       # ROM 93E2 - ECADECT
62bf: d6,05               jge   62c6             if (ECT < ECADQ1)  {
62c1: 91,40,ca            orb   Rca,40           Ecadq1 = 1;                       # set ECADQ1
62c4: 20,09               sjmp  62cf             goto 62cf; }
62c6: 9b,f6,3d,b0         cmpb  Rb0,[Rf6+3d]                                       # ROM 93E5 - EDETHYS
62ca: da,03               jle   62cf             if ((uns) ECT < [93e5])  {
62cc: 71,bf,ca            an2b  Rca,bf           Ecadq1 = 0; }                     # clr ECADQ1
62cf: b3,74,21,42         ldb   R42,[R74+21]     R42 = N_byte;                     # 29F - N BYTE
62d3: 9b,f6,3b,42         cmpb  R42,[Rf6+3b]                                       # 93E3 - ECADN
62d7: d1,05               jleu  62de             if ((uns) R42 > ECadn )  {
62d9: 91,20,ca            orb   Rca,20           Ecadq2 = 1;                       # set ECADQ2
62dc: 20,09               sjmp  62e7             goto 62e7; }
62de: 9b,f6,3e,42         cmpb  R42,[Rf6+3e]                                       # 93E6 - EDNHYS
62e2: db,03               jc    62e7             if (R42 > EDNHYS)  {
62e4: 71,df,ca            an2b  Rca,df           Ecadq2 = 0; }                     # clr ECADQ2
62e7: b3,74,3f,30         ldb   R30,[R74+3f]     R30 = Mph_FiltH;                  # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
62eb: 9b,f6,3c,30         cmpb  R30,[Rf6+3c]                                       # 93E4 - ECADVS
62ef: d1,05               jleu  62f6             if ((uns) R30 > ECADVS )  {
62f1: 91,10,ca            orb   Rca,10           Ecadq3 = 1;                       # set ECADQ3
62f4: 20,09               sjmp  62ff             goto 62ff; }
62f6: 9b,f6,3f,30         cmpb  R30,[Rf6+3f]                                       # 93E7 - EDVSHYS
62fa: db,03               jc    62ff             if (R30 > EDVSHYS)  {
62fc: 71,ef,ca            an2b  Rca,ef           Ecadq3 = 0; }                     # clr ECADQ3
62ff: 51,b8,c5,42         an3b  R42,Rc5,b8       R42 = Fmem_flags & b8;
6303: d7,2c               jne   6331             if (R42 = 0)  {
6305: b3,fe,0b,42         ldb   R42,[Rfe+b]      R42 = Thrmhp;                     # 9E65 thermactor present switch = 1.0
6309: 99,01,42            cmpb  R42,1            
630c: d7,03               jne   6311             if (R42 != 1) goto 6311;          # jmp if no Thermactor present
630e: 37,ca,0f            jnb   B7,Rca,6320      if (Usaflg = 0) goto 6320;        # jmp if not USAFLG
6311: 45,40,00,f6,30      ad3w  R30,Rf6,40       R30 = EDTM3;                      # 93E8 - EDTM3
6316: ef,36,d4            call  374f             Check_Timers();
6319: d3,16               jnc   6331             if ((uns) R30 >= 0)  {
631b: 98,42,00            cmpb  R0,R42           
631e: d7,11               jne   6331             if (0 = R42)  {
6320: 32,df,0e            jnb   B2,Rdf,6331      if (Ecadi = 1)  {                 # jmp if not ECADI
6323: 36,ca,0b            jnb   B6,Rca,6331      if (Ecadq1 = 1)  {                # jmp if not ECADQ1
6326: 35,ca,08            jnb   B5,Rca,6331      if (Ecadq2 = 1)  {                # jmp if not ECADQ2
6329: 34,ca,05            jnb   B4,Rca,6331      if (Ecadq3 = 1)  {                # jmp if not ECADQ3
632c: 71,bf,47            an2b  R47,bf           Hi_fan = 0;                       # R47 bit 6 OFF (Fan)HI FAN
632f: 20,03               sjmp  6334             return; } } } } } } }
6331: 91,40,47            orb   R47,40           Hi_fan = 1; }                     # R47 bit 6 ON (Fan)HI FAN
6334: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 3E
# Update Canister Purge timing
#################################################################


  Upd_canpTm:
6335: b3,f6,45,14         ldb   R14,[Rf6+45]     R14 = [93ed];
6339: 98,14,b0            cmpb  Rb0,R14          
633c: da,03               jle   6341             if ((uns) ECT < R14)  {
633e: 71,f7,ed            an2b  Red,f7           Hvq1 = 0; }
6341: 7b,f6,46,14         sb2b  R14,[Rf6+46]     R14 -= [93ee];
6345: 98,14,b0            cmpb  Rb0,R14          
6348: d6,03               jge   634d             if (ECT < R14)  {
634a: 91,08,ed            orb   Red,8            Hvq1 = 1; }
634d: 71,bf,e9            an2b  Re9,bf           CanPurgeOK = 0;
6350: 45,4e,00,f6,30      ad3w  R30,Rf6,4e       R30 = 93f6;                       # 93F6 - Canister purge hot startup delay time.
6355: ef,f7,d3            call  374f             Check_Timers();
6358: d3,02               jnc   635c             if ((uns) R30 < 0) goto 635c;
635a: 20,59               sjmp  63b5             goto 63b5;
635c: 33,ed,56            jnb   B3,Red,63b5      if (Hvq1 = 1)  {
635f: 9b,f6,48,cd         cmpb  Rcd,[Rf6+48]                                       # timer?
6363: d3,50               jnc   63b5             if ((uns) Nactmr >= [93f0])  {
6365: 32,ee,06            jnb   B2,Ree,636e      if (Olflg = 0) goto 636e;
6368: 9b,f6,47,00         cmpb  R0,[Rf6+47]      
636c: df,47               je    63b5             if (0 != [93ef])  {
636e: 45,ca,02,fa,32      ad3w  R32,Rfa,2ca      R32 = 9a72;                       # Table 9A72 - Canister Purge Duty Cycle vs. AM, X -input = AM, Y -output = Purge Duty Cycle.
6373: a0,a2,34            ldw   R34,Ra2          R34 = AM;
6376: 09,01,34            shlw  R34,1            R34 *= 2;
6379: d3,03               jnc   637e             if ((uns) R34 >= 0)  {
637b: b1,ff,35            ldb   R35,ff           R35 = ff; }
637e: b0,35,34            ldb   R34,R35          R34 = R35;
6381: ef,33,d2            call  35b7             UUbyteLu();
6384: 98,38,00            cmpb  R0,R38           
6387: df,2c               je    63b5             if (0 != R38)  {
6389: b0,38,40            ldb   R40,R38          R40 = R38;
638c: 45,b2,02,fa,32      ad3w  R32,Rfa,2b2      R32 = 9a5a;                       # Table 9A5A - Canister Purge Duty Cycle Multiplier, X -input = PRGTMR. Y -output = Duty Cycle Mu
                                                                                   ltiplier.
6391: b3,72,c9,34         ldb   R34,[R72+c9]     R34 = Prgtmr;                     # 149 - timer Canister Purge Timer - cannister purge accumulation time in seconds
6395: ef,1f,d2            call  35b7             UUbyteLu();
6398: 7c,38,40            ml2b  R40,R38          R40 *= R38;
639b: 09,01,40            shlw  R40,1            R40 *= 2;
639e: 45,be,02,fa,32      ad3w  R32,Rfa,2be      R32 = 9a66;                       # Table 9A66 - Canister Purge Duty Cycle Multiplier, X -input = CPRGTMR, Y -output = Duty Cycle M
                                                                                   ultiplier.
63a3: b3,72,ca,34         ldb   R34,[R72+ca]     R34 = Cprgtmr;                    # 14A - timer?
63a7: ef,0d,d2            call  35b7             UUbyteLu();
63aa: 7c,41,38            ml2b  R38,R41          R38 *= R41;
63ad: 08,07,38            shrw  R38,7            R38 /= 80;
63b0: 91,40,ef            orb   Ref,40           Prgflg = 1;
63b3: 20,09               sjmp  63be             goto 63be; } } } }
63b5: 11,38               clrb  R38              R38 = 0;
63b7: 71,bf,ef            an2b  Ref,bf           Prgflg = 0;
63ba: c7,72,ca,00         stb   R0,[R72+ca]      Cprgtmr = 0;                      # zero 14A - timer - Current Purge on time.
63be: c7,72,ac,38         stb   R38,[R72+ac]     Purgdc = R38;
63c2: 98,00,38            cmpb  R38,R0           
63c5: df,03               je    63ca             if (R38 != 0)  {
63c7: 91,40,e9            orb   Re9,40           CanPurgeOK = 1; }

#################################################################
# Tasklist Routine at 2151, routine offset 70 Fall thru?
# Update Canister Purge
################################################################# 


  Upd_canP:
63ca: b1,a3,38            ldb   R38,a3           R38 = a3;
63cd: c7,72,ae,38         stb   R38,[R72+ae]     Purge_period = R38;               # 12E - PURGE PERIOD
63d1: 7f,72,ac,38         ml2b  R38,[R72+ac]     R38 *= Purgdc;                    # 12C - PURGDC - Canister Purge Duty Cycle.
63d5: 09,01,38            shlw  R38,1            R38 *= 2;
63d8: c7,72,ad,39         stb   R39,[R72+ad]     Purg_on_time = R39;               # 12D - PURG ON TIME
63dc: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 16
# Update A/C cutout and idle slowdown flag
#################################################################


  Update_AC:
63dd: b3,f6,5a,42         ldb   R42,[Rf6+5a]     R42 = [9402];
63e1: 98,b0,42            cmpb  R42,Rb0          
63e4: d6,05               jge   63eb             if (R42 < ECT)  {
63e6: 91,40,eb            orb   Reb,40           Acect_flg = 1;
63e9: 20,26               sjmp  6411             goto 6411; }
63eb: 7b,f6,5b,42         sb2b  R42,[Rf6+5b]     R42 -= [9403];
63ef: 98,b0,42            cmpb  R42,Rb0          
63f2: da,03               jle   63f7             if ((uns) R42 < ECT)  {
63f4: 71,bf,eb            an2b  Reb,bf           Acect_flg = 0; }
63f7: a3,f6,5c,42         ldw   R42,[Rf6+5c]     R42 = [9404];
63fb: 88,ae,42            cmpw  R42,Rae          
63fe: d1,05               jleu  6405             if ((uns) R42 > Rpmx4 )  {
6400: 91,20,eb            orb   Reb,20           Acn_flg = 1;
6403: 20,0c               sjmp  6411             goto 6411; }
6405: 67,f6,5e,42         ad2w  R42,[Rf6+5e]     R42 += [9406];
6409: 88,ae,42            cmpw  R42,Rae          
640c: db,03               jc    6411             if (R42 > Rpmx4)  {
640e: 71,df,eb            an2b  Reb,df           Acn_flg = 0; }
6411: 37,ee,3a            jnb   B7,Ree,644e      if (A3C = 0) goto 644e;           # jmp if A/C is off
6414: 3e,eb,03            jb    B6,Reb,641a      if (Acect_flg = 1) goto 641a;
6417: 35,eb,02            jnb   B5,Reb,641c      if (Acn_flg = 0) goto 641c;
641a: 20,25               sjmp  6441             goto 6441;
641c: 9b,f6,53,c8         cmpb  Rc8,[Rf6+53]     
6420: db,02               jc    6424             if ((uns) Atmr1 >= [93fb]) goto 6424;
6422: 20,1d               sjmp  6441             goto 6441;
6424: b3,f6,54,42         ldb   R42,[Rf6+54]     R42 = [93fc];
6428: 31,ea,08            jnb   B1,Rea,6433      if (Biflg = 1)  {                 # BIFLG = If equal to 1, Brake is on.
642b: 9b,74,95,42         cmpb  R42,[R74+95]                                       # 213 - A/C Clutch Brake Timer (sec)
642f: d1,02               jleu  6433             if ((uns) R42 <= Acbtmr) goto 6433;
6431: 20,0e               sjmp  6441             goto 6441; }
6433: b3,f6,55,42         ldb   R42,[Rf6+55]     R42 = [93fd];
6437: 9b,74,97,42         cmpb  R42,[R74+97]                                       # 215 - A/C Clutch WOT Cutout Timer (sec)
643b: d1,02               jleu  643f             if ((uns) R42 <= Wcotmr) goto 643f;
643d: 20,02               sjmp  6441             goto 6441;
643f: 20,18               sjmp  6459             goto 6459;
6441: a3,f6,64,42         ldw   R42,[Rf6+64]     R42 = [940c];
6445: 33,ea,06            jnb   B3,Rea,644e      if (Accflg = 0) goto 644e;
6448: 8b,74,98,42         cmpw  R42,[R74+98]                                       # 216 - A/C CLUTCH TRANSITION TIMER
644c: d9,0b               jgtu  6459             if ((uns) R42 <= Acctmr)  {
644e: 91,40,46            orb   R46,40           WOT_AC = 1;                       # LSO output line 6 setting bit turns ON relay which turns AC OFF
6451: 71,f7,ea            an2b  Rea,f7           Accflg = 0;
6454: 71,fb,ea            an2b  Rea,fb           Aciflg = 0;
6457: 20,32               sjmp  648b             return; }
6459: a3,f6,0a,42         ldw   R42,[Rf6+a]      R42 = SSFCTR;
645d: 8b,76,2e,42         cmpw  R42,[R76+2e]                                       # 3A8 timer?
6461: db,28               jc    648b             if ((uns) R42 >= A3CTMR) return;
6463: a3,f6,56,42         ldw   R42,[Rf6+56]     R42 = [93fe];
6467: 8b,74,98,42         cmpw  R42,[R74+98]                                       # 216 - A/C CLUTCH TRANSITION TIMER
646b: d9,1e               jgtu  648b             if ((uns) R42 > Acctmr ) return;
646d: 37,d0,0a            jnb   B7,Rd0,647a      if (Cl_thrtl = 0) goto 647a;
6470: a3,f6,58,42         ldw   R42,[Rf6+58]     R42 = [9400];
6474: 8b,74,9a,42         cmpw  R42,[R74+9a]                                       # 218 - A/C CLUTCH TURN -ON DELAY TIMER (msec resolution)
6478: d9,0b               jgtu  6485             if ((uns) R42 <= Acitmr)  {
647a: 71,bf,46            an2b  R46,bf           WOT_AC = 0;                       # LSO output line 6 clearing bit turns OFF relay which turns AC ON
647d: 91,08,ea            orb   Rea,8            Accflg = 1;
6480: 71,fb,ea            an2b  Rea,fb           Aciflg = 0;
6483: 20,06               sjmp  648b             return; }
6485: 3b,ea,03            jb    B3,Rea,648b      if (Accflg = 1) return;           # jmp if ACCFLG
6488: 91,04,ea            orb   Rea,4            Aciflg = 1;                       # set ACIFLG - A/C engagement impending flag:1=A/C about to engage - adjust airflow and fuel imme
                                                                                   diately
648b: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 38
# update ect cooling fans
#################################################################


  Update_fans:
648c: 9b,f6,74,00         cmpb  R0,[Rf6+74]                                        # 941C fan control enable
6490: d7,01               jne   6493             if (0 = Fan_enble)  {
6492: f0                  ret                    return; }

6493: 37,a1,02            jnb   B7,Ra1,6498      if (Cranking = 0) goto 6498;
6496: 20,c1               sjmp  6559             goto 6559;
6498: 71,df,e9            an2b  Re9,df           Hsfflg = 0;
649b: 9b,f6,77,b0         cmpb  Rb0,[Rf6+77]                                       #  ROM 941F fan high speed temp 2(242DegF)
649f: d6,24               jge   64c5             if (ECT >= Ect_hs2) goto 64c5;
64a1: 9b,f6,76,b0         cmpb  Rb0,[Rf6+76]                                       #  ROM 941E fan high speed temp 1(234DegF)
64a5: de,21               jlt   64c8             if (ECT >= Ect_hs1)  {
64a7: b3,74,21,42         ldb   R42,[R74+21]     R42 = N_byte;
64ab: 9b,f6,78,42         cmpb  R42,[Rf6+78]     
64af: d3,17               jnc   64c8             if ((uns) R42 >= [9420])  {
64b1: a3,74,de,42         ldw   R42,[R74+de]     R42 = Load;                       # engine load (VE? )
64b5: 8b,f6,7a,42         cmpw  R42,[Rf6+7a]     
64b9: d3,0d               jnc   64c8             if ((uns) R42 >= [9422])  {
64bb: b3,74,3f,42         ldb   R42,[R74+3f]     R42 = Mph_FiltH;                  # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
64bf: 9b,f6,79,42         cmpb  R42,[Rf6+79]     
64c3: d9,03               jgtu  64c8             if ((uns) R42 <= [9421])  {
64c5: 91,20,e9            orb   Re9,20           Hsfflg = 1; } } } }
64c8: 35,e9,0d            jnb   B5,Re9,64d8      if (Hsfflg = 1)  {
64cb: b3,f6,71,40         ldb   R40,[Rf6+71]     R40 = [9419];
64cf: 9b,72,ce,40         cmpb  R40,[R72+ce]                                       # timer?
64d3: d9,03               jgtu  64d8             if ((uns) R40 <= Edftmr)  {
64d5: 91,08,e9            orb   Re9,8            Hispd = 1; } }
64d8: b3,f6,76,42         ldb   R42,[Rf6+76]     R42 = Ect_hs1;                    # 941E fan high speed temp 1(234DegF)
64dc: 7b,f6,6d,42         sb2b  R42,[Rf6+6d]     R42 -= [9415];
64e0: 98,b0,42            cmpb  R42,Rb0          
64e3: da,03               jle   64e8             if ((uns) R42 < ECT)  {
64e5: 71,f7,e9            an2b  Re9,f7           Hispd = 0; }
64e8: 9b,f6,6c,b0         cmpb  Rb0,[Rf6+6c]                                       #  ROM 9414 fan low speed temp (220DegF)
64ec: da,03               jle   64f1             if ((uns) ECT < Fan_temp)  {
64ee: 91,04,e9            orb   Re9,4            Lospd_ect = 1; }
64f1: b3,f6,6c,42         ldb   R42,[Rf6+6c]     R42 = Fan_temp;                   # 9414 fan low speed temp (220DegF)
64f5: 7b,f6,6e,42         sb2b  R42,[Rf6+6e]     R42 -= [9416];
64f9: 98,b0,42            cmpb  R42,Rb0          
64fc: da,03               jle   6501             if ((uns) R42 < ECT)  {
64fe: 71,fb,e9            an2b  Re9,fb           Lospd_ect = 0; }
6501: 33,e9,09            jnb   B3,Re9,650d      if (Hispd = 0) goto 650d;
6504: b3,f6,75,40         ldb   R40,[Rf6+75]     R40 = Hedfhp;                     # 941D fan high speed enable
6508: 99,01,40            cmpb  R40,1            
650b: df,44               je    6551             if (R40 = 1) goto 6551;
650d: b3,f6,6f,42         ldb   R42,[Rf6+6f]     R42 = [9417];
6511: 7b,f6,70,42         sb2b  R42,[Rf6+70]     R42 -= [9418];
6515: 9b,74,3f,42         cmpb  R42,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
6519: d1,05               jleu  6520             if ((uns) R42 > Mph_FiltH )  {
651b: 33,ea,02            jnb   B3,Rea,6520      if (Accflg = 0) goto 6520;
651e: 20,06               sjmp  6526             goto 6526; }
6520: 3a,e9,03            jb    B2,Re9,6526      if (Lospd_ect = 1) goto 6526;
6523: 37,c5,04            jnb   B7,Rc5,652a      if (Cfmflag = 1)  {
6526: 71,9f,47            an2b  R47,9f           Fan = 0;
                                                 Hi_fan = 0;                       # R47 bits 5 and 6 OFF (Fans? )
6529: f0                  ret                    return; }

652a: 3b,ea,0c            jb    B3,Rea,6539      if (Accflg = 0)  {
652d: a3,f6,72,40         ldw   R40,[Rf6+72]     R40 = [941a];
6531: 8b,74,98,40         cmpw  R40,[R74+98]                                       # 216 - timer?
6535: d9,02               jgtu  6539             if ((uns) R40 > Acctmr ) goto 6539;
6537: 20,14               sjmp  654d             goto 654d; }
6539: b3,f6,55,40         ldb   R40,[Rf6+55]     R40 = [93fd];
653d: 9b,74,97,40         cmpb  R40,[R74+97]                                       # 215 timer?
6541: d9,0a               jgtu  654d             if ((uns) R40 > Wcotmr ) goto 654d;
6543: b3,f6,6f,40         ldb   R40,[Rf6+6f]     R40 = [9417];
6547: 9b,74,3f,40         cmpb  R40,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
654b: db,02               jc    654f             if ((uns) R40 >= Mph_FiltH) goto 654f;
654d: 20,10               sjmp  655f             goto 655f;
654f: 20,07               sjmp  6558             goto 6558;
6551: 71,df,47            an2b  R47,df           Fan = 0;                          # R47 bit 5 OFF (Fan? )
6554: 91,40,47            orb   R47,40           Hi_fan = 1;                       # R47 bit 6 ON (Fan? )
6557: f0                  ret                    return;

6558: f0                  ret                    return;

6559: 71,f7,e9            an2b  Re9,f7           Hispd = 0;
655c: 71,fb,e9            an2b  Re9,fb           Lospd_ect = 0;
655f: 91,20,47            orb   R47,20           Fan = 1;                          # R47 bit 5 ON (Fan? )
6562: 71,bf,47            an2b  R47,bf           Hi_fan = 0;                       # R47 bit 6 OFF (Fan? )
6565: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 40
#################################################################


  Upd_Thermactor1:
6566: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = Thrmhp;
656a: 99,02,30            cmpb  R30,2            
656d: d7,31               jne   65a0             if (R30 = 2)  {                   # thermactor present must be 2 
656f: 3c,c5,2b            jb    B4,Rc5,659d      if (Tfmflag = 0)  {
6572: 3f,a1,28            jb    B7,Ra1,659d      if (Cranking = 0)  {
6575: 3a,a1,25            jb    B2,Ra1,659d      if (Undsp = 0)  {
6578: a3,f2,0a,30         ldw   R30,[Rf2+a]      R30 = Thbpsc;
657c: 67,72,a6,30         ad2w  R30,[R72+a6]     R30 += TPS_Min;                   # 126 - RATCH=Closed TP
6580: d3,04               jnc   6586             if ((uns) R30 >= 0)  {
6582: a1,c0,ff,30         ldw   R30,ffc0         R30 = ffc0; }
6586: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
6589: d1,05               jleu  6590             if ((uns) TP > R30 )  {
658b: 91,08,47            orb   R47,8            Sbs1 = 1;                         # R47 bit 3 ON (Air management1)
658e: 20,10               sjmp  65a0             return; }
6590: 6b,f2,0c,30         sb2w  R30,[Rf2+c]      R30 -= Thbpsh;
6594: db,02               jc    6598             if (R30 > 0)  {
6596: 01,30               clrw  R30              R30 = 0; }
6598: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
659b: db,03               jc    65a0             if ((uns) TP >= R30) return; } } }
659d: 71,f7,47            an2b  R47,f7           Sbs1 = 0; }                       # R47 bit 3 OFF (Air management1)
65a0: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 4A
# Update Air Management
#################################################################


  Upd_Air_mgmnt:
65a1: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = Thrmhp;                     # 9E65 thermactor present switch = 1.0
65a5: 99,03,30            cmpb  R30,3            
65a8: d7,29               jne   65d3             if (R30 = 3)  {
65aa: a3,f2,0e,30         ldw   R30,[Rf2+e]      R30 = Niac;                       # 8E68 - NIAC
65ae: 88,30,ae            cmpw  Rae,R30          
65b1: d1,05               jleu  65b8             if ((uns) Rpmx4 > R30 )  {
65b3: 91,10,29            orb   R29,10           Iacflg = 1;                       # set IACFLG
65b6: 20,10               sjmp  65c8             goto 65c8; }
65b8: 6b,f2,10,30         sb2w  R30,[Rf2+10]     R30 -= Niach;                     # 8E6A - NIACH
65bc: db,02               jc    65c0             if (R30 > 0)  {
65be: 01,30               clrw  R30              R30 = 0; }
65c0: 88,30,ae            cmpw  Rae,R30          
65c3: db,03               jc    65c8             if (Rpmx4 > R30)  {
65c5: 71,ef,29            an2b  R29,ef           Iacflg = 0; }                     # clr IACFLG
65c8: 3c,29,05            jb    B4,R29,65d0      if (Iacflg = 0)  {
65cb: 71,ef,47            an2b  R47,ef           Iac = 0;                          # R47 bit 4 OFF (Air management2)
65ce: 20,03               sjmp  65d3             return; }
65d0: 91,10,47            orb   R47,10           Iac = 1; }                        # R47 bit 4 ON (Air management2)
65d3: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 18
#################################################################


  Set_Timers:
65d4: 3d,2b,04            jb    B5,R2b,65db      if (Stiflg = 0)  {
65d7: c7,72,48,00         stb   R0,[R72+48]      Tsstil = 0; }                     # STI input line low timer
65db: 37,a1,1e            jnb   B7,Ra1,65fc      if (Cranking = 1)  {
65de: 11,c8               clrb  Rc8              Atmr1 = 0;                        # Cranking, clear timers
65e0: 71,bf,24            an2b  R24,bf           Atmr2_On = 0;
65e3: 11,c9               clrb  Rc9              Atmr2 = 0;
65e5: 71,df,24            an2b  R24,df           Nactmr_On = 0;
65e8: 11,cd               clrb  Rcd              Nactmr = 0;
65ea: 71,fb,24            an2b  R24,fb           Awotmr_On = 0;
65ed: 11,cb               clrb  Rcb              Awotmr = 0;
65ef: 71,df,a1            an2b  Ra1,df           Purging = 0;
65f2: c7,72,c9,00         stb   R0,[R72+c9]      Prgtmr = 0;
65f6: c7,72,ce,00         stb   R0,[R72+ce]      Edftmr = 0;
65fa: 22,c4               sjmp  68c0             goto 68c0; }
65fc: 37,d0,0a            jnb   B7,Rd0,6609      if (Cl_thrtl = 1)  {              # Not cranking, but closed Throttle
65ff: 91,40,a1            orb   Ra1,40           Cttmr_On = 1;
6602: 71,df,24            an2b  R24,df           Nactmr_On = 0;
6605: 11,cd               clrb  Rcd              Nactmr = 0;
6607: 20,0a               sjmp  6613             goto 6613; }
6609: 91,20,24            orb   R24,20           Nactmr_On = 1;                    # Not crank, not closed Throttle
660c: 71,bf,a1            an2b  Ra1,bf           Cttmr_On = 0;
660f: c7,72,aa,00         stb   R0,[R72+aa]      Cttmr = 0;
6613: 30,24,0d            jnb   B0,R24,6623      if (Wot = 1)  {                   # At Wide Open Throttle ?
6616: 91,04,24            orb   R24,4            Awotmr_On = 1;
6619: 99,fe,cb            cmpb  Rcb,fe           
661c: d3,03               jnc   6621             if ((uns) Awotmr >= fe)  {
661e: 71,fb,24            an2b  R24,fb           Awotmr_On = 0; }
6621: 20,05               sjmp  6628             goto 6628; }
6623: 71,fb,24            an2b  R24,fb           Awotmr_On = 0;                    # part throttle ?
6626: 11,cb               clrb  Rcb              Awotmr = 0;
6628: 9b,fe,06,b0         cmpb  Rb0,[Rfe+6]      
662c: da,08               jle   6636             if ((uns) ECT < [9e60])  {
662e: 3e,24,05            jb    B6,R24,6636      if (Atmr2_On = 0)  {
6631: 91,40,24            orb   R24,40           Atmr2_On = 1;
6634: 11,c9               clrb  Rc9              Atmr2 = 0; } }                    # RC9 is some kind of timer
6636: 35,47,04            jnb   B5,R47,663d      if (Fan = 1)  {                   # if R47 bit 5 OFF (Fan? )
6639: c7,72,ce,00         stb   R0,[R72+ce]      Edftmr = 0; }                     # zero 14E - timer
663d: a3,fc,38,38         ldw   R38,[Rfc+38]     R38 = [9ab6];
6641: 88,38,ae            cmpw  Rae,R38          
6644: db,05               jc    664b             if (Rpmx4 > R38)  {
6646: 91,02,a1            orb   Ra1,2            Idleq = 1;
6649: 20,0c               sjmp  6657             goto 6657; }
664b: 67,fc,3a,38         ad2w  R38,[Rfc+3a]     R38 += [9ab8];
664f: 88,38,ae            cmpw  Rae,R38          
6652: d1,03               jleu  6657             if ((uns) Rpmx4 > R38 )  {
6654: 71,fd,a1            an2b  Ra1,fd           Idleq = 0; }
6657: 71,f7,ef            an2b  Ref,f7           Idlflg = 0;
665a: 36,26,09            jnb   B6,R26,6666      if (Dndsup = 1)  {
665d: 37,d0,06            jnb   B7,Rd0,6666      if (Cl_thrtl = 1)  {
6660: 31,a1,03            jnb   B1,Ra1,6666      if (Idleq = 1)  {
6663: 91,08,ef            orb   Ref,8            Idlflg = 1; } } }
6666: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = Ctntmr;
666a: 45,2a,01,f8,32      ad3w  R32,Rf8,12a      R32 = 955a;                       # FILTER 955A
666f: ef,45,cf            call  35b7             UUbyteLu();
6672: 09,05,38            shlw  R38,5            R38 *= 20;
6675: 67,f6,32,38         ad2w  R38,[Rf6+32]     R38 += [93da];
6679: 88,38,ae            cmpw  Rae,R38          
667c: db,05               jc    6683             if (Rpmx4 > R38)  {
667e: 91,02,24            orb   R24,2            Ctnq = 1;
6681: 20,0c               sjmp  668f             goto 668f; }
6683: 67,f6,34,38         ad2w  R38,[Rf6+34]     R38 += [93dc];
6687: 88,38,ae            cmpw  Rae,R38          
668a: d1,03               jleu  668f             if ((uns) Rpmx4 > R38 )  {
668c: 71,fd,24            an2b  R24,fd           Ctnq = 0; }
668f: 71,fb,e8            an2b  Re8,fb           Ctnflg = 0;
6692: 71,fd,e8            an2b  Re8,fd           Ctntmr_up = 0;
6695: 91,01,e8            orb   Re8,1            Ctntmr_dwn = 1;
6698: 9b,fe,04,b0         cmpb  Rb0,[Rfe+4]      
669c: da,2c               jle   66ca             if ((uns) ECT < CThigh)  {
669e: 37,d0,29            jnb   B7,Rd0,66ca      if (Cl_thrtl = 1)  {
66a1: 3f,e7,26            jb    B7,Re7,66ca      if (Ndsflg = 0)  {
66a4: 31,24,23            jnb   B1,R24,66ca      if (Ctnq = 1)  {
66a7: 91,04,e8            orb   Re8,4            Ctnflg = 1;
66aa: 91,02,e8            orb   Re8,2            Ctntmr_up = 1;
66ad: 71,fe,e8            an2b  Re8,fe           Ctntmr_dwn = 0;
66b0: b3,f4,72,38         ldb   R38,[Rf4+72]     R38 = Niold;
66b4: 77,f4,73,38         ad2b  R38,[Rf4+73]     R38 += Drv_rpm;
66b8: d3,03               jnc   66bd             if ((uns) R38 >= 0)  {
66ba: b1,ff,38            ldb   R38,ff           R38 = ff; }
66bd: 9b,72,c4,38         cmpb  R38,[R72+c4]     
66c1: d9,07               jgtu  66ca             if ((uns) R38 <= Ctntmr)  {
66c3: c7,72,c4,38         stb   R38,[R72+c4]     Ctntmr = R38;
66c7: 71,fd,e8            an2b  Re8,fd           Ctntmr_up = 0; } } } } }
66ca: a3,74,e2,3a         ldw   R3a,[R74+e2]     R3a = Perload;                    # 260 Volumetric Efficiency
66ce: a3,f6,22,38         ldw   R38,[Rf6+22]     R38 = [93ca];
66d2: 47,f6,24,38,3c      ad3w  R3c,R38,[Rf6+24] R3c = R38 + [93cc];
66d7: d3,03               jnc   66dc             if ((uns) R3c >= 0)  {
66d9: bd,ff,3c            ldsbw R3c,ff           R3c = (int)ff; }
66dc: 88,3a,3c            cmpw  R3c,R3a          
66df: d3,0e               jnc   66ef             if ((uns) R3c < R3a) goto 66ef;
66e1: 88,3a,38            cmpw  R38,R3a          
66e4: d1,0c               jleu  66f2             if ((uns) R38 > R3a )  {
66e6: c7,72,b7,00         stb   R0,[R72+b7]      Hmtmr = 0;                        # zero 137 timer?
66ea: 71,fb,eb            an2b  Reb,fb           Hmtmr_On = 0;
66ed: 20,03               sjmp  66f2             goto 66f2;
66ef: 91,04,eb            orb   Reb,4            Hmtmr_On = 1; }
66f2: 71,7f,ec            an2b  Rec,7f           Swtflg = 0;
66f5: 45,02,00,f4,30      ad3w  R30,Rf4,2        R30 = Mfatm3;                     # 8FD8
66fa: ef,52,d0            call  374f             Check_Timers();
66fd: db,56               jc    6755             if ((uns) R30 >= 0) goto 6755;
66ff: 38,d0,53            jb    B0,Rd0,6755      if (B0_Apt = 1) goto 6755;        # WOT flag
6702: 3a,ee,50            jb    B2,Ree,6755      if (Olflg = 1) goto 6755;
6705: 8b,f4,0e,ae         cmpw  Rae,[Rf4+e]      
6709: d1,4a               jleu  6755             if ((uns) Rpmx4 <= Mfanlo) goto 6755;
670b: 8b,f4,10,ae         cmpw  Rae,[Rf4+10]     
670f: db,44               jc    6755             if ((uns) Rpmx4 >= Mfanhi) goto 6755;
6711: 4b,74,fe,ae,38      sb3w  R38,Rae,[R74+fe] R38 = Rpmx4 - RPM_Filt2;          # 027c - filtered(2) RPM
6716: db,02               jc    671a             if (R38 > 0)  {
6718: 03,38               negw  R38              R38 = -R38; }
671a: 8b,f4,12,38         cmpw  R38,[Rf4+12]     
671e: db,35               jc    6755             if ((uns) R38 >= Mfasn) goto 6755;
6720: 8b,f4,14,3a         cmpw  R3a,[Rf4+14]     
6724: db,2f               jc    6755             if ((uns) R3a >= Mfalh) goto 6755;
6726: 37,e7,2c            jnb   B7,Re7,6755      if (Ndsflg = 0) goto 6755;
6729: b3,f4,20,38         ldb   R38,[Rf4+20]     R38 = Mpmnbp;
672d: 77,f4,21,38         ad2b  R38,[Rf4+21]     R38 += Mpnbph;
6731: d3,03               jnc   6736             if ((uns) R38 >= 0)  {
6733: b1,ff,38            ldb   R38,ff           R38 = ff; }
6736: 9b,74,80,38         cmpb  R38,[R74+80]                                       # BP - barometric pressure
673a: d9,19               jgtu  6755             if ((uns) R38 > Bp ) goto 6755;
673c: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
6740: df,16               je    6758             if (0 = Vstype) goto 6758;
6742: b3,f2,42,38         ldb   R38,[Rf2+42]     R38 = Vsmpg;
6746: 77,f2,43,38         ad2b  R38,[Rf2+43]     R38 += Vsmpgh;
674a: d3,03               jnc   674f             if ((uns) R38 >= 0)  {
674c: b1,ff,38            ldb   R38,ff           R38 = ff; }
674f: 9b,74,3f,38         cmpb  R38,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
6753: d1,03               jleu  6758             if ((uns) R38 <= Mph_FiltH) goto 6758;
6755: 30,ec,03            jnb   B0,Rec,675b      if (Mfa_on = 1)  {
6758: 91,80,ec            orb   Rec,80           Swtflg = 1; }
675b: b3,72,c8,38         ldb   R38,[R72+c8]     R38 = Mfactr;
675f: 30,ee,02            jnb   B0,Ree,6764      if (Swtfl = 1)  {
6762: 17,38               incb  R38              R38++; }
6764: 3f,ec,02            jb    B7,Rec,6769      if (Swtflg = 0)  {
6767: 11,38               clrb  R38              R38 = 0; }
6769: c7,72,c8,38         stb   R38,[R72+c8]     Mfactr = R38;
676d: 9b,f4,16,38         cmpb  R38,[Rf4+16]     
6771: d3,03               jnc   6776             if ((uns) R38 >= Swtcnt)  {
6773: 91,01,ec            orb   Rec,1            Mfa_on = 1; }
6776: 38,24,55            jb    B0,R24,67ce      if (Wot = 1) goto 67ce;
6779: a3,f4,10,38         ldw   R38,[Rf4+10]     R38 = Mfanhi;
677d: 67,f4,18,38         ad2w  R38,[Rf4+18]     R38 += Mfanhh;
6781: 88,38,ae            cmpw  Rae,R38          
6784: d9,48               jgtu  67ce             if ((uns) Rpmx4 > R38 ) goto 67ce;
6786: a3,f4,0e,38         ldw   R38,[Rf4+e]      R38 = Mfanlo;
678a: 6b,f4,1a,38         sb2w  R38,[Rf4+1a]     R38 -= Mfanlh;
678e: 88,38,ae            cmpw  Rae,R38          
6791: d3,3b               jnc   67ce             if ((uns) Rpmx4 < R38) goto 67ce;
6793: 8b,f4,1c,3a         cmpw  R3a,[Rf4+1c]     
6797: d3,35               jnc   67ce             if ((uns) R3a < Mfall) goto 67ce;
6799: a3,f4,14,38         ldw   R38,[Rf4+14]     R38 = Mfalh;
679d: 67,f4,1e,38         ad2w  R38,[Rf4+1e]     R38 += Mfalhh;
67a1: d3,03               jnc   67a6             if ((uns) R38 >= 0)  {
67a3: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
67a6: 88,38,3a            cmpw  R3a,R38          
67a9: d9,23               jgtu  67ce             if ((uns) R3a > R38 ) goto 67ce;
67ab: 37,e7,20            jnb   B7,Re7,67ce      if (Ndsflg = 0) goto 67ce;
67ae: 51,a8,c5,34         an3b  R34,Rc5,a8       R34 = Fmem_flags & a8;
67b2: d7,1a               jne   67ce             if (R34 != 0) goto 67ce;
67b4: b3,74,80,40         ldb   R40,[R74+80]     R40 = Bp;                         # BP - barometric pressure
67b8: 9b,f4,20,40         cmpb  R40,[Rf4+20]     
67bc: d3,10               jnc   67ce             if ((uns) R40 < Mpmnbp) goto 67ce;
67be: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
67c2: df,10               je    67d4             if (0 != Vstype)  {
67c4: b3,f2,42,38         ldb   R38,[Rf2+42]     R38 = Vsmpg;
67c8: 9b,74,3f,38         cmpb  R38,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
67cc: d1,06               jleu  67d4             if ((uns) R38 > Mph_FiltH )  {
67ce: c4,ce,00            stb   R0,Rce           Mfatmr = 0;                       # zero RCE timer?
67d1: 71,fe,ec            an2b  Rec,fe           Mfa_on = 0; } }
67d4: 71,fb,26            an2b  R26,fb           Nflg = 0;
67d7: 37,d0,06            jnb   B7,Rd0,67e0      if (Cl_thrtl = 1)  {
67da: 3f,e7,03            jb    B7,Re7,67e0      if (Ndsflg = 0)  {
67dd: 91,04,26            orb   R26,4            Nflg = 1; } }
67e0: 11,38               clrb  R38              R38 = 0;
67e2: 30,ec,12            jnb   B0,Rec,67f7      if (Mfa_on = 1)  {
67e5: b3,f4,22,38         ldb   R38,[Rf4+22]     R38 = Mfarmp;
67e9: 77,74,f4,38         ad2b  R38,[R74+f4]     R38 += Mfamul;
67ed: db,05               jc    67f4             if ((uns) R38 >= 0) goto 67f4;
67ef: 99,80,38            cmpb  R38,80           
67f2: d1,03               jleu  67f7             if ((uns) R38 > 80 )  {
67f4: b1,80,38            ldb   R38,80           R38 = 80; } }
67f7: c7,74,f4,38         stb   R38,[R74+f4]     Mfamul = R38;
67fb: 30,29,04            jnb   B0,R29,6802      if (Hltmr_Off = 1)  {
67fe: c7,72,cc,00         stb   R0,[R72+cc]      Hltmr = 0; }                      # High load timer - 1/8 seconds under high load so far
6802: 3a,ee,08            jb    B2,Ree,680d      if (Olflg = 0)  {
6805: 3b,27,05            jb    B3,R27,680d      if (Swtfl1 = 0)  {
6808: 91,80,27            orb   R27,80           Lestmr1_On = 1;
680b: 20,07               sjmp  6814             goto 6814; } }
680d: 71,7f,27            an2b  R27,7f           Lestmr1_On = 0;
6810: c7,74,e8,00         stb   R0,[R74+e8]      Lestmr1 = 0;                      # zero timer?
6814: 3a,ee,08            jb    B2,Ree,681f      if (Olflg = 0)  {
6817: 38,27,05            jb    B0,R27,681f      if (Swtfl2 = 0)  {
681a: 91,40,27            orb   R27,40           Lestmr2_On = 1;
681d: 20,07               sjmp  6826             goto 6826; } }
681f: 71,bf,27            an2b  R27,bf           Lestmr2_On = 0;
6822: c7,74,e9,00         stb   R0,[R74+e9]      Lestmr2 = 0;                      # zero timer?
6826: b3,74,e8,14         ldb   R14,[R74+e8]     R14 = Lestmr1;                    # timer?
682a: 9b,f6,36,14         cmpb  R14,[Rf6+36]     
682e: d3,03               jnc   6833             if ((uns) R14 >= [93de])  {
6830: 91,02,ed            orb   Red,2            Legofg1 = 1; }
6833: b3,74,e9,14         ldb   R14,[R74+e9]     R14 = Lestmr2;                    # timer?
6837: 9b,f6,36,14         cmpb  R14,[Rf6+36]     

  Sub35:
683b: d3,03               jnc   6840             if ((uns) R14 >= [93de])  {
683d: 91,01,ed            orb   Red,1            Legofg2 = 1; }
6840: b3,f6,38,14         ldb   R14,[Rf6+38]     R14 = [93e0];
6844: 98,00,14            cmpb  R14,R0           
6847: df,0c               je    6855             if (R14 != 0)  {
6849: 33,27,03            jnb   B3,R27,684f      if (Swtfl1 = 1)  {
684c: 71,fd,ed            an2b  Red,fd           Legofg1 = 0; }
684f: 30,27,03            jnb   B0,R27,6855      if (Swtfl2 = 1)  {
6852: 71,fe,ed            an2b  Red,fe           Legofg2 = 0; } }
6855: 33,ea,05            jnb   B3,Rea,685d      if (Accflg = 1)  {
6858: 38,ea,02            jb    B0,Rea,685d      if (Paccflg = 1) goto 685d;
685b: 20,06               sjmp  6863             goto 6863; }
685d: 3b,ea,0a            jb    B3,Rea,686a      if (Accflg = 0)  {
6860: 30,ea,07            jnb   B0,Rea,686a      if (Paccflg = 1)  {
6863: c3,74,98,00         stw   R0,[R74+98]      Acctmr = 0;                       # zero 216 - timer?
6867: 95,01,ea            xorb  Rea,1            Paccflg ^= 1; } }
686a: a3,72,a6,36         ldw   R36,[R72+a6]     R36 = TPS_Min;                    # 126 - RATCH=Closed TP
686e: 47,f6,60,36,42      ad3w  R42,R36,[Rf6+60] R42 = R36 + [9408];
6873: 88,aa,42            cmpw  R42,Raa                                            # RAA is Throttle position
6876: db,03               jc    687b             if (R42 > TP)  {
6878: 91,80,eb            orb   Reb,80           Acwflg = 1; }
687b: 6b,f6,62,42         sb2w  R42,[Rf6+62]     R42 -= [940a];
687f: 88,aa,42            cmpw  R42,Raa                                            # RAA is Throttle position
6882: d1,03               jleu  6887             if ((uns) R42 > TP )  {
6884: 71,7f,eb            an2b  Reb,7f           Acwflg = 0; }
6887: 3f,eb,06            jb    B7,Reb,6890      if (Acwflg = 0)  {
688a: c7,74,96,00         stb   R0,[R74+96]      Acwtmr = 0;                       # zero 214 - timer?
688e: 20,0f               sjmp  689f             goto 689f; }
6890: b3,74,96,42         ldb   R42,[R74+96]     R42 = Acwtmr;                     # 214 - timer?
6894: 99,ff,42            cmpb  R42,ff           
6897: d7,06               jne   689f             if (R42 = ff)  {
6899: 15,42               decb  R42              R42--;
689b: c7,74,96,42         stb   R42,[R74+96]     Acwtmr = R42; }                   # set 214 - timer?
689f: 48,36,aa,34         sb3w  R34,Raa,R36      R34 = TP - R36;                   # RAA is Throttle position
68a3: db,02               jc    68a7             if (R34 > 0)  {
68a5: 01,34               clrw  R34              R34 = 0; }
68a7: 45,56,01,f0,32      ad3w  R32,Rf0,156      R32 = Fn087;                      # Table 9056
68ac: ef,5d,cd            call  360c             UUWordLu();
68af: 9b,74,96,38         cmpb  R38,[R74+96]                                       # 214 - timer?
68b3: d1,04               jleu  68b9             if ((uns) R38 > Acwtmr )  {
68b5: c7,74,97,00         stb   R0,[R74+97]      Wcotmr = 0; }                     # zero 215 timer?
68b9: 30,24,04            jnb   B0,R24,68c0      if (Wot = 1)  {
68bc: c7,74,a2,00         stb   R0,[R74+a2]      Nwotmr = 0; }                     # zero 220 timer?
68c0: a3,f6,1c,32         ldw   R32,[Rf6+1c]     R32 = [93c4];
68c4: 67,f6,1a,32         ad2w  R32,[Rf6+1a]     R32 += [93c2];
68c8: 88,32,ae            cmpw  Rae,R32          
68cb: d1,05               jleu  68d2             if ((uns) Rpmx4 > R32 )  {
68cd: 91,10,eb            orb   Reb,10           Ctupr_flg = 1;
68d0: 20,09               sjmp  68db             goto 68db; }
68d2: 8b,f6,1c,ae         cmpw  Rae,[Rf6+1c]     
68d6: db,03               jc    68db             if (Rpmx4 > [93c4])  {
68d8: 71,ef,eb            an2b  Reb,ef           Ctupr_flg = 0; }
68db: 37,d0,08            jnb   B7,Rd0,68e6      if (Cl_thrtl = 1)  {
68de: 34,eb,05            jnb   B4,Reb,68e6      if (Ctupr_flg = 1)  {
68e1: 91,08,eb            orb   Reb,8            Ctaflg = 1;
68e4: 20,07               sjmp  68ed             goto 68ed; } }
68e6: c7,72,b8,00         stb   R0,[R72+b8]      Ctatmr = 0;                       # zero 138 timer?
68ea: 71,f7,eb            an2b  Reb,f7           Ctaflg = 0;
68ed: 88,00,ae            cmpw  Rae,R0           
68f0: d7,04               jne   68f6             if (Rpmx4 = 0)  {
68f2: c7,72,cf,00         stb   R0,[R72+cf]      Crktmr = 0; }                     # zero 14F timer?
68f6: 3a,ea,04            jb    B2,Rea,68fd      if (Aciflg = 1) return;
68f9: c3,74,9a,00         stw   R0,[R74+9a]      Acitmr = 0; }                     # zero 218 - timer?
68fd: f0                  ret                    return;

#################################################################
# Update Timers
# see timer table below this subroutine.
# routine has 1 mS (1/1204) resolution.
# keeps remainders of IOTIMER so that it stays in sync
#################################################################


  Update_timers:
68fe: a3,72,c0,3c         ldw   R3c,[R72+c0]     R3c = Eighths_ext;                # 1/8s remainder (in mSec)
6902: a1,b1,69,30         ldw   R30,69b1         R30 = Timer_list;
6906: a0,06,36            ldw   R36,R6           R36 = IO_Timer;
6909: 4b,72,c2,36,38      sb3w  R38,R36,[R72+c2] R38 = R36 - Loop_time;            # IOTIMER delta time since last mSec
690e: 01,3a               clrw  R3a              R3a = 0;
6910: 0d,07,38            shldw R38,7            R38 *= 80;
6913: 8d,73,cb,38         divw  R38,cb73         R38 /= cb73;                      # *128/52083 = 1 mSec
6917: 88,00,38            cmpw  R38,R0           
691a: d7,02               jne   691e             if (R38 != 0) goto 691e;
691c: 20,92               sjmp  69b0             return;                           # < 1 mS passed - return
691e: c7,74,5e,38         stb   R38,[R74+5e]     Bg_timer = R38;                   # time since last timer update (mSecs)
6922: 65,40,00,3a         ad2w  R3a,40           R3a += 40;                        # (remainder IO times*128) + 64 (rounding)
6926: 08,07,3a            shrw  R3a,7            R3a /= 80;                        # return to IOTIMES remainder
6929: 48,3a,36,32         sb3w  R32,R36,R3a      R32 = R36 - R3a;                  # effective time of this update (IOTIME-remainder)
692d: b1,20,3e            ldb   R3e,20           R3e = 20;                         # set Lmillisecs, = "new mS"
6930: 74,38,3c            ad2b  R3c,R38          R3c += R38;                       # add new mSs to current mS count
6933: 59,80,3c,3f         sb3b  R3f,R3c,80       R3f = R3c - 80;                   # R3f +ve if new 1/8 sec
6937: d3,0f               jnc   6948             if ((uns) R3f >= 0)  {
6939: b0,3f,3c            ldb   R3c,R3f          R3c = R3f;                        # remainder =- 1/8 sec (in mS)
693c: 91,40,3e            orb   R3e,40           Leighths = 1;                     # = "New 1/8 Sec"
693f: e0,3d,06            djnz  R3d,6948         R3d--;
                                                 if (R3d != 0) goto 6948;          # 1 Sec remainder (in 1/8 secs)
6942: 91,80,3e            orb   R3e,80           Lseconds = 1;                     # set "New second" (when R3d = 0)
6945: b1,08,3d            ldb   R3d,8            R3d = 8; } }                      # reset 1 sec remainder (= 8/8, counts down)
6948: c3,72,c0,3c         stw   R3c,[R72+c0]     Eighths_ext = R3c;                # store 1/8 sec remainder (in mSec)
694c: c3,72,c2,32         stw   R32,[R72+c2]     Loop_time = R32;                  # save IOTIME of last timer update (a true mS)
6950: b2,31,3c            ldb   R3c,[R30++]      R3c = [R30++];                    # OK. Start process
6953: 98,00,3c            cmpb  R3c,R0           
6956: df,58               je    69b0             if (R3c = 0) return;              # All zero - return (exit)
6958: ae,31,32            ldzbw R32,[R30++]      R32 = (uns)[R30++];
695b: b2,31,33            ldb   R33,[R30++]      R33 = [R30++];                    # 16 bit address of timer
695e: 30,3c,12            jnb   B0,R3c,6973      if (Free_run = 0) goto 6973;      # short entry? Go to update
6961: b2,31,3d            ldb   R3d,[R30++]      R3d = [R30++];                    # load mask from timer entry
6964: ae,31,34            ldzbw R34,[R30++]      R34 = (uns)[R30++];               # create 16 bit address for flags
6967: 72,34,3d            an2b  R3d,[R34]        R3d &= [R34];                     # AND flags data with entry mask
696a: 33,3c,04            jnb   B3,R3c,6971      if (Inverse = 0) goto 6971;       # flag on or off required ?
696d: df,04               je    6973             if (R3d = 0) goto 6973;           # Inverse - if flag zero, GO timer
696f: 27,df               sjmp  6950             goto 6950;                        # (flags set) STOP, loop to next entry
6971: df,dd               je    6950             if (R3d = 0) goto 6950;           # (flags clr) STOP, loop to next entry
6973: 50,3c,3e,00         an3b  R0,R3e,R3c       R0 = R3e & R3c;                   # time flags - has time increment passed?
6977: df,d7               je    6950             if (R0 = 0) goto 6950;            # no, loop to next entry
6979: 31,3c,05            jnb   B1,R3c,6981      if (Word_tmr = 1)  {              # Byte or Word timer
697c: a2,32,36            ldw   R36,[R32]        R36 = [R32];                      # read current Word value
697f: 20,03               sjmp  6984             goto 6984; }
6981: be,32,36            ldsbw R36,[R32]        R36 = (int)[R32];                 # read current Byte value
6984: 32,3c,04            jnb   B2,R3c,698b      if (Decrement = 0) goto 698b;     # OK - update. Up or Down
6987: 03,36               negw  R36              R36 = -R36;                       # negate value
6989: df,18               je    69a3             if (R36 != 0)  {                  # if zero jump straight to save
698b: 3d,3c,04            jb    B5,R3c,6992      if (Millisecs = 0)  {
698e: 07,36               incw  R36              R36++;                            # Not mSecs, increment timer
6990: 20,03               sjmp  6995             goto 6995; }
6992: 64,38,36            ad2w  R36,R38          R36 += R38;                       # add mSecs to timer
6995: d3,07               jnc   699e             if ((uns) R36 < 0) goto 699e;
6997: 01,36               clrw  R36              R36 = 0;                          # overflow, wrap to zero
6999: 3a,3c,07            jb    B2,R3c,69a3      if (Decrement = 0)  {             # down - jmp straight to save
699c: 05,36               decw  R36              R36--;                            # up, set -1 ?
699e: 32,3c,02            jnb   B2,R3c,69a3      if (Decrement = 1)  {             # jmp to save word/byte
69a1: 03,36               negw  R36              R36 = -R36; } } }
69a3: 31,3c,05            jnb   B1,R3c,69ab      if (Word_tmr = 1)  {
69a6: c2,32,36            stw   R36,[R32]        [R32] = R36;                      # save Word timer
69a9: 27,a5               sjmp  6950             goto 6950; }
69ab: c6,32,36            stb   R36,[R32]        [R32] = R36;                      # save Byte timer
69ae: 27,a0               sjmp  6950             goto 6950;
69b0: f0                  ret                    return;

###################################### 
# TIMERS Table 
# 3 or 5 byte entries
# byte  0    = flags word
# byte  2&3 WORD = timer address
# if 5 byte entry - timer controlled by flag(s)
# byte  4    = flag mask - selects control bit(s) in address
# byte  5    = flags address (start/stop) timer
#
# 2X = timer in 1/1024 seconds (~msec)
# 4X = timer in 1/8 seconds
# 8X = timer in seconds
# So
# bit 0 = 0 if short entry (3 or 5 bytes)
# bit 1 = 1 if 16 bit timer else 0 = 8 bit timer
# bit 2 = 0 timer count up vs down
# bit 3 = 0 if flag bit must be set to update timer loc
# bit 4 not used
# bit 5 = 1 update in 1/1024 seconds (~msec)
# bit 6 = update in 1/8 seconds
# bit 7 = update in seconds
# else entry size = 5
# entry size = 2 if bit 0 of first byte = 0
# in follow Table the 15 bit address field is byte flipped for correct word order
######################################




  Timer_list:
69b1: 20,36,01            struct 20, Baptmr,                                       # Byte,mSecs,Up. Time since last BP pulse?
69b4: 89,c8,00,80,a1      struct 89, Atmr1, Cranking,                              # Byte,Secs,Up. Time since Cranking = 0
69b9: 81,c9,00,40,24      struct 81, Atmr2, Atmr2_On,                              # Byte,Secs,Up. Time since Atmr2_On = 1
69be: 89,4d,01,04,a1      struct 89, Atmr3, Undsp,                                 # Byte,Secs,Up. Time since Undsp = 0
69c3: 81,66,02,80,27      struct 81, Lestmr1, Lestmr1_On,                          # Byte,Secs,Up. Time since Lestmr1_On = 1
69c8: 81,67,02,40,27      struct 81, Lestmr2, Lestmr2_On,                          # Byte,Secs,Up. Time since Lestmr2_On = 1
69cd: 81,cb,00,04,24      struct 81, Awotmr, Awotmr_On,                            # Byte,Secs,Up. Time since Awotmr_On = 1
69d2: 81,cd,00,20,24      struct 81, Nactmr, Nactmr_On,                            # Byte,Secs,Up. Time since Nactmr_On = 1
69d7: 83,3a,01,01,a1      struct 83, Adptmr, Adptmr_On,                            # Word,Secs,Up. Time since Adptmr_On = 1
69dc: 41,45,01,80,ed      struct 41, Lugtmr, Lugtmr_up,                            # Byte,1/8s,Up. Time since Lugtmr_up = 1
69e1: 45,45,01,40,ed      struct 45, Lugtmr, Lugtmr_dwn,                           # Byte,1/8s,Down. Time since Lugtmr_dwn = 1
69e6: 80,4e,01            struct 80, Edftmr,                                       # Byte,Secs,Up. 
69e9: 40,ca,01            struct 40, Vip_timer_ex,                                 # Byte,1/8s,Up. 
69ec: 42,c0,01            struct 42, Miltmr,                                       # Word,1/8s,Up. 
69ef: 22,34,01            struct 22, Putmr,                                        # Word, mSecs,Up. 
69f2: 41,c8,01,20,2b      struct 41, Tsstil, Stiflg,                               # Byte,1/8s,Up. Time since Stiflg = 1
69f7: 83,c2,01,40,2a      struct 83, Outtmr, No_start,                             # Word,Secs,Up. Time since No_start = 1
69fc: 22,3e,01            struct 22, Tslpip,                                       # Word, mSecs,Up.
69ff: 22,c4,01            struct 22, Tslidm,                                       # Word, mSecs,Up.
6a02: 81,37,01,04,eb      struct 81, Hmtmr, Hmtmr_On,                              # Byte,Secs,Up. Time since Hmtmr_On = 1
6a07: 49,4c,01,01,29      struct 49, Hltmr, Hltmr_Off,                             # Byte,1/8s,Up. Time since Hltmr_Off = 0
6a0c: 80,38,01            struct 80, Ctatmr,                                       # Byte,1/8s,Up.
6a0f: 41,2a,01,40,a1      struct 41, Cttmr, Cttmr_On,                              # Byte,1/8s,Up. Time since Cttmr_On = 1
6a14: 81,44,01,02,e8      struct 81, Ctntmr, Ctntmr_up,                            # Byte,Secs,Up. Time since Ctntmr_up = 1
6a19: 85,44,01,01,e8      struct 85, Ctntmr, Ctntmr_dwn,                           # Byte,Secs,Down. Time since Ctntmr_dwn = 1
6a1e: 89,20,02,01,24      struct 89, Nwotmr, Wot,                                  # Byte,Secs,Up. Time since Wot = 0 (Not WOT)
6a23: 81,ce,00,01,ec      struct 81, Mfatmr, Mfa_on,                               # Byte,Secs,Up. Time since Mfa_on = 1 (managed Fuel)
6a28: 81,64,02,80,24      struct 81, Tsegre, Tsegre_On,                            # Byte,Secs,Up. Time since Tsegre_On = 1
6a2d: 23,1e,02,40,4f      struct 23, Tsladv, Knock_enabled,                        # Word,mSecs,Up. Time since Knock_enabled = 1
6a32: 80,46,01            struct 80, Isctmr,                                       # Byte,Secs,Up. 
6a35: 20,47,01            struct 20, Multmr,                                       # Byte,mSecs,Up. 
6a38: 40,cc,00            struct 40, Nddtim,                                       # Byte,1/8s,Up. 
6a3b: 42,16,02            struct 42, Acctmr,                                       # Word,1/8s,Up. 
6a3e: 80,14,02            struct 80, Acwtmr,                                       # Byte,Secs,Up. 
6a41: 40,15,02            struct 40, Wcotmr,                                       # Byte,1/8s,Up. 
6a44: 23,18,02,04,ea      struct 23, Acitmr, Aciflg,                               # Word,mSecs,Up. Time since Aciflg = 1
6a49: 41,13,02,02,ea      struct 41, Acbtmr, Biflg,                                # Byte,1/8s,Up. Time since Biflg = 1
6a4e: 41,39,01,40,ec      struct 41, Sltmr, Sltmr_flgs,                            # Byte,mSecs,Up. Time since Sltmr_flgs = 1
6a53: 26,a8,02            struct 26, Debtmr,                                       # Word,mSecs,Down. 
6a56: 20,bb,02            struct 20, Tslmph,                                       # Byte,mSecs,Up.
6a59: 40,4f,01            struct 40, Crktmr,                                       # Byte,1/8s,Up. 
6a5c: 81,49,01,40,ef      struct 81, Prgtmr, Prgflg,                               # Byte,Secs,Up. Time since Prgflg = 1 
6a61: 41,4a,01,40,ef      struct 41, Cprgtmr, Prgflg,                              # Byte,1/8s,Up. Time since Egofl2 = 1
6a66: 21,50,01,08,a1      struct 21, Dltmr, Dmflg,                                 # Byte,mSecs,Up. Time since Dmflg = 1
6a6b: 22,32,01            struct 22, Ffmtmr,                                       # Word,mSecs,Up.
6a6e: 40,c9,01            struct 40, Vsstmr,                                       # Byte,1/8s,Up. 
6a71: 40,c6,01            struct 40, Vip_fpmtmr,                                   # Byte,1/8s,Up. 
6a74: 22,aa,03            struct 22, Hwtmr,                                        # Word,mSecs,Up.
6a77: 22,a8,03            struct 22, A3CTMR,                                       # Word,mSecs,Up.

#################################################################
# Tasklist Routine at 2151, routine offset 46
# Update shift light
#################################################################
6a7a: 00                  byte  


  Upd_ShiftL:
6a7b: b3,fe,03,30         ldb   R30,[Rfe+3]      R30 = Tstrat;                     # 9E5D=0(Manual trans) - TSTRAT - transmission stratagey
6a7f: 99,01,30            cmpb  R30,1                                              # SIL (Shift Indicator Light)
6a82: d7,55               jne   6ad9             if (R30 = 1)  {
6a84: 38,d0,2d            jb    B0,Rd0,6ab4      if (B0_Apt = 0)  {                # jmp if ?
6a87: 45,34,00,f0,32      ad3w  R32,Rf0,34       R32 = Fn651;                      # Table 8C34 - Incremental Indicated RPM shift point as a function of ECT
6a8c: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
6a8f: ef,6f,cb            call  3601             SUWordLU();
6a92: c0,14,38            stw   R38,R14          R14 = R38;
6a95: 45,50,00,f0,32      ad3w  R32,Rf0,50       R32 = Fn652A;                     # Table 8C50 - Indicated RPM shift point as a function of LOAD.
6a9a: a3,74,de,34         ldw   R34,[R74+de]     R34 = Load;                       # engine load (VE? )
6a9e: ef,6b,cb            call  360c             UUWordLu();
6aa1: 64,38,14            ad2w  R14,R38          R14 += R38;                       # add RPM shift points
6aa4: 8b,f0,0c,ae         cmpw  Rae,[Rf0+c]                                        # ROM 8C0C - SPTRPM
6aa8: d9,05               jgtu  6aaf             if ((uns) Rpmx4 > [8c0c] ) goto 6aaf;
6aaa: 88,14,ae            cmpw  Rae,R14          
6aad: d1,05               jleu  6ab4             if ((uns) Rpmx4 > R14 )  {
6aaf: 91,40,ec            orb   Rec,40           Sltmr_flgs = 1;                   # set SLTMR FLG
6ab2: 20,07               sjmp  6abb             goto 6abb; } }
6ab4: 71,bf,ec            an2b  Rec,bf           Sltmr_flgs = 0;                   # clr SLTMR FLG
6ab7: c7,72,b9,00         stb   R0,[R72+b9]      Sltmr = 0;                        # zero 139 timer - SLTMR
6abb: 3f,a1,1b            jb    B7,Ra1,6ad9      if (Cranking = 0)  {
6abe: 8b,f0,0e,ae         cmpw  Rae,[Rf0+e]      
6ac2: d9,10               jgtu  6ad4             if ((uns) Rpmx4 > [8c0e] ) goto 6ad4;
6ac4: b3,72,b9,30         ldb   R30,[R72+b9]     R30 = Sltmr;                      # 139 Shift Light Timer
6ac8: 9b,f0,10,30         cmpb  R30,[Rf0+10]     
6acc: d1,0b               jleu  6ad9             if ((uns) R30 > [8c10] )  {
6ace: 9b,f0,11,30         cmpb  R30,[Rf0+11]     
6ad2: d9,05               jgtu  6ad9             if ((uns) R30 <= [8c11])  {
6ad4: 91,04,47            orb   R47,4            ShLight_On = 1;                   # R47 bit 2 ON Shift Light
6ad7: 20,03               sjmp  6adc             return; } } } }
6ad9: 71,fb,47            an2b  R47,fb           ShLight_On = 0;                   # R47 bit 2 OFF Shift Light
6adc: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 48
#################################################################


  Upd_Thermactor:
6add: 9b,f6,66,00         cmpb  R0,[Rf6+66]                                        # 940E - HPACL
6ae1: df,25               je    6b08             if (0 != Hpacl)  {                # return if no Thermactor present
6ae3: 3f,a1,0a            jb    B7,Ra1,6af0      if (Cranking = 1) goto 6af0;
6ae6: a3,74,d4,30         ldw   R30,[R74+d4]     R30 = Archg;
6aea: 8b,f6,68,30         cmpw  R30,[Rf6+68]     
6aee: db,10               jc    6b00             if ((uns) R30 >= [9410]) goto 6b00;
6af0: a3,01,26,01,30      ldw   R30,[R0+126]     R30 = TPS_Min;                    # 126 - Filtered TP
6af5: 67,f6,6a,30         ad2w  R30,[Rf6+6a]     R30 += [9412];                    # 9412 - SHKTP
6af9: db,0a               jc    6b05             if (R30 > 0)  {
6afb: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
6afe: d3,05               jnc   6b05             if ((uns) TP >= R30)  {
6b00: 91,10,47            orb   R47,10           Iac = 1;                          # R47 bit 4 ON (Air management2)
6b03: 20,03               sjmp  6b08             return; } }
6b05: 71,ef,47            an2b  R47,ef           Iac = 0; }                        # R47 bit 4 OFF (Air management2)
6b08: f0                  ret                    return;


  Sub36:
6b09: 31,eb,03            jnb   B1,Reb,6b0f      if (Sigpip = 0) goto 6b0f;        # jmp if not SIGPIP
6b0c: 3e,2e,02            jb    B6,R2e,6b11      if (Synflg = 1) goto 6b11;        # jmp if SYNFLG
6b0f: 20,7d               sjmp  6b8e             goto 6b8e;
6b11: 4b,76,c6,ba,50      sb3w  R50,Rba,[R76+c6] R50 = PIPHi_ETime - Dtsig;        # RBA - PIP time lo 16 bits
6b16: db,02               jc    6b1a             if (R50 > 0)  {
6b18: 03,50               negw  R50              R50 = -R50; }
6b1a: c3,76,c6,ba         stw   Rba,[R76+c6]     Dtsig = PIPHi_ETime;              # RBA - PIP time lo 16 bits
6b1e: a3,f0,0a,54         ldw   R54,[Rf0+a]      R54 = Ssfctr;
6b22: 6c,ba,54            ml2w  R54,Rba          R54 *= PIPHi_ETime;               # RBA - PIP time lo 16 bits
6b25: 88,56,50            cmpw  R50,R56          
6b28: db,64               jc    6b8e             if (R50 > R56)  {
6b2a: 4b,76,ba,ba,50      sb3w  R50,Rba,[R76+ba] R50 = PIPHi_ETime - Prev_PIP_ETime; # RBA - PIP time lo 16 bits
6b2f: db,02               jc    6b33             if (R50 > 0)  {
6b31: 03,50               negw  R50              R50 = -R50; }
6b33: 88,56,50            cmpw  R50,R56          
6b36: db,56               jc    6b8e             if (R50 > R56)  {
6b38: a3,76,c2,50         ldw   R50,[R76+c2]     R50 = Sigdlt;
6b3c: c0,54,50            stw   R50,R54          R54 = R50;
6b3f: c0,58,50            stw   R50,R58          R58 = R50;
6b42: 6b,76,c4,50         sb2w  R50,[R76+c4]     R50 -= Psgdlt;
6b46: db,02               jc    6b4a             if (R50 > 0)  {
6b48: 03,50               negw  R50              R50 = -R50; }
6b4a: a3,f0,0a,56         ldw   R56,[Rf0+a]      R56 = Ssfctr;
6b4e: 6c,56,54            ml2w  R54,R56          R54 *= R56;
6b51: 88,56,50            cmpw  R50,R56          
6b54: db,38               jc    6b8e             if (R50 > R56)  {
6b56: a0,ba,56            ldw   R56,Rba          R56 = PIPHi_ETime;
6b59: 01,54               clrw  R54              R54 = 0;
6b5b: 0c,02,54            shrdw R54,2            R54 /= 4;
6b5e: 8c,58,54            divw  R54,R58          R54 /= R58;
6b61: dd,2b               jv    6b8e             if (OVF = 0)  {
6b63: a3,f2,04,50         ldw   R50,[Rf2+4]      R50 = Fkskay;
6b67: 6c,50,54            ml2w  R54,R50          R54 *= R50;
6b6a: 03,50               negw  R50              R50 = -R50;
6b6c: a3,76,c0,52         ldw   R52,[R76+c0]     R52 = Sigkal;
6b70: 6c,52,50            ml2w  R50,R52          R50 *= R52;
6b73: 64,52,56            ad2w  R56,R52          R56 += R52;
6b76: 8b,f2,06,56         cmpw  R56,[Rf2+6]      
6b7a: db,04               jc    6b80             if (R56 > Sigkll)  {
6b7c: a3,f2,06,56         ldw   R56,[Rf2+6]      R56 = Sigkll; }
6b80: 8b,f2,08,56         cmpw  R56,[Rf2+8]      
6b84: d1,04               jleu  6b8a             if ((uns) R56 > Sigklu )  {
6b86: a3,f2,08,56         ldw   R56,[Rf2+8]      R56 = Sigklu; }
6b8a: c3,76,c0,56         stw   R56,[R76+c0]     Sigkal = R56; } } } }
6b8e: 9b,fe,07,bd         cmpb  Rbd,[Rfe+7]      
6b92: d1,0c               jleu  6ba0             if ((uns) Kayctr > PIPsC )  {
6b94: b1,01,bd            ldb   Rbd,1            Kayctr = 1;
6b97: c3,74,22,ba         stw   Rba,[R74+22]     Dtpcyc = PIPHi_ETime;
6b9b: c3,74,24,be         stw   Rbe,[R74+24]     Hfpcyc = PIPH_PW;
6b9f: f0                  ret                    return; }

6ba0: 17,bd               incb  Rbd              Kayctr++;
6ba2: 9b,fe,07,bd         cmpb  Rbd,[Rfe+7]      
6ba6: d1,6b               jleu  6c13             if ((uns) Kayctr > PIPsC )  {
6ba8: 39,eb,68            jb    B1,Reb,6c13      if (Sigpip = 1) return;
6bab: 4b,74,22,ba,50      sb3w  R50,Rba,[R74+22] R50 = PIPHi_ETime - Dtpcyc;
6bb0: db,02               jc    6bb4             if (R50 > 0)  {
6bb2: 03,50               negw  R50              R50 = -R50; }
6bb4: a3,f0,0a,52         ldw   R52,[Rf0+a]      R52 = Ssfctr;
6bb8: 4c,52,ba,54         ml3w  R54,Rba,R52      R54 = PIPHi_ETime * R52;
6bbc: 88,56,50            cmpw  R50,R56          
6bbf: d9,52               jgtu  6c13             if ((uns) R50 > R56 ) return;
6bc1: 4b,74,24,be,50      sb3w  R50,Rbe,[R74+24] R50 = PIPH_PW - Hfpcyc;
6bc6: db,02               jc    6bca             if (R50 > 0)  {
6bc8: 03,50               negw  R50              R50 = -R50; }
6bca: 4c,52,be,54         ml3w  R54,Rbe,R52      R54 = PIPH_PW * R52;
6bce: 88,56,50            cmpw  R50,R56          
6bd1: d9,40               jgtu  6c13             if ((uns) R50 > R56 ) return;
6bd3: 01,54               clrw  R54              R54 = 0;
6bd5: 47,74,22,ba,56      ad3w  R56,Rba,[R74+22] R56 = PIPHi_ETime + Dtpcyc;
6bda: db,37               jc    6c13             if ((uns) R56 >= 0) return;
6bdc: 0c,02,54            shrdw R54,2            R54 /= 4;
6bdf: 47,74,24,be,50      ad3w  R50,Rbe,[R74+24] R50 = PIPH_PW + Hfpcyc;
6be4: db,2d               jc    6c13             if ((uns) R50 >= 0) return;
6be6: 8c,50,54            divw  R54,R50          R54 /= R50;
6be9: dd,28               jv    6c13             if (OVF = 1) return;
6beb: 89,99,99,54         cmpw  R54,9999         
6bef: db,22               jc    6c13             if ((uns) R54 >= 9999) return;
6bf1: 4d,00,e0,c0,50      ml3w  R50,Rc0,e000     R50 = Mkay * e000;
6bf6: 6d,00,20,54         ml2w  R54,2000         R54 *= 2000;
6bfa: 44,52,56,c0         ad3w  Rc0,R56,R52      Mkay = R56 + R52;                 # Now check for 10% each way ?
6bfe: 89,33,73,c0         cmpw  Rc0,7333         
6c02: db,05               jc    6c09             if (Mkay > 7333)  {
6c04: a1,33,73,c0         ldw   Rc0,7333         Mkay = 7333;                      # = 0.9 ?
6c08: f0                  ret                    return; }

6c09: 89,cd,8c,c0         cmpw  Rc0,8ccd         
6c0d: d1,04               jleu  6c13             if ((uns) Mkay <= 8ccd) return;
6c0f: a1,cd,8c,c0         ldw   Rc0,8ccd         Mkay = 8ccd; }                    # = 1.10 ?
6c13: f0                  ret                    return;


  Sub37:
6c14: a0,be,54            ldw   R54,Rbe          R54 = PIPH_PW;
6c17: 6c,c0,54            ml2w  R54,Rc0          R54 *= Mkay;
6c1a: 99,40,57            cmpb  R57,40           
6c1d: d3,02               jnc   6c21             if ((uns) R57 < 40) goto 6c21;
6c1f: 20,6d               sjmp  6c8e             return;
6c21: 0d,02,54            shldw R54,2            R54 *= 4;
6c24: 48,56,ba,50         sb3w  R50,Rba,R56      R50 = PIPHi_ETime - R56;          # PIP time lo 16 bits with correction
6c28: db,02               jc    6c2c             if (R50 > 0)  {
6c2a: 03,50               negw  R50              R50 = -R50; }
6c2c: a3,76,ba,54         ldw   R54,[R76+ba]     R54 = Prev_PIP_ETime;
6c30: 6b,76,bc,54         sb2w  R54,[R76+bc]     R54 -= Prev_PIPH_PW;
6c34: 6c,be,54            ml2w  R54,Rbe          R54 *= PIPH_PW;
6c37: 8f,76,bc,54         divw  R54,[R76+bc]     R54 /= Prev_PIPH_PW;
6c3b: dd,51               jv    6c8e             if (OVF = 1) return;
6c3d: 64,be,54            ad2w  R54,Rbe          R54 += PIPH_PW;
6c40: db,4c               jc    6c8e             if ((uns) R54 >= 0) return;
6c42: 48,54,ba,52         sb3w  R52,Rba,R54      R52 = PIPHi_ETime - R54;
6c46: db,02               jc    6c4a             if (R52 > 0)  {
6c48: 03,52               negw  R52              R52 = -R52; }
6c4a: b3,76,be,54         ldb   R54,[R76+be]     R54 = Tl0FLG;
6c4e: 11,56               clrb  R56              R56 = 0;
6c50: 88,52,50            cmpw  R50,R52          
6c53: d9,1b               jgtu  6c70             if ((uns) R50 <= R52)  {
6c55: 37,54,0a            jnb   B7,R54,6c62      if (B7_R54 = 1)  {
6c58: b3,76,bf,56         ldb   R56,[R76+bf]     R56 = Difctr;
6c5c: 17,56               incb  R56              R56++;
6c5e: d3,02               jnc   6c62             if ((uns) R56 >= 0)  {
6c60: 15,56               decb  R56              R56--; } }
6c62: c7,76,bf,56         stb   R56,[R76+bf]     Difctr = R56;
6c66: 9b,fe,14,56         cmpb  R56,[Rfe+14]     
6c6a: d3,22               jnc   6c8e             if ((uns) R56 < [9e6e]) return;
6c6c: 11,54               clrb  R54              R54 = 0;
6c6e: 20,1a               sjmp  6c8a             goto 6c8a; }
6c70: 3f,54,0a            jb    B7,R54,6c7d      if (B7_R54 = 0)  {
6c73: b3,76,bf,56         ldb   R56,[R76+bf]     R56 = Difctr;
6c77: 17,56               incb  R56              R56++;
6c79: d3,02               jnc   6c7d             if ((uns) R56 >= 0)  {
6c7b: 15,56               decb  R56              R56--; } }
6c7d: c7,76,bf,56         stb   R56,[R76+bf]     Difctr = R56;
6c81: 9b,fe,15,56         cmpb  R56,[Rfe+15]     
6c85: d3,07               jnc   6c8e             if ((uns) R56 < [9e6f]) return;
6c87: b1,80,54            ldb   R54,80           R54 = 80;
6c8a: c7,76,be,54         stb   R54,[R76+be]     Tl0FLG = R54;
6c8e: f0                  ret                    return;

#################################################################
# handle HSI line 1 data - Knock sensor
# check for Knock if reqd
#################################################################


  Knk_inth:
6c8f: 71,fd,87            an2b  R87,fd           Knk_irq = 0;                      # mask HSI data
6c92: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # 947A KIHP = 00 ( is there a knock sensor )
6c96: df,06               je    6c9e             if (0 != Kihp)  {                 # jump if line data = 0
6c98: 91,08,4f            orb   R4f,8            Knock_detected = 1;               # set KNOCK DETECTED
6c9b: 91,08,d9            orb   Rd9,8            Vip_knock = 1; }                  # set VIP KNOCK
6c9e: f0                  ret                    return;


  Sub38:
6c9f: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # 947A KIHP = 00 ( is there a knock sensor )
6ca3: d7,01               jne   6ca6             if (0 = Kihp)  {
6ca5: f0                  ret                    return; }

6ca6: 8b,f8,44,ae         cmpw  Rae,[Rf8+44]                                       # ROM 9474 - RPMCNL
6caa: d1,12               jleu  6cbe             if ((uns) Rpmx4 > RPMCNL )  {     # jmp if N <= RPMCNL
6cac: 9b,f8,49,dd         cmpb  Rdd,[Rf8+49]                                       # KWCTR : ROM 9479 - WINCLD
6cb0: db,0c               jc    6cbe             if (Kwctr > WINCLD)  {            # jmp if KWCTR >= WINCLD
6cb2: 33,4f,03            jnb   B3,R4f,6cb8      if (Knock_detected = 1)  {        # jmp if not KNOCK DETECTED
6cb5: 17,dd               incb  Rdd              Kwctr++;                          # KWCTR
6cb7: f0                  ret                    return; }

6cb8: 31,eb,03            jnb   B1,Reb,6cbe      if (Sigpip = 1)  {                # SIGPIP
6cbb: 17,dd               incb  Rdd              Kwctr++;                          # KWCTR
6cbd: f0                  ret                    return; } } }

6cbe: 11,dd               clrb  Rdd              Kwctr = 0;                        # KWCTR
6cc0: a1,22,03,7e         ldw   R7e,322          Rtab = Q9;                        # QUEUE 9
6cc4: 9b,7e,01,00         cmpb  R0,[R7e+1]                                         # 323
6cc8: df,04               je    6cce             if (0 != [Rtab+1])  {
6cca: 91,02,4e            orb   R4e,2            Kts_pending = 1;
# 2284 proc address
6ccd: f0                  ret                    return; }

6cce: 28,15               scall 6ce5             Sub39();
6cd0: a1,86,22,92         ldw   R92,2286         TPtr = 2286;
6cd4: ef,22,b8            call  24f9             Do_CmdN();
6cd7: f0                  ret                    return;


  Add_H_Beta:
6cd8: 39,4e,07            jb    B1,R4e,6ce2      if (Kts_pending = 0)  {
6cdb: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
6cdf: cc,00               pop   R0               R0 = pop();
6ce1: f0                  ret                    return; }

6ce2: 71,fd,4e            an2b  R4e,fd           Kts_pending = 0;                  # clr R4E bit 1

  Sub39:
6ce5: 4c,c0,be,50         ml3w  R50,Rbe,Rc0      R50 = PIPH_PW * Mkay;
6ce9: 99,40,53            cmpb  R53,40           
6cec: db,12               jc    6d00             if (R53 > 40)  {
6cee: 0d,02,50            shldw R50,2            R50 *= 4;
6cf1: a0,52,50            ldw   R50,R52          R50 = R52;
6cf4: 6f,74,a8,50         ml2w  R50,[R74+a8]     R50 *= Htime_beta;
6cf8: 3f,53,05            jb    B7,R53,6d00      if (B7_R53 = 0)  {
6cfb: 0d,01,50            shldw R50,1            R50 *= 2;
6cfe: 20,03               sjmp  6d03             goto 6d03; } }
6d00: bd,ff,52            ldsbw R52,ff           R52 = (int)ff;
6d03: 47,74,50,52,80      ad3w  R80,R52,[R74+50] HSO_time = R52 + Prev_PIP_time;   # last saved PIP event time (24 bits)
6d08: b3,74,52,82         ldb   R82,[R74+52]     HSO_timeH = Prev_PIP_timeH;
6d0c: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
6d0f: f8                  clc                    CY = 0
6d10: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 36
#################################################################


  Add_H_Delta:
6d11: 67,74,aa,80         ad2w  R80,[R74+aa]     HSO_time += Htime_delta;
6d15: 27,f5               sjmp  6d0c             goto 6d0c;

  UPd_KnkRet:
6d17: 3f,4e,02            jb    B7,R4e,6d1c      if (New_pip = 1) goto 6d1c;       # New PIP received flag
6d1a: 20,8e               sjmp  6daa             goto 6daa;
6d1c: 45,62,03,f8,32      ad3w  R32,Rf8,362      R32 = 9792;                       # unknown function
6d21: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
6d24: 08,07,34            shrw  R34,7            R34 /= 80;                        # = RPM / 128
6d27: ef,8d,c8            call  35b7             UUbyteLu();
6d2a: 09,07,38            shlw  R38,7            R38 *= 80;                        # Table output * 128
6d2d: 67,f8,40,38         ad2w  R38,[Rf8+40]     R38 += WOPEN;                     # = WOPEN
6d31: c3,74,a8,38         stw   R38,[R74+a8]     Htime_beta = R38;                 # WINDOW BETA
6d35: 45,54,03,f8,32      ad3w  R32,Rf8,354      R32 = 9784;                       # output is fraction of PIP Period.
6d3a: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
6d3d: 08,07,34            shrw  R34,7            R34 /= 80;                        # Table output * 128
6d40: ef,74,c8            call  35b7             UUbyteLu();
6d43: 6c,ba,38            ml2w  R38,Rba          R38 *= PIPHi_ETime;               # RBA - PIP time lo 16 bits
6d46: 0d,06,38            shldw R38,6            R38 *= 40;                        # multiply by 64
6d49: 67,f8,42,3a         ad2w  R3a,[Rf8+42]     R3a += WINLEN;                    # 9472 - WINLEN
6d4d: c3,74,aa,3a         stw   R3a,[R74+aa]     Htime_delta = R3a;                # 228 - WINDOW DELTA
6d51: 45,48,03,f8,32      ad3w  R32,Rf8,348      R32 = 9778;                       # Retard increment versus RPM, deg.
6d56: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
6d59: 08,07,34            shrw  R34,7            R34 /= 80;                        # Table output * 128
6d5c: ef,58,c8            call  35b7             UUbyteLu();
6d5f: c4,e2,38            stb   R38,Re2          Retinc = R38;                     # RET INC
6d62: 36,4f,45            jnb   B6,R4f,6daa      if (Knock_enabled = 1)  {
6d65: 45,6c,03,f8,32      ad3w  R32,Rf8,36c      R32 = Advrpm;                     # Spark Advance Rate vs RPM
6d6a: a0,ae,34            ldw   R34,Rae          R34 = Rpmx4;
6d6d: 08,07,34            shrw  R34,7            R34 /= 80;                        # RPM / 128
6d70: ef,44,c8            call  35b7             UUbyteLu();
6d73: 09,04,38            shlw  R38,4            R38 *= 10;                        # adv * 16
6d76: 8b,74,a0,38         cmpw  R38,[R74+a0]     
6d7a: d9,2e               jgtu  6daa             if ((uns) R38 <= Tsladv)  {
6d7c: a3,74,a0,3c         ldw   R3c,[R74+a0]     R3c = Tsladv;
6d80: 68,38,3c            sb2w  R3c,R38          R3c -= R38;
6d83: c3,74,a0,3c         stw   R3c,[R74+a0]     Tsladv = R3c;

# Advance all cyls 1 degree of spark
6d87: fa                  di                     disable ints;
6d88: ff                  nop                    
6d89: b1,01,40            ldb   R40,1            R40 = 1;                          # add 1 degree of advance to each cyl
6d8c: ad,08,42            ldzbw R42,8            R42 = (uns)8;
6d8f: 57,43,2b,02,40,30   ad3b  R30,R40,[R42+22b] R30 = R40 + [R42+Spkadv];        # 22B - SparkAdvance[ cyl 1 -8 ]
6d95: dd,06               jv    6d9d             if (OVF = 1) goto 6d9d;
6d97: 9b,f8,31,30         cmpb  R30,[Rf8+31]     
6d9b: da,04               jle   6da1             if ((uns) R30 < ADVLIM)  {
6d9d: b3,f8,31,30         ldb   R30,[Rf8+31]     R30 = ADVLIM; }                   # Advance Limit
6da1: c7,43,2b,02,30      stb   R30,[R42+22b]    [R42+Spkadv] = R30;               # 22B - SparkAdvance[ cyl 1 -8 ] new advance for this cyl
6da6: e0,42,e6            djnz  R42,6d8f         R42--;
                                                 if (R42 != 0) goto 6d8f;
6da9: fb                  ei                     enable ints; } }
6daa: ef,a7,c8            call  3654             Srolav3T(Tbart,TP,9806);          # Filter Throttle Posn
6dad: 2a,02,aa,00,5e,d0   #args  
6db3: c3,74,ac,3e         stw   R3e,[R74+ac]     Tbart = R3e;                      # filtered result
6db7: a3,74,ac,38         ldw   R38,[R74+ac]     R38 = Tbart;
6dbb: a0,aa,3a            ldw   R3a,Raa          R3a = TP;
6dbe: 0c,01,38            shrdw R38,1            R38 /= 2;
6dc1: 68,38,3a            sb2w  R3a,R38          R3a -= R38;
6dc4: c3,74,00,3a         stw   R3a,[R74+0]      Tcf = R3a;
6dc8: 98,d0,00            cmpb  R0,Rd0           
6dcb: da,0f               jle   6ddc             if ((uns) 0 < Apt)  {
6dcd: a3,f8,34,14         ldw   R14,[Rf8+34]     R14 = TIPLOD;
6dd1: 8b,74,de,14         cmpw  R14,[R74+de]     
6dd5: d1,05               jleu  6ddc             if ((uns) R14 > Load )  {
6dd7: 91,20,2d            orb   R2d,20           Ctflg = 1;
6dda: 20,16               sjmp  6df2             goto 6df2; } }
6ddc: a3,f8,36,38         ldw   R38,[Rf8+36]     R38 = TIPHS;
6de0: 67,f8,34,38         ad2w  R38,[Rf8+34]     R38 += TIPLOD;
6de4: d3,03               jnc   6de9             if ((uns) R38 >= 0)  {
6de6: bd,ff,38            ldsbw R38,ff           R38 = (int)ff; }
6de9: 8b,74,de,38         cmpw  R38,[R74+de]     
6ded: db,03               jc    6df2             if (R38 > Load)  {
6def: 71,df,2d            an2b  R2d,df           Ctflg = 0; }
6df2: a3,f8,2e,14         ldw   R14,[Rf8+2e]     R14 = KACRAT;
6df6: 8b,74,00,14         cmpw  R14,[R74+0]      
6dfa: d2,11               jgt   6e0d             if (R14 <= Tcf)  {
6dfc: 9b,f8,3d,b0         cmpb  Rb0,[Rf8+3d]     
6e00: da,0b               jle   6e0d             if ((uns) ECT < [946d])  {
6e02: 8b,f8,3e,ae         cmpw  Rae,[Rf8+3e]     
6e06: db,05               jc    6e0d             if (Rpmx4 > NTIP)  {
6e08: 91,40,2d            orb   R2d,40           Tipflg = 1;
6e0b: 20,03               sjmp  6e10             goto 6e10; } } }
6e0d: 71,bf,2d            an2b  R2d,bf           Tipflg = 0;
6e10: 9b,f8,3c,b0         cmpb  Rb0,[Rf8+3c]     
6e14: da,1d               jle   6e33             if ((uns) ECT < [946c])  {
6e16: 8b,f8,38,ae         cmpw  Rae,[Rf8+38]     
6e1a: d1,17               jleu  6e33             if ((uns) Rpmx4 > RPMMIN )  {
6e1c: a3,f8,3a,14         ldw   R14,[Rf8+3a]     R14 = LODNOK;
6e20: b3,f8,4a,42         ldb   R42,[Rf8+4a]     R42 = Kihp;                       # is there a knock sensor ?
6e24: 8b,74,de,14         cmpw  R14,[R74+de]                                       # engine load (VE? )
6e28: db,09               jc    6e33             if (R14 > Load)  {
6e2a: 98,42,00            cmpb  R0,R42           
6e2d: db,04               jc    6e33             if (0 > R42)  {
6e2f: 91,40,4f            orb   R4f,40           Knock_enabled = 1;
6e32: f0                  ret                    return; } } } }

6e33: 36,4f,12            jnb   B6,R4f,6e48      if (Knock_enabled = 0) return;
6e36: 71,bf,4f            an2b  R4f,bf           Knock_enabled = 0;
6e39: ad,08,42            ldzbw R42,8            R42 = (uns)8;
6e3c: c7,43,2b,02,00      stb   R0,[R42+22b]     [R42+Spkadv] = 0;                 # clr SparkAdvance[ cyl 1 -8 ]
6e41: e0,42,f8            djnz  R42,6e3c         R42--;
                                                 if (R42 != 0) goto 6e3c;
6e44: c3,74,a0,00         stw   R0,[R74+a0]      Tsladv = 0; }
6e48: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 4E
# Key On Engine Off, Engine Running, Continuous tests
# There are 4 proc Tables BASE A - BASE D - how do these correspond to
# self test stuff
#################################################################


  Do_SelfTest:
6e49: 71,fe,d9            an2b  Rd9,fe           Vip_fp_override = 0;
6e4c: 2a,48               scall 7096             Set_EGRFlags();                   # Set up EGR flags
6e4e: 71,f7,2c            an2b  R2c,f7           Wigflg = 0;
6e51: 3a,2a,0c            jb    B2,R2a,6e60      if (Vip_enable = 0)  {            # jump if VIP enable is set
6e54: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = Putmr;                      # Time since CPU power up - mS
6e58: 99,10,43            cmpb  R43,10                                             # compare whole seconds 16
6e5b: d3,03               jnc   6e60             if ((uns) R43 >= 10)  {           # jmp if timer < 4096 msec (~ 4 secs)
6e5d: 91,04,2a            orb   R2a,4            Vip_enable = 1; } }
6e60: 36,2a,14            jnb   B6,R2a,6e77      if (No_start = 0) goto 6e77;
6e63: 35,2b,05            jnb   B5,R2b,6e6b      if (Stiflg = 0) goto 6e6b;        # jump if EEC reset
6e66: 37,a1,0b            jnb   B7,Ra1,6e74      if (Cranking = 0) goto 6e74;      # jump if not CRANKING - EEC reset
6e69: 20,a7               sjmp  6f12             goto 6f12;                        # Enter KOEO (Engine off test)

########## STI low - EEC reset
6e6b: 3b,d6,03            jb    B3,Rd6,6e71      if (Sto_working = 1) goto 6e71;
6e6e: 32,2b,03            jnb   B2,R2b,6e74      if (Sto_trigger = 1)  {
6e71: ef,2c,09            call  77a0             clear_KAM(); }
6e74: e7,c9,15            jump  8440             goto 8440;                        # Reboot system
6e77: 35,2a,1e            jnb   B5,R2a,6e98      if (Self_test = 0) goto 6e98;     # normal strategy - not self test
6e7a: 35,2b,f7            jnb   B5,R2b,6e74      if (Stiflg = 0) goto 6e74;        # STI input is low - EEC reset
6e7d: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;                     # Transmission type
6e81: 99,03,42            cmpb  R42,3                                              # 3 = Manual Transmission, both clutch and gear switches.
6e84: d3,08               jnc   6e8e             if ((uns) R42 < 3) goto 6e8e;
6e86: 99,04,42            cmpb  R42,4                                              # 4 = Auto Transmission, non-electronic, neutral drive switch.
6e89: d9,03               jgtu  6e8e             if ((uns) R42 > 4 ) goto 6e8e;
6e8b: 3f,e7,e6            jb    B7,Re7,6e74      if (Ndsflg = 1) goto 6e74;
6e8e: 36,e6,05            jnb   B6,Re6,6e96      if (Pfehp_flg = 1)  {
6e91: ef,43,09            call  77d7             SrolavT(Fiept);                   # filter at 00CA[R78] use blend 116(EVP) to 380
6e94: 80,03               #args                  }
6e96: 20,6d               sjmp  6f05             goto 6f05;
6e98: 30,2a,1a            jnb   B0,R2a,6eb5      if (Vscdt = 0) goto 6eb5;
6e9b: 35,2b,12            jnb   B5,R2b,6eb0      if (Stiflg = 1)  {                # jump if STI input is low
6e9e: b3,73,3d,01,42      ldb   R42,[R72+13d]    R42 = Mph_FiltH;                  # Vehicle speed, MPH
6ea3: 99,04,42            cmpb  R42,4            
6ea6: d9,08               jgtu  6eb0             if ((uns) R42 <= 4)  {            # Vehicle speed > 4 MPH
6ea8: 37,a0,05            jnb   B7,Ra0,6eb0      if (On_state = 1)  {              # SCCS on (Cruise Control)
6eab: 3d,a0,02            jb    B5,Ra0,6eb0      if (Brake_state = 1) goto 6eb0;   # SCCS brake (cruise control)
6eae: 20,91               sjmp  6f41             goto 6f41; } } }                  # VSCDT? push proc D and execute it
6eb0: 91,20,2a            orb   R2a,20           Self_test = 1;                    # OK - running self tests
6eb3: 27,bf               sjmp  6e74             goto 6e74;                        # EEC reset
6eb5: 31,2a,08            jnb   B1,R2a,6ec0      if (Vscst = 0) goto 6ec0;         # jump if not VIP mode flag : VSCST
6eb8: 3d,2b,b9            jb    B5,R2b,6e74      if (Stiflg = 1) goto 6e74;        # jump if STI input is high to EEC reset
6ebb: 37,a1,b6            jnb   B7,Ra1,6e74      if (Cranking = 0) goto 6e74;      # jump if not CRANKING to EEC reset
6ebe: 20,7a               sjmp  6f3a             goto 6f3a;                        # VSCST? push proc C and execute it(STI low and engine off or starting)
6ec0: 3f,a1,49            jb    B7,Ra1,6f0c      if (Cranking = 1) goto 6f0c;      # jump if CRANKING
6ec3: 3a,a1,03            jb    B2,Ra1,6ec9      if (Undsp = 1) goto 6ec9;         # jump if underspeed/cranking 
6ec6: 3d,2b,02            jb    B5,R2b,6ecb      if (Stiflg = 1) goto 6ecb;        # jump if STI input is high
6ec9: 20,82               sjmp  6f4d             return;
6ecb: b3,72,48,42         ldb   R42,[R72+48]     R42 = Tsstil;                     # 1C8 timer - STI input line low timer (1/8sec)
6ecf: 99,08,42            cmpb  R42,8                                              # 1 second
6ed2: d3,79               jnc   6f4d             if ((uns) R42 < 8) return;        # jmp if STI low timer < 1 second
6ed4: 32,2a,76            jnb   B2,R2a,6f4d      if (Vip_enable = 0) return;       # jump if not VIP mode flag : VIP enable
6ed7: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = Putmr;                      # 134 - PUTMR - Counts up after h/w reset
6edb: 99,18,43            cmpb  R43,18                                             # compare whole seconds 1800 msec (1/1024) = 6 seconds
6ede: d3,6d               jnc   6f4d             if ((uns) R43 < 18) return;       # jmp if timer < 6 sec
6ee0: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = Vstype;
6ee4: 99,02,42            cmpb  R42,2            
6ee7: d7,16               jne   6eff             if (R42 = 2)  {
6ee9: 37,a0,13            jnb   B7,Ra0,6eff      if (On_state = 1)  {              # SCCS on (Cruise Control)
6eec: 3f,2a,10            jb    B7,R2a,6eff      if (Disable_vscdt = 0)  {         # jump if VIP mode flag : disable VSCDT set
6eef: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = Putmr;                      # 134 - PUTMR - Counts up after h/w reset
6ef3: 9b,79,f2,00,43      cmpb  R43,[R78+f2]                                       # compare whole seconds
6ef8: db,05               jc    6eff             if (R43 > Vvscet)  {              # jmp if timer >= VVSCET?
6efa: 91,09,2a            orb   R2a,9            Vscdt = 1;
                                                 Disable_running = 1;              # VIP mode flag : set VSCDT and DISABLE RUNNING
6efd: 20,42               sjmp  6f41             goto 6f41; } } } }                # jmp to BASE D procs
6eff: 3b,2a,48            jb    B3,R2a,6f4a      if (Disable_running = 0)  {       # jump if VIP mode flag : disable running set

# ENTER DYNAMIC TEST
6f02: 91,a0,2a            orb   R2a,a0           Self_test = 1;
                                                 Disable_vscdt = 1;                # Set VIP mode flag : disable no start and disable VSCDT
6f05: 28,47               scall 6f4e             Sub40();
6f07: cb,3b,7e,71         push  [R3a+717e]       push([R3a+717e]);                 # BASE A - computed jump
6f0b: f0                  ret                    return;

6f0c: 35,2b,0a            jnb   B5,R2b,6f19      if (Stiflg = 0) goto 6f19;        # jump if STI input is low
6f0f: 3c,2a,38            jb    B4,R2a,6f4a      if (Disable_nostart = 0)  {       # jump VIP mode flag : disable no start

# ENTER ENGINE OFF TEST?
6f12: 28,3a               scall 6f4e             Sub40();
6f14: cb,3b,68,71         push  [R3a+7168]       push([R3a+7168]);                 # BASE B - push self test function proc ?
6f18: f0                  ret                    return;                           # test code - KOEO self test and others?

6f19: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = Vstype;
6f1d: 99,02,42            cmpb  R42,2            
6f20: d7,2b               jne   6f4d             if (R42 != 2) return;             # return
6f22: 37,a0,28            jnb   B7,Ra0,6f4d      if (On_state = 0) return;         # if SCCS ON state - return (exit if cruise control is ON)
6f25: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = Putmr;                      # 134 - PUTMR - Counts up after h/w reset (msec)
6f29: 99,28,43            cmpb  R43,28                                             # compare msec - 2800 * 1/1024 = 10 seconds
6f2c: db,1f               jc    6f4d             if ((uns) R43 >= 28) return;      # if Eng Runnung Timer >= 10seconds then return
6f2e: a3,72,be,42         ldw   R42,[R72+be]     R42 = Tslpip;                     # 13E - timer? time since last PIP recieved (msec)
6f32: 99,04,43            cmpb  R43,4                                              # 400 msec(1/1024) seconds ~ 1 second
6f35: d1,16               jleu  6f4d             if ((uns) R43 <= 4) return;       # if time since PIP <= 1 sec then return
6f37: 91,02,2a            orb   R2a,2            Vscst = 1;                        # Set VIP mode flag : VSCST

##### ENGINE OFF VCS TEST?
6f3a: 28,12               scall 6f4e             Sub40();
6f3c: cb,3b,c8,71         push  [R3a+71c8]       push([R3a+71c8]);                 # BASE C - computed jump in 7000 area
6f40: f0                  ret                    return;                           # run the test routine

##### ENTER ENGINE RUNNING TEST

6f41: 28,0b               scall 6f4e             Sub40();
6f43: cb,3b,d6,71         push  [R3a+71d6]       push([R3a+71d6]);                 # BASE D - computed jump in 7000 area
6f47: f0                  ret                    return;                           # run the test routine

#### computed diagnostic calls return here



6f48: 21,2b               ??                                                       # Save diagnostic testing registers

6f4a: 91,08,2c            orb   R2c,8            Wigflg = 1;
6f4d: f0                  ret                    return;

######################################
# gets jump function index into R3A
#######################################


  Sub40:
6f4e: 29,00               scall 7050             Get_diag_vals();                  # load diagnostic testing registers
6f50: ac,38,3a            ldzbw R3a,R38          R3a = (uns)R38;                   # function address index
6f53: 09,01,3a            shlw  R3a,1            R3a *= 2;                         # X 2 - make into word index
6f56: cc,42               pop   R42              R42 = pop();                      # original return address
6f58: c9,48,6f            push  6f48             push(6f48);                       # push extra address (save diag vals)
6f5b: 88,00,40            cmpw  R40,R0                                             # Zero 1st time only, This is return address of call x7026
6f5e: df,02               je    6f62             if (R40 = 0) goto 6f62;           # jump if first time thru here
6f60: 20,da               sjmp  703c             goto 703c;                        # return to 1st or 3rd caller
6f62: c8,42               push  R42              push(R42);                        # restore return address
6f64: f0                  ret                    return;

# Diagnostic Proc Table A


  Sub41:
6f65: a1,10,55,d4         ldw   Rd4,5510         Vip_code = 5510;                  # Diagnostic Proc Table A proc no 2
6f69: 7b,fe,07,d4         sb2b  Rd4,[Rfe+7]      Vip_code -= PIPsC;
6f6d: 08,d4,d4            shrw  Rd4,Rd4          Vip_code >>= Vip_code;
6f70: 28,08               scall 6f7a             Sub44();
6f72: 20,6f               sjmp  6fe3             goto 6fe3;

  Sub42:
6f74: ad,02,d4            ldzbw Rd4,2            Vip_code = (uns)2;

  Sub43:
6f77: 91,02,d9            orb   Rd9,2            Goose = 1;

  Sub44:
6f7a: 91,04,d9            orb   Rd9,4            Onedigit_out = 1;
6f7d: 28,a7               scall 7026             Sub51();
6f7f: 71,fb,d9            an2b  Rd9,fb           Onedigit_out = 0;
6f82: f0                  ret                    return;

####################################################################
# Diagnostic proc Table A
# sensor error stack processing - dump out errors?
####################################################################


  Sub45:
6f83: b1,10,19            ldb   R19,10           R19 = 10;
6f86: 98,30,00            cmpb  R0,R30                                             # is error stack empty?
6f89: d7,04               jne   6f8f             if (0 = R30)  {
6f8b: ef,20,0c            call  7bae             SaveTCode1(11);
# E11 - System PASS
6f8e: 11                  #args                  }                                 # Trouble Code : System PASS (no errors)
6f8f: ef,1c,0c            call  7bae             SaveTCode1(0);                    # E 00 (end of errors? ) 
6f92: 00                  #args  
6f93: a1,42,03,30         ldw   R30,342          R30 = Serv_code_tab;              # Hard Trouble Code Error Table
6f97: ae,31,32            ldzbw R32,[R30++]      R32 = (uns)[R30++];               # load next trouble code byte into word R32
6f9a: 98,00,32            cmpb  R32,R0           
6f9d: df,08               je    6fa7             if (R32 = 0) goto 6fa7;           # zero is end of error codes?
6f9f: 28,45               scall 6fe6             Sub46();                          # call this for every error
6fa1: 89,55,03,30         cmpw  R30,355                                            # 342 + 13
6fa5: d3,f0               jnc   6f97             if ((uns) R30 < 355) goto 6f97;   # loop back small
# end of error codes stack
6fa7: 30,d6,15            jnb   B0,Rd6,6fbf      if (High_speed = 0) goto 6fbf;
6faa: 34,d9,05            jnb   B4,Rd9,6fb2      if (Kam_codes = 1)  {
6fad: b1,04,33            ldb   R33,4            R33 = 4;
6fb0: 21,06               sjmp  70b8             goto 70b8; }
6fb2: 28,67               scall 701b             Sub50();
6fb4: 71,fe,d6            an2b  Rd6,fe           High_speed = 0;
6fb7: 32,d6,24            jnb   B2,Rd6,6fde      if (Low_speed = 0) goto 6fde;
6fba: b1,08,19            ldb   R19,8            R19 = 8;
6fbd: 27,d4               sjmp  6f93             goto 6f93;                        # loop back big
6fbf: 32,d6,0e            jnb   B2,Rd6,6fd0      if (Low_speed = 0) goto 6fd0;
6fc2: 71,fb,d6            an2b  Rd6,fb           Low_speed = 0;
6fc5: 36,2a,03            jnb   B6,R2a,6fcb      if (No_start = 1)  {
6fc8: 91,10,d9            orb   Rd9,10           Kam_codes = 1; }
6fcb: 31,d6,10            jnb   B1,Rd6,6fde      if (Lowspeed_repeat = 0) goto 6fde;
6fce: 27,c3               sjmp  6f93             goto 6f93;                        # loop back big
6fd0: 31,d6,13            jnb   B1,Rd6,6fe6      if (Lowspeed_repeat = 0) goto 6fe6;
6fd3: 34,d9,08            jnb   B4,Rd9,6fde      if (Kam_codes = 1)  {
6fd6: 91,04,d6            orb   Rd6,4            Low_speed = 1;
6fd9: b1,0a,33            ldb   R33,a            R33 = a;
6fdc: 20,da               sjmp  70b8             goto 70b8; }
6fde: 71,fd,d6            an2b  Rd6,fd           Lowspeed_repeat = 0;
6fe1: 28,38               scall 701b             Sub50();
6fe3: e7,28,0f            jump  7f0e             goto 7f0e;

#######################################################
# ? DUMPS OUT HARD ERROR CODES?
# R32 byte has trouble code - called for every trouble code in 342 stack
#######################################################

  Sub46:
6fe6: 09,04,32            shlw  R32,4            R32 *= 10;                        # error code x 16 (left one hex digit)
6fe9: 17,33               incb  R33              R33++;
6feb: 20,04               sjmp  6ff1             goto 6ff1;
6fed: 28,20               scall 700f             Sub48();                          # execute this loop error code X 16 + 1? times
6fef: 28,21               scall 7012             Sub49();
6ff1: e0,33,f9            djnz  R33,6fed         R33--;
                                                 if (R33 != 0) goto 6fed;
6ff4: b1,03,33            ldb   R33,3            R33 = 3;
6ff7: 28,19               scall 7012             Sub49();
6ff9: e0,33,fb            djnz  R33,6ff7         R33--;
                                                 if (R33 != 0) goto 6ff7;
6ffc: 38,32,07            jb    B0,R32,7006      if (B0_R32 = 0)  {
6fff: 09,04,32            shlw  R32,4            R32 *= 10;                        # R32 << 4 (one hex digit)
7002: 17,32               incb  R32              R32++;
7004: 27,e3               sjmp  6fe9             goto 6fe9; }
7006: b1,04,33            ldb   R33,4            R33 = 4;

  Sub47:
7009: 28,07               scall 7012             Sub49();
700b: e0,33,fb            djnz  R33,7009         R33--;
                                                 if (R33 != 0) goto Sub47;
700e: f0                  ret                    return;
#######################################################
# entry point 1
# shift D4 right 16 times or until R19 == 0
#######################################################


  Sub48:
700f: 91,80,d5            orb   Rd5,80           Rd5 |= 80;

  Sub49:
7012: e0,19,02            djnz  R19,7017         R19--;
                                                 if (R19 != 0) goto 7017;
7015: 20,0f               sjmp  7026             goto Sub51;
7017: 08,01,d4            shrw  Rd4,1            Vip_code /= 2;
701a: f0                  ret                    return;

#######################################################


  Sub50:
701b: 3c,19,07            jb    B4,R19,7025      if (B4_R19 = 1) return;
701e: 15,19               decb  R19              R19--;
7020: 08,19,d4            shrw  Rd4,R19          Vip_code >>= R19;
7023: 28,01               scall 7026             Sub51(); }
7025: f0                  ret                    return;

#######################################################
# this proc can shortcut returns from stack - to grandcaller
#######################################################


  Sub51:
7026: cc,40               pop   R40              R40 = pop();                      # get & save caller
7028: cc,14               pop   R14              R14 = pop();                      # get & save grandcaller
702a: 71,ef,d6            an2b  Rd6,ef           Sto_fast = 0;                     # STO fast codes
702d: 30,d6,03            jnb   B0,Rd6,7033      if (High_speed = 1)  {            # jump if STO high speed
7030: 91,10,d6            orb   Rd6,10           Sto_fast = 1; }
7033: b1,10,19            ldb   R19,10           R19 = 10;
7036: 91,20,d6            orb   Rd6,20           Sto_code = 1;
7039: 91,04,2b            orb   R2b,4            Sto_trigger = 1;                  # Self Test Output trigger
703c: 3a,2b,10            jb    B2,R2b,704f      if (Sto_trigger = 1) return;
703f: 32,d9,03            jnb   B2,Rd9,7045      if (Onedigit_out = 1)  {
7042: 3b,d6,0a            jb    B3,Rd6,704f      if (Sto_working = 1) return; }    # return to grandcaller 
 # return to grandcaller 
7045: c8,14               push  R14              push(R14);                        # restore grandcaller
7047: c8,40               push  R40              push(R40);                        # restore caller
7049: 01,40               clrw  R40              R40 = 0;
704b: 28,28               scall 7075             Save_diag_vals();                 # Save diagnostic testing registers
704d: 01,d4               clrw  Rd4              Vip_code = 0; }
704f: f0                  ret                    return;

######################################################
# save and restore test values for self test
######################################################


  Get_diag_vals:
7050: a3,72,50,30         ldw   R30,[R72+50]     R30 = Code_cnt_ex;
7054: a3,72,5a,32         ldw   R32,[R72+5a]     R32 = Code_ones_ex;
7058: a3,72,62,34         ldw   R34,[R72+62]     R34 = Vip_nrm_ex;
705c: a3,72,64,36         ldw   R36,[R72+64]     R36 = Vip_nrm2_EX;
7060: b3,72,57,38         ldb   R38,[R72+57]     R38 = Vip_cnt_ex;
7064: a3,72,52,40         ldw   R40,[R72+52]     R40 = Vip_stack_ex;
7068: a3,72,54,14         ldw   R14,[R72+54]     R14 = Vip_stack_x2;
706c: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = Vip_timer_ex;
7070: b3,72,66,19         ldb   R19,[R72+66]     R19 = Shift_cnt_ex;
7074: f0                  ret                    return;


  Save_diag_vals:
7075: c3,72,50,30         stw   R30,[R72+50]     Code_cnt_ex = R30;
7079: c3,72,5a,32         stw   R32,[R72+5a]     Code_ones_ex = R32;
707d: c3,72,62,34         stw   R34,[R72+62]     Vip_nrm_ex = R34;
7081: c3,72,64,36         stw   R36,[R72+64]     Vip_nrm2_EX = R36;
7085: c7,72,57,38         stb   R38,[R72+57]     Vip_cnt_ex = R38;
7089: c3,72,52,40         stw   R40,[R72+52]     Vip_stack_ex = R40;
708d: c3,72,54,14         stw   R14,[R72+54]     Vip_stack_x2 = R14;
7091: c7,72,66,19         stb   R19,[R72+66]     Shift_cnt_ex = R19;
7095: f0                  ret                    return;

##########################################################


  Set_EGRFlags:
7096: 45,80,00,f2,78      ad3w  R78,Rf2,80       Cp = Ectmax;                      # points to 0x8EDA
709b: a1,80,01,72         ldw   R72,180          Rp = Injdly;                      # why does this REG need resetting
709f: b3,fa,31,42         ldb   R42,[Rfa+31]     R42 = Egr_type;                   # 0=sonic, 1=PFE, 2=none
70a3: 71,bf,d9            an2b  Rd9,bf           Vegrbp = 0;
70a6: 99,02,42            cmpb  R42,2            
70a9: d7,03               jne   70ae             if (R42 = 2)  {                   # branch ALWAYS in this ROM
70ab: 91,40,d9            orb   Rd9,40           Vegrbp = 1; }
70ae: 71,bf,e6            an2b  Re6,bf           Pfehp_flg = 0;
70b1: e0,42,03            djnz  R42,70b7         R42--;
                                                 if (R42 != 0) return;
70b4: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # - never happens in this ROM
70b7: f0                  ret                    return;
##########################################################

70b8: 2f,4f               scall 7009             Sub47();
70ba: ad,10,32            ldzbw R32,10           R32 = (uns)10;
70bd: 2f,27               scall 6fe6             Sub46();                          # process? a trouble code?
70bf: 28,5c               scall 711d             Sub52();                          # set R30 to end of trouble code stack
70c1: 30,d6,3f            jnb   B0,Rd6,7103      if (High_speed = 1)  {            # Low Speed Repeat
70c4: ad,15,32            ldzbw R32,15           R32 = (uns)15;
70c7: c2,30,32            stw   R32,[R30]        [R30] = R32;                      # R30 = # 356 WORD
70ca: 3e,d8,36            jb    B6,Rd8,7103      if (Vip_kam = 0)  {
70cd: ad,11,32            ldzbw R32,11           R32 = (uns)11;
70d0: c2,30,32            stw   R32,[R30]        [R30] = R32;                      # save start code?
70d3: 01,1a               clrw  R1a              R1a = 0;
70d5: a1,c4,07,1c         ldw   R1c,7c4          R1c = Kam_indexl;                 # KAMINDEXLow
70d9: b1,08,1e            ldb   R1e,8            R1e = 8;
70dc: b2,1d,34            ldb   R34,[R1c++]      R34 = [R1c++];                    # take next value from 7C4 Table
70df: 07,1a               incw  R1a              R1a++;
70e1: 89,25,00,1a         cmpw  R1a,25                                             # loop for 25 entries (37)
70e5: d9,18               jgtu  70ff             if ((uns) R1a > 25 ) goto 70ff;
70e7: 19,01,34            shlb  R34,1            R34 *= 2;
70ea: d3,0e               jnc   70fa             if ((uns) R34 >= 0)  {            # was bit bit set?
70ec: 57,1b,42,71,00,1f   ad3b  R1f,R0,[R1a+7142] R1f = [R1a+7142];                # Table (index starts at 1 not zero)
70f2: df,06               je    70fa             if (R1f != 0)  {                  # skip zeros 
70f4: c6,31,1f            stb   R1f,[R30++]      [R30++] = R1f;                    # write to 356+

#############################################################
# Restore the registers used
# Save the registers used for testing
# If ROM 97D9(EGR Type) = 1 then set bit 6 in RE6 else clear the bit
# If ROM 97D9(EGR Type) = 2 then set bit 6 in RD9 else clear the bit
# Save diagnostic testing registers
# Set up EGR flags
# Since ROM does not change this proc ALWAYS clr both bit 6 flags
# Things like continious tests require preserving registers
# change flag bit 6 in RD9 and RE6 based on ROM 97D9(EGR Type) = egr type ( 0=sonic, 1=PFE, 2=none)
# load diagnostic testing registers
# resets R72 = 180 and sets R78 = 8EDA
#############################################################
70f7: c6,30,00            stb   R0,[R30]         [R30] = 0; } }                    # mark as end in case of exit?
70fa: e0,1e,e2            djnz  R1e,70df         R1e--;
                                                 if (R1e != 0) goto 70df;          # loop
70fd: 27,da               sjmp  70d9             goto 70d9;                        # loop
70ff: 28,1c               scall 711d             Sub52();                          # set ptr to code table
7101: 28,1f               scall 7122             Sub53(); } }                      # Bubble sort Table
7103: 56,31,00,32         ad3b  R32,R0,[R30++]   R32 = [R30++];
7107: df,04               je    710d             if (R32 != 0)  {
7109: 2e,db               scall 6fe6             Sub46();
710b: 27,f6               sjmp  7103             goto 7103; }
710d: 38,d6,08            jb    B0,Rd6,7118      if (High_speed = 0)  {
7110: 32,d6,05            jnb   B2,Rd6,7118      if (Low_speed = 1)  {
7113: 71,fb,d6            an2b  Rd6,fb           Low_speed = 0;
7116: 27,a7               sjmp  70bf             goto 70bf; } }
7118: 71,ef,d9            an2b  Rd9,ef           Kam_codes = 0;
711b: 26,95               sjmp  6fb2             goto 6fb2;

  Sub52:
711d: a1,56,03,30         ldw   R30,356          R30 = Cntn_code_tab;              # R30 = end of trouble code stack
7121: f0                  ret                    return;
# bubble sort


  Sub53:
7122: 56,31,00,1c         ad3b  R1c,R0,[R30++]   R1c = [R30++];                    # load ptr to ?
7126: df,f5               je    711d             if (R1c = 0) goto Sub52;          # exit and restore ptr
7128: a0,30,1a            ldw   R1a,R30          R1a = R30;
712b: 56,1b,00,1d         ad3b  R1d,R0,[R1a++]   R1d = [R1a++];
712f: df,f1               je    7122             if (R1d = 0) goto Sub53;
7131: 98,1c,1d            cmpb  R1d,R1c          
7134: db,f5               jc    712b             if ((uns) R1d >= R1c) goto 712b;
7136: c7,1a,ff,1c         stb   R1c,[R1a+ff]     [R1a-1] = R1c;
713a: b0,1d,1c            ldb   R1c,R1d          R1c = R1d;
713d: c7,30,ff,1c         stb   R1c,[R30+ff]     [R30-1] = R1c;
7141: 27,e8               sjmp  712b             goto 712b;

#############################################################
# Diagnostic, Trouble Codes ?  called as [7142+Reg] from 70ec
# so table must start at 1. 
##############################################################


7143: 51,54,61,64,53,00,63,87 ?? 
714b: 00,14,18,00,22,91,41,00 ?? 
7153: 31,32,33,34,35,00,00,00 ?? 
715b: 29,00,00,00,00,ff,ff,ff ?? 
7163: 95,96,56,66,67      ??    

#############################################################
# Self Test subroutine list KOEO.  ( From 6f14+x)
##############################################################

7168: 0d,78               vect  780d,            Do_KOEO
716a: 8c,80               vect  808c,            Sub102                            # Proc uses next word as a PARAM
716c: 08,00               word  8,               INT_Mask                          # PARAM - interrupt mask address
716e: 70,78               vect  7870,            Test1                             # ECT. BP, MAF sensor range tests
7170: d2,78               vect  78d2,            Test2                             # ACT, EGR, NPS, A/C on,PwrSteering,VCAL, TP sensor tests
7172: e4,79               vect  79e4,            Sub70                             # force LSO and HSO outputs off set STO on jmp to (R34)
7174: ad,79               vect  79ad,            Sub68                             # Thermactor Air System test
7176: ce,79               vect  79ce,            Sub69                             # Fuel Pump Secondary circuit test
7178: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
717a: 01,7b               vect  7b01,            Sub75                             # incr R38 and set LSO and BiDI outputs?
717c: 1b,7b               vect  7b1b,            Sub76                             # proc with odd h/w xor

######## Self Test list 2 (from 6f07)################

717e: e0,7b               vect  7be0,            Sub77
7180: 65,6f               vect  6f65,            Sub41                             # clr STO, Hard Fault, ACT, ECT, TP, TPS ?
7182: 84,7c               vect  7c84,            Sub78                             # high RPM test (If Engine Running)
7184: a3,7c               vect  7ca3,            Sub79
7186: c9,7c               vect  7cc9,            Sub80
7188: e5,7c               vect  7ce5,            Sub81
718a: 11,7d               vect  7d11,            Sub82
718c: 4a,7d               vect  7d4a,            Sub83
718e: 68,7d               vect  7d68,            Sub84
7190: 91,7d               vect  7d91,            Sub85
7192: aa,7d               vect  7daa,            Sub86
7194: 85,80               vect  8085,            Sub101
7196: 5a,90               word  905a,            Dnppm                             # PARAM  - for proc 8085
7198: 4c,7e               vect  7e4c,            Sub89
719a: 8f,7e               vect  7e8f,            Sub90
719c: 15,7f               vect  7f15,            Sub91
719e: 24,7f               vect  7f24,            Sub92
71a0: 37,7f               vect  7f37,            Sub93
71a2: 55,7f               vect  7f55,            Sub94
71a4: 62,7f               vect  7f62,            Sub95
71a6: 7f,7f               vect  7f7f,            Sub96
71a8: b1,7f               vect  7fb1,            Sub97
71aa: c8,7f               vect  7fc8,            Sub98
71ac: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71ae: a6,80               vect  80a6,            Sub103
71b0: c4,80               vect  80c4,            Sub104
71b2: f2,80               vect  80f2,            Sub105
71b4: fe,80               vect  80fe,            Sub106
71b6: 21,81               vect  8121,            Sub107
71b8: 2d,81               vect  812d,            Sub108
71ba: 77,81               vect  8177,            Sub109
71bc: 8a,81               vect  818a,            Sub110
71be: ba,81               vect  81ba,            Sub111
71c0: 34,84               vect  8434,            Sub119                            # in all three Tables at end
71c2: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71c4: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71c6: 34,84               vect  8434,            Sub119                            # in all three Tables at end

######## Self Test list 3 (from 6f3c)################
71c8: 92,72               vect  7292,            Sub58                             # STO off and output to low, zero VIP timer, incr R38 test index
71ca: f4,71               vect  71f4,            Sub54                             # tweak flags
71cc: ff,71               vect  71ff,            Sub56                             # SCCS something
71ce: 73,72               vect  7273,            Sub57
71d0: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71d2: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71d4: 34,84               vect  8434,            Sub119                            # in all three Tables at end

######## Self Test list 4 (from 6f43)################

71d6: 92,72               vect  7292,            Sub58                             # STO off and output to low, zero VIP timer, incr R38 test index
71d8: fa,71               vect  71fa,            Sub55
71da: 7e,80               vect  807e,            Sub100
71dc: 69,91               word  9169,                                              # PARAM - for proc 807e
71de: a6,72               vect  72a6,            Sub59
71e0: cc,72               vect  72cc,            Sub60
71e2: 7e,80               vect  807e,            Sub100
71e4: 6a,91               word  916a,                                              # PARAM - for proc 807e
71e6: d6,72               vect  72d6,            Sub61
71e8: dc,72               vect  72dc,            Sub62
71ea: 00,73               vect  7300,            Sub63
71ec: 04,73               vect  7304,            Sub64                             # HEGO - A/F ratio test?
71ee: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71f0: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71f2: 34,84               vect  8434,            Sub119                            # in all three Tables at end

########## End of self test lists ####################


  Sub54:
71f4: 91,fb,d7            orb   Rd7,fb           Code_75 = 1;
                                                 Code_74 = 1;
                                                 Code_45_92 = 1;
                                                 Code_77_91 = 1;
                                                 Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
71f7: 91,04,d7            orb   Rd7,4            Code_67_94 = 1;                   # set code flags for clearing later

  Sub55:
71fa: ef,77,fd            call  6f74             Sub42();
71fd: 20,98               sjmp  7297             goto 7297;

  Sub56:
71ff: 37,b5,03            jnb   B7,Rb5,7205      if (SCCS_Off = 1)  {
7202: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0; }
7205: 35,b5,03            jnb   B5,Rb5,720b      if (SCCS_Coast = 1)  {
7208: 71,bf,d7            an2b  Rd7,bf           Code_42_72 = 0; }
720b: 34,b5,03            jnb   B4,Rb5,7211      if (SCCS_Accel = 1)  {
720e: 71,df,d7            an2b  Rd7,df           Code_44_73 = 0; }
7211: 33,b5,03            jnb   B3,Rb5,7217      if (SCCS_Resume = 1)  {
7214: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; }
7217: 91,08,d7            orb   Rd7,8            Code_45_92 = 1;
721a: 98,b5,00            cmpb  R0,Rb5           
721d: d7,03               jne   7222             if (0 = Vsc_flagsb)  {            # no SCCS buttons/mode
721f: 71,f7,d7            an2b  Rd7,f7           Code_45_92 = 0; }
7222: 31,ea,05            jnb   B1,Rea,722a      if (Biflg = 1)  {
7225: 71,fd,d7            an2b  Rd7,fd           Code_74 = 0;                      # Brake is on.
7228: 20,03               sjmp  722d             goto 722d; }
722a: 71,fe,d7            an2b  Rd7,fe           Code_75 = 0;
722d: 3f,e7,03            jb    B7,Re7,7233      if (Ndsflg = 0)  {
7230: 71,fb,d7            an2b  Rd7,fb           Code_67_94 = 0; }
7233: 51,fb,d7,42         an3b  R42,Rd7,fb       R42 = Tc_flags & fb;
7237: d7,03               jne   723c             if (R42 != 0) goto 723c;
7239: 32,d7,20            jnb   B2,Rd7,725c      if (Code_67_94 = 1)  {
723c: ef,fc,0b            call  7e3b             GetWord(Vipt1);
723f: 66,91               #args  
7241: 3b,d7,15            jb    B3,Rd7,7259      if (Code_45_92 = 1) goto 7259;
7244: 51,f0,d7,42         an3b  R42,Rd7,f0       R42 = Tc_flags & f0;
7248: df,12               je    725c             if (R42 != 0)  {
724a: 99,f0,42            cmpb  R42,f0           
724d: d7,05               jne   7254             if (R42 = f0)  {
724f: 28,52               scall 72a3             SaveTCode2(49);                   # E49 SPOUT signal defaulted or 1-2 shift error E40D
7251: 49                  #args  
7252: 20,08               sjmp  725c             goto 725c; }
7254: 28,4d               scall 72a3             SaveTCode2(Flags_47);             # E47 air flow low at base idle
7256: 47                  #args  
7257: 20,03               sjmp  725c             goto 725c;
7259: 28,48               scall 72a3             SaveTCode2(48);                   # E48 air flow high at base idle
725b: 48                  #args                  } }
725c: ef,e5,06            call  7944             Sub67();
725f: 32,d7,03            jnb   B2,Rd7,7265      if (Code_67_94 = 1)  {
7262: 28,3f               scall 72a3             SaveTCode2(67);                   # E67 A/C input high
7264: 67                  #args                  }
7265: 31,d7,03            jnb   B1,Rd7,726b      if (Code_74 = 1)  {
7268: 28,39               scall 72a3             SaveTCode2(Rp2);                  # E74 Brake circuit fail - not actuated
726a: 74                  #args                  }
726b: 30,d7,03            jnb   B0,Rd7,7271      if (Code_75 = 1)  {
726e: 28,33               scall 72a3             SaveTCode2(75);                   # E75 Brake circuit fail - always high
7270: 75                  #args                  }
7271: 20,24               sjmp  7297             goto 7297;

  Sub57:
7273: ef,79,08            call  7aef             Sub74();
7276: c9,7f,72            push  727f             push(727f);
7279: 28,12               scall 728d             OCC_chk1(681,4610);               # SCCS Open Circuit Check, pars = E81,limit,bit mask(=SCCS),IO
727b: 81,06,10,46         #args  
727f: 28,a4               scall 7325             Sub66();
7281: 91,10,46            orb   R46,10           Scvnt = 1;                        # LSO output line 4 ON (Speed Control Vent)
7284: c9,97,72            push  7297             push(7297);                       # return from 7A76 to this address
7287: 28,06               scall 728f             OCC_chk2(482,4601);               # DOL Open Circuit Check, E82,limit,bit mask(=DOL),IO
7289: 82,04,01,46         #args  

  OCC_chk1:
728d: 28,8a               scall 7319             Sub65();                          # SCCS controls off & stuff?

  OCC_chk2:
728f: e7,e4,07            jump  7a76             goto Test_IO;                     # Open Circuit Check function

############################################################
# STO off and output to low, zero VIP timer, incr R38 test index
# jump Table entry 71C8
############################################################

  Sub58:
7292: 01,30               clrw  R30              R30 = 0;
7294: ef,1d,05            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7297: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;                 # zero 1CA timer? VIP TIMER EX?
729b: 17,38               incb  R38              R38++;                            # incr test index
729d: f0                  ret                    return;

729e: ef,0b,05            call  77ac             Set_STO();                        # tweak flags, set STO on and return
72a1: 27,f4               sjmp  7297             goto 7297;                        # 91 - Air/Fuel mixture not within Self test range (HEGO switching error)

  SaveTCode2:
72a3: e7,08,09            jump  7bae             goto SaveTCode1;                  # JUMP TO (use caller data) E 91 -> err stack

  Sub59:
72a6: 91,20,d9            orb   Rd9,20           Vvsfl1 = 1;                       # From Diagnostic Proc Table D
72a9: a3,79,e2,00,42      ldw   R42,[R78+e2]     R42 = Vrss;
72ae: c3,73,2e,01,42      stw   R42,[R72+12e]    Res_speed = R42;
72b3: 6b,79,e0,00,42      sb2w  R42,[R78+e0]     R42 -= Vrsh;
72b8: 8b,73,2c,01,42      cmpw  R42,[R72+12c]    
72bd: d1,dc               jleu  729b             if ((uns) R42 <= Mph_FiltA) goto 729b;
72bf: ef,79,0b            call  7e3b             GetWord(Vipt2);
72c2: 67,91               #args  
72c4: 2f,dd               scall 72a3             SaveTCode2(36);
72c6: 36                  #args  
72c7: b1,0c,38            ldb   R38,c            R38 = c;
72ca: 20,4d               sjmp  7319             goto Sub65;

  Sub60:
72cc: b1,80,a0            ldb   Ra0,80           Vsc_states = 80;                  # From Diagnostic Proc Table D
72cf: 28,48               scall 7319             Sub65();                          # From Diagnostic Proc Table D
72d1: 91,10,46            orb   R46,10           Scvnt = 1;                        # LSO output line 4 ON (Speed Control Vent)
72d4: 27,c1               sjmp  7297             goto 7297;

  Sub61:
72d6: c3,72,70,aa         stw   Raa,[R72+70]     Tpsav = TP;                       # From Diagnostic Proc Table D
72da: 27,bb               sjmp  7297             goto 7297;

  Sub62:
72dc: 4b,72,70,aa,42      sb3w  R42,Raa,[R72+70] R42 = TP - Tpsav;
72e1: 8b,79,ee,00,42      cmpw  R42,[R78+ee]     
72e6: da,05               jle   72ed             if ((uns) R42 < Vtplu)  {
72e8: 2f,b9               scall 72a3             SaveTCode2(Flags_28);
72ea: 28                  #args  
72eb: 27,da               sjmp  72c7             goto 72c7; }
72ed: 03,42               negw  R42              R42 = -R42;
72ef: 8b,79,ec,00,42      cmpw  R42,[R78+ec]     
72f4: da,05               jle   72fb             if ((uns) R42 < Vtpld)  {
72f6: 2f,ab               scall 72a3             SaveTCode2(Flags_27);
72f8: 27                  #args  
72f9: 27,cc               sjmp  72c7             goto 72c7; }
72fb: ef,3d,0b            call  7e3b             GetWord(Vipt3);
72fe: 68,91               #args  

  Sub63:
7300: 28,17               scall 7319             Sub65();
7302: 27,93               sjmp  7297             goto 7297;

# Diagnostic Proc Table D

  Sub64:
7304: a3,fa,62,42         ldw   R42,[Rfa+62]     R42 = [980a];
7308: 8b,73,2c,01,42      cmpw  R42,[R72+12c]    
730d: d9,08               jgtu  7317             if ((uns) R42 <= Mph_FiltA)  {
730f: ef,29,0b            call  7e3b             GetWord(980c);
7312: 64,d0               #args  
7314: 2f,8d               scall 72a3             SaveTCode2(37);
7316: 37                  #args                  }
7317: 17,38               incb  R38              R38++;                            # incr test index

# Diagnostic Proc Table D

  Sub65:
7319: 71,df,d9            an2b  Rd9,df           Vvsfl1 = 0;                       # clr RD9 bit 5 VVS flag1?
731c: 28,07               scall 7325             Sub66();
731e: 71,ef,46            an2b  R46,ef           Scvnt = 0;                        # LSO output line 4 OFF (Speed Control Vent)
7321: 71,fe,46            an2b  R46,fe           Scvac = 0;                        # LSO output line 0 OFF (Speed Control Vacuum)
7324: f0                  ret                    return;


  Sub66:
7325: b1,ff,42            ldb   R42,ff           R42 = ff;
7328: c7,73,1b,ff,42      stb   R42,[R72+ff1b]   Vsc_count = R42;                  # SCCS Count? R9B = R42 why such a strange instruction?
732d: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset ?
#################################################################


  Chk_Sensors:
732e: 2d,66               scall 7096             Set_EGRFlags();
7330: ef,aa,10            call  83dd             Sub116();
7333: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7336: 38,2a,03            jb    B0,R2a,733c      if (Vscdt = 0)  {
7339: 71,df,d9            an2b  Rd9,df           Vvsfl1 = 0; }
733c: 3a,2a,01            jb    B2,R2a,7340      if (Vip_enable = 0)  {
733f: f0                  ret                    return; }

7340: 30,2a,01            jnb   B0,R2a,7344      if (Vscdt = 1)  {
7343: f0                  ret                    return; }

7344: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
7347: b3,78,f3,42         ldb   R42,[R78+f3]     R42 = V_fpmflg;
734b: e0,42,13            djnz  R42,7361         R42--;
                                                 if (R42 != 0) goto 7361;
734e: 37,46,18            jnb   B7,R46,7369      if (Pump = 1)  {
7351: 3a,a1,03            jb    B2,Ra1,7357      if (Undsp = 0)  {
7354: 91,80,d9            orb   Rd9,80           Rmspru = 1; }
7357: c7,72,46,00         stb   R0,[R72+46]      Vip_fpmtmr = 0;
735b: 3c,df,03            jb    B4,Rdf,7361      if (Fpm = 0)  {
735e: 91,08,2b            orb   R2b,8            Error_detected = 1; }
7361: ef,7c,03            call  76e0             updTCodes(4004,14);
7364: 04,40,14            #args  
7367: 20,2b               sjmp  7394             goto 7394; }
7369: 37,d9,18            jnb   B7,Rd9,7384      if (Rmspru = 1)  {
736c: 71,7f,d9            an2b  Rd9,7f           Rmspru = 0;
736f: ef,de,fc            call  7050             Get_diag_vals();                  # load diagnostic testing registers
7372: ef,7a,07            call  7aef             Sub74();                          # call set HSO Time Hold = Master IO Timer Lo + # 0003
7375: c9,7f,73            push  737f             push(737f);                       # return to this address
7378: ef,fb,06            call  7a76             Test_IO(INT_Mask,4680);           # E8 Fuel Pump Open Circuit Check
737b: 08,00,80,46         #args  
737f: 90,1a,2b            orb   R2b,R1a          Flags_2B |= R1a;
7382: 20,16               sjmp  739a             goto 739a; }
7384: b3,72,46,42         ldb   R42,[R72+46]     R42 = Vip_fpmtmr;
7388: 9b,78,f5,42         cmpb  R42,[R78+f5]     
738c: d3,06               jnc   7394             if ((uns) R42 >= V_fpmtm)  {
738e: 34,df,03            jnb   B4,Rdf,7394      if (Fpm = 1)  {
7391: 91,08,2b            orb   R2b,8            Error_detected = 1; } }
7394: ef,49,03            call  76e0             updTCodes(8004,13);
7397: 04,80,13            #args  
739a: ef,43,03            call  76e0             updTCodes(TP_Filt,11);
739d: 00,01,11            #args  
73a0: 3b,2c,04            jb    B3,R2c,73a7      if (Wigflg = 0)  {
73a3: 37,a1,01            jnb   B7,Ra1,73a7      if (Cranking = 1)  {              # exit if CRANKING
73a6: f0                  ret                    return; } }

73a7: 71,7f,d8            an2b  Rd8,7f           Threshold_lvl = 0;
73aa: ef,b7,05            call  7964             Compare(Ectmin,ECT_Raw);          # ECT raw from AD conversion
73ad: 7e,90,12,01         #args  
73b1: ef,2c,03            call  76e0             updTCodes(2018,HSI_Data);         # trouble code bit 2 - ECT open circuit trouble code
73b4: 18,20,0d            #args  
73b7: ef,aa,05            call  7964             Compare(ECT_Raw,Ectmax);
73ba: 12,01,80,90         #args  
73be: ef,1f,03            call  76e0             updTCodes(8020,INT_Pend);
73c1: 20,80,09            #args  
73c4: ef,9d,05            call  7964             Compare(Actmin,ACT_Raw);
73c7: 68,90,14,01         #args  
73cb: 2b,13               scall 76e0             updTCodes(1008,HSI_Time_Hi);
73cd: 08,10,0f            #args  
73d0: ef,91,05            call  7964             Compare(ACT_Raw,Actmax);
73d3: 14,01,6a,90         #args  
73d7: 2b,07               scall 76e0             updTCodes(4010,HSI_Sample);
73d9: 10,40,0b            #args  
73dc: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
73e0: df,21               je    7403             if (0 != [947b])  {
73e2: b3,72,b6,42         ldb   R42,[R72+b6]     R42 = Baptmr;
73e6: 9b,79,96,00,42      cmpb  R42,[R78+96]     
73eb: d1,05               jleu  73f2             if ((uns) R42 > Vbpmax )  {
73ed: 91,08,2b            orb   R2b,8            Error_detected = 1;
73f0: 20,11               sjmp  7403             goto 7403; }
73f2: ef,6f,05            call  7964             Compare(BAP_Intvl,Vbpdl2);
73f5: 0a,01,04,91         #args  
73f9: 3b,2b,07            jb    B3,R2b,7403      if (Error_detected = 0)  {
73fc: ef,65,05            call  7964             Compare(Vbpdl1,BAP_Intvl);
73ff: 02,91,0a,01         #args                  } }
7403: 2a,db               scall 76e0             updTCodes(859,1);
7405: 59,08,01            #args  
7408: 8b,79,92,00,ae      cmpw  Rae,[R78+92]     
740d: db,07               jc    7416             if (Rpmx4 > Vmarpm)  {
740f: ef,52,05            call  7964             Compare(MAF_Raw,Maxmaf);
7412: 24,01,0e,91         #args                  }
7416: 2a,c8               scall 76e0             updTCodes(2054,HSI_Mask);
7418: 54,20,0c            #args  
741b: 3a,a1,12            jb    B2,Ra1,7430      if (Undsp = 0)  {
741e: a3,72,be,42         ldw   R42,[R72+be]     R42 = Tslpip;
7422: 8b,79,86,00,42      cmpw  R42,[R78+86]     
7427: d9,07               jgtu  7430             if ((uns) R42 <= Vmafpiplmt)  {
7429: ef,38,05            call  7964             Compare(Vmamin,MAF_Raw);
742c: 10,91,24,01         #args                  } }
7430: 2a,ae               scall 76e0             updTCodes(104c,STACK);
7432: 4c,10,10            #args  
7435: ef,2c,05            call  7964             Compare(Tapmin,TPS_Raw);
7438: 70,90,22,01         #args  
743c: 2a,a2               scall 76e0             updTCodes(Pipacl,HSI_Time);
743e: 38,02,0e            #args  
7441: ef,20,05            call  7964             Compare(TPS_Raw,Tapmax);
7444: 22,01,6e,90         #args  
7448: 2a,96               scall 76e0             updTCodes(840,IO_Status);
744a: 40,08,0a            #args  
744d: 33,2c,02            jnb   B3,R2c,7452      if (Wigflg = 0) goto 7452;
7450: 20,90               sjmp  74e2             goto 74e2;
7452: b3,78,24,22         ldb   R22,[R78+24]     R22 = Vegobp;
7456: e0,22,39            djnz  R22,7492         R22--;
                                                 if (R22 != 0) goto 7492;
7459: b3,72,56,20         ldb   R20,[R72+56]     R20 = Ptcnt;                      # test selector is 1D7 vs 1D6 BYTE here
745d: 98,00,d0            cmpb  Rd0,R0           
7460: d7,03               jne   7465             if (Apt = 0)  {
7462: 91,80,e6            orb   Re6,80           B7_Flags_e6 = 1; }
7465: 37,d0,11            jnb   B7,Rd0,7479      if (Cl_thrtl = 1)  {
7468: 37,e6,0e            jnb   B7,Re6,7479      if (B7_Flags_e6 = 1)  {
746b: 71,7f,e6            an2b  Re6,7f           B7_Flags_e6 = 0;
746e: 17,20               incb  R20              R20++;                            # increment test routine selector (R38)
7470: d3,03               jnc   7475             if ((uns) R20 >= 0)  {
7472: b1,ff,20            ldb   R20,ff           R20 = ff; }                       # max test is 00FF
7475: c7,72,56,20         stb   R20,[R72+56]     Ptcnt = R20; } }                  # test selector is 1D7 not the 1D6 here
7479: 9b,f3,a6,00,c9      cmpb  Rc9,[Rf2+a6]                                       # - RC9 is some kind of timer
747e: d9,02               jgtu  7482             if ((uns) Atmr2 > Vegotm ) goto 7482;
7480: 20,10               sjmp  7492             goto 7492;
7482: b3,fe,0b,32         ldb   R32,[Rfe+b]      R32 = Thrmhp;
7486: e0,32,03            djnz  R32,748c         R32--;
                                                 if (R32 != 0) goto 748c;
7489: 3c,47,06            jb    B4,R47,7492      if (Iac = 1) goto 7492;           # if  Air management2 ON
748c: 51,b8,c5,32         an3b  R32,Rc5,b8       R32 = Fmem_flags & b8;
7490: df,0f               je    74a1             if (R32 = 0) goto 74a1;
7492: c7,72,56,00         stb   R0,[R72+56]      Ptcnt = 0;                        # test selector is 1D7 - reset to zero
7496: 98,22,00            cmpb  R0,R22           
7499: df,04               je    749f             if (0 = R22) goto 749f;
749b: 20,1c               sjmp  74b9             goto 74b9;


749d: 20,02               ??                                                       # Never gets here ?

749f: 20,41               sjmp  74e2             goto 74e2;
74a1: 9b,f3,a7,00,20      cmpb  R20,[Rf2+a7]     
74a6: d9,02               jgtu  74aa             if ((uns) R20 > Vptcnt ) goto 74aa;
74a8: 20,38               sjmp  74e2             goto 74e2;
74aa: b3,73,25,01,30      ldb   R30,[R72+125]    R30 = Egoss1;
74af: 9b,f3,a5,00,30      cmpb  R30,[Rf2+a5]     
74b4: db,03               jc    74b9             if (R30 > Vegosw)  {
74b6: 91,08,2b            orb   R2b,8            Error_detected = 1; }
74b9: 2a,25               scall 76e0             updTCodes(Mult_bp212A,INT_Mask);
74bb: 01,02,08            #args  
74be: b3,fe,16,42         ldb   R42,[Rfe+16]     R42 = No_hegos;
74c2: 98,22,00            cmpb  R0,R22           
74c5: d7,05               jne   74cc             if (0 != R22) goto 74cc;
74c7: 99,01,42            cmpb  R42,1            
74ca: d7,02               jne   74ce             if (R42 != 1) goto 74ce;
74cc: 20,0f               sjmp  74dd             goto 74dd;
74ce: b3,73,26,01,30      ldb   R30,[R72+126]    R30 = Egoss2;
74d3: 9b,f3,a5,00,30      cmpb  R30,[Rf2+a5]     
74d8: db,03               jc    74dd             if (R30 > Vegosw)  {
74da: 91,08,2b            orb   R2b,8            Error_detected = 1; }
74dd: 2a,01               scall 76e0             updTCodes(401,Tmr_OVF_cnt);
74df: 01,04,12            #args  
74e2: b3,79,f9,00,42      ldb   R42,[R78+f9]     R42 = Vsssw;
74e7: e0,42,65            djnz  R42,754f         R42--;
                                                 if (R42 != 0) goto 754f;
74ea: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = Vstype;
74ee: 98,00,42            cmpb  R42,R0           
74f1: df,5c               je    754f             if (R42 != 0)  {
74f3: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;
74f7: 99,04,42            cmpb  R42,4            
74fa: db,1a               jc    7516             if ((uns) R42 >= 4) goto 7516;
74fc: a3,73,dc,00,42      ldw   R42,[R72+dc]     R42 = Load;
7501: 3c,c5,0e            jb    B4,Rc5,7512      if (Tfmflag = 1) goto 7512;
7504: 37,d0,0b            jnb   B7,Rd0,7512      if (Cl_thrtl = 0) goto 7512;
7507: 8b,f3,14,01,42      cmpw  R42,[Rf2+114]    
750c: d9,04               jgtu  7512             if ((uns) R42 > Vsload ) goto 7512;
750e: 20,18               sjmp  7528             goto 7528;


7510: 20,02               ??    

7512: 20,0e               sjmp  7522             goto 7522;


7514: 20,0c               ??    

7516: 37,e7,09            jnb   B7,Re7,7522      if (Ndsflg = 1)  {
7519: 8b,f3,74,01,ae      cmpw  Rae,[Rf2+174]    
751e: d3,02               jnc   7522             if ((uns) Rpmx4 < Vsamin) goto 7522;
7520: 20,06               sjmp  7528             goto 7528; }
7522: c7,72,49,00         stb   R0,[R72+49]      Vsstmr = 0;
7526: 20,27               sjmp  754f             goto 754f;
7528: 8b,f3,76,01,ae      cmpw  Rae,[Rf2+176]    
752d: db,04               jc    7533             if ((uns) Rpmx4 >= Vsmmin) goto 7533;
752f: 20,1e               sjmp  754f             goto 754f;


7531: 20,0d               ??    

7533: b3,72,49,42         ldb   R42,[R72+49]     R42 = Vsstmr;
7537: 9b,f3,7a,01,42      cmpb  R42,[Rf2+17a]    
753c: db,02               jc    7540             if ((uns) R42 >= Vsstim) goto 7540;
753e: 20,0f               sjmp  754f             goto 754f;
7540: b3,73,3d,01,42      ldb   R42,[R72+13d]    R42 = Mph_FiltH;
7545: 9b,f3,78,01,42      cmpb  R42,[Rf2+178]    
754a: db,03               jc    754f             if (R42 > Vssmn1)  {
754c: 91,08,2b            orb   R2b,8            Error_detected = 1; } } }
754f: 29,8f               scall 76e0             updTCodes(8003,LSO_Port);
7551: 03,80,02            #args  
7554: 36,d9,02            jnb   B6,Rd9,7559      if (Vegrbp = 0) goto 7559;
7557: 20,d9               sjmp  7632             goto 7632;
7559: 3e,e6,0d            jb    B6,Re6,7569      if (Pfehp_flg = 0)  {
755c: ef,70,09            call  7ecf             ChkSensor(EVP_Raw,Vevpll,Evpmin,32); # Lo,Hi limit, E hi = none, E Lo - PFE/EVP/ (sonic) voltage below closed limit
755f: 16,01,b4,90,b0,90,32,00 #args  
7567: 20,1f               sjmp  7588             goto 7588; }
7569: 3f,d0,02            jb    B7,Rd0,756e      if (Cl_thrtl = 1) goto 756e;
756c: 20,80               sjmp  75ee             goto 75ee;
756e: a3,72,88,42         ldw   R42,[R72+88]     R42 = RPM_Filt1;
7572: 8b,79,c8,00,42      cmpw  R42,[R78+c8]     
7577: db,f3               jc    756c             if ((uns) R42 >= Vn) goto 756c;
7579: 2a,5c               scall 77d7             SrolavT(Fiept);
757b: 80,03               #args  
757d: ef,4f,09            call  7ecf             ChkSensor(Fiept,Veptil,Eptmin,3432); # PFE/EVP/ (sonic) voltage below closed limit, Defective PFE/EPT sensor ?
7580: 80,03,40,91,34,91,32,34 #args  
7588: b0,1a,40            ldb   R40,R1a          R40 = R1a;
758b: 2a,60               scall 77ed             Set_TC(31);
758d: 31                  #args  
758e: 29,50               scall 76e0             updTCodes(802a,LIO_Port);
7590: 2a,80,03            #args  
7593: 2a,58               scall 77ed             Set_TC(35);
7595: 35                  #args  
7596: 29,48               scall 76e0             updTCodes(832,IO_Timer_Hi);
7598: 32,08,07            #args  
759b: 33,2c,08            jnb   B3,R2c,75a6      if (Wigflg = 1)  {
759e: 71,bf,2c            an2b  R2c,bf           Egrfg2 = 0;
75a1: 71,7f,2c            an2b  R2c,7f           Egrfg1 = 0;
75a4: 20,87               sjmp  762d             goto 762d; }
75a6: 2a,45               scall 77ed             Set_TC(32);
75a8: 32                  #args  
75a9: 29,35               scall 76e0             updTCodes(4002,AD_Low);
75ab: 02,40,04            #args  
75ae: 36,e6,0a            jnb   B6,Re6,75bb      if (Pfehp_flg = 1)  {
75b1: 2a,3a               scall 77ed             Set_TC(34);
75b3: 34                  #args  
75b4: 29,2a               scall 76e0             updTCodes(1002,IO_Timer);
75b6: 02,10,06            #args  
75b9: 20,33               sjmp  75ee             goto 75ee; }
75bb: 3c,40,e0            jb    B4,R40,759e      if (B4_R40 = 1) goto 759e;
75be: 98,00,d3            cmpb  Rd3,R0           
75c1: d7,28               jne   75eb             if (Rd3 != 0) goto 75eb;
75c3: 71,7f,2c            an2b  R2c,7f           Egrfg1 = 0;
75c6: 3e,2c,07            jb    B6,R2c,75d0      if (Egrfg2 = 0)  {
75c9: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
75cd: 91,40,2c            orb   R2c,40           Egrfg2 = 1; }
75d0: ef,91,03            call  7964             Compare(EVP_Raw,Vevphl);
75d3: 16,01,b6,90         #args  
75d7: 33,2b,0a            jnb   B3,R2b,75e4      if (Error_detected = 0) goto 75e4;
75da: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = Vip_timer_ex;
75de: 9b,78,3c,18         cmpb  R18,[R78+3c]     
75e2: d3,4e               jnc   7632             if ((uns) R18 < Veitmr) goto 7632;
75e4: 28,fa               scall 76e0             updTCodes(1002,IO_Timer);
75e6: 02,10,06            #args  
75e9: 20,42               sjmp  762d             goto 762d;
75eb: 71,bf,2c            an2b  R2c,bf           Egrfg2 = 0;
75ee: 9b,78,29,d3         cmpb  Rd3,[R78+29]     
75f2: d3,aa               jnc   759e             if ((uns) Rd3 < Vcrtdc) goto 759e;
75f4: a3,73,dc,00,42      ldw   R42,[R72+dc]     R42 = Load;
75f9: 8b,78,2e,42         cmpw  R42,[R78+2e]     
75fd: d9,9f               jgtu  759e             if ((uns) R42 > Vegrload ) goto 759e;
75ff: 3f,2c,07            jb    B7,R2c,7609      if (Egrfg1 = 0)  {
7602: 91,80,2c            orb   R2c,80           Egrfg1 = 1;
7605: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0; }
7609: 3e,e6,09            jb    B6,Re6,7615      if (Pfehp_flg = 0)  {
760c: ef,55,03            call  7964             Compare(Vevpcl,EVP_Raw);
760f: ba,90,16,01         #args  
7613: 20,0b               sjmp  7620             goto 7620; }
7615: 29,c0               scall 77d7             SrolavT(Cfiept);
7617: 7e,03               #args  
7619: ef,48,03            call  7964             Compare(Cfiept,Veptcl);
761c: 7e,03,46,91         #args  
7620: 33,2b,0a            jnb   B3,R2b,762d      if (Error_detected = 0) goto 762d;
7623: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = Vip_timer_ex;
7627: 9b,78,28,18         cmpb  R18,[R78+28]     
762b: d3,05               jnc   7632             if ((uns) R18 >= Vectmr)  {
762d: 28,b1               scall 76e0             updTCodes(2002,AD_High);
762f: 02,20,05            #args                  }
7632: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
7635: 8b,78,fa,ae         cmpw  Rae,[R78+fa]     
7639: db,02               jc    763d             if ((uns) Rpmx4 >= Vlorpm) goto 763d;
763b: 20,36               sjmp  7673             goto 7673;
763d: 2b,25               scall 7964             Compare(Tslpip,Vpiptm);
763f: 3e,01,7c,90         #args  
7643: 33,2b,0b            jnb   B3,R2b,7651      if (Error_detected = 1)  {
7646: 91,01,2c            orb   R2c,1            Idm_bypass = 1;
7649: c7,72,3f,00         stb   R0,[R72+3f]      Idm_fault_cnt = 0;
764d: c3,72,44,00         stw   R0,[R72+44]      Tslidm = 0; }                     # time in self test mode?
7651: 28,8d               scall 76e0             updTCodes(4001,0);
7653: 01,40,00            #args  
7656: 38,2c,0d            jb    B0,R2c,7666      if (Idm_bypass = 0)  {
7659: 2b,09               scall 7964             Compare(Tslidm,Vidmtm);
765b: c4,01,78,90         #args  
765f: 28,7f               scall 76e0             updTCodes(2001,15);
7661: 01,20,15            #args  
7664: 20,11               sjmp  7677             goto 7677; }
7666: a3,72,44,42         ldw   R42,[R72+44]     R42 = Tslidm;
766a: 9b,f2,76,43         cmpb  R43,[Rf2+76]     
766e: d1,07               jleu  7677             if ((uns) R43 > Vidmst )  {
7670: 71,fe,2c            an2b  R2c,fe           Idm_bypass = 0;
7673: c3,72,44,00         stw   R0,[R72+44]      Tslidm = 0; }
7677: 29,80               scall 77f9             upd_flflg(LIO_Port,20);
7679: 03,00,20            #args  
767c: 29,7b               scall 77f9             upd_flflg(HSI_Mask,HSO_time);
767e: 0c,00,80            #args  
7681: 29,76               scall 77f9             upd_flflg(30,40);
7683: 30,00,40            #args  
7686: 29,71               scall 77f9             upd_flflg(Mkay,STACK);
7688: c0,00,10            #args  
768b: 29,6c               scall 77f9             upd_flflg(400,LSO_Port);
768d: 00,04,02            #args  
7690: 29,67               scall 77f9             upd_flflg(300,INT_Mask);
7692: 00,03,08            #args  
7695: 33,2c,09            jnb   B3,R2c,76a1      if (Wigflg = 1)  {
7698: 37,d8,04            jnb   B7,Rd8,769f      if (Threshold_lvl = 1)  {
769b: 29,0f               scall 77ac             Set_STO();                        # tweak flags, set STO on and return
769d: 20,02               sjmp  76a1             goto 76a1; }
769f: 29,13               scall 77b4             Reset_STO(); }                    # set STO off flag, set STO output low, and set STO trigger
76a1: 39,25,3b            jb    B1,R25,76df      if (Warm_up = 1) return;
76a4: 3f,a1,38            jb    B7,Ra1,76df      if (Cranking = 1) return;
76a7: 3a,a1,35            jb    B2,Ra1,76df      if (Undsp = 1) return;
76aa: b3,73,2d,ff,14      ldb   R14,[R72+ff2d]   R14 = Tcstrt;
76af: 9b,f2,6c,14         cmpb  R14,[Rf2+6c]     
76b3: d6,2a               jge   76df             if (R14 >= Vect5) return;
76b5: 9b,f3,fe,00,b0      cmpb  Rb0,[Rf2+fe]     
76ba: da,23               jle   76df             if (ECT <= Vect3) return;
76bc: 91,02,25            orb   R25,2            Warm_up = 1;
76bf: 30,ef,1d            jnb   B0,Ref,76df      if (Power_up = 0) return;
76c2: 3d,2b,1a            jb    B5,R2b,76df      if (Stiflg = 1) return;           # jump if STI input is high
# incr the # times the test has been run for index R38 and less ?
76c5: a1,17,00,38         ldw   R38,17           R38 = 17;
76c9: b3,39,c9,07,3a      ldb   R3a,[R38+7c9]    R3a = [R38+Kam_index6];           # incr 22 bytes in Table clamp at max of FF
76ce: 17,3a               incb  R3a              R3a++;
76d0: d7,02               jne   76d4             if (R3a = 0)  {
76d2: 15,3a               decb  R3a              R3a--; }                          # clamp to FF max
76d4: c7,39,c9,07,3a      stb   R3a,[R38+7c9]    [R38+Kam_index6] = R3a;
76d9: e0,38,ed            djnz  R38,76c9         R38--;
                                                 if (R38 != 0) goto 76c9;
76dc: 71,fe,ef            an2b  Ref,fe           Power_up = 0; }
76df: f0                  ret                    return;

#######################################################
# sets and clears trouble code bit flags
# first param (at 001A) bottom 3 bits are index in 7C4 Table?
# rest of bit >> 3 and - 1 are error flag bit
#######################################################


  updTCodes:
76e0: 28,dc               scall 77be             GetbytesR1a(3);                   # copy the three bytes to R1A/1B/1C
76e2: 03                  #args  
76e3: bc,1c,14            ldsbw R14,R1c          R14 = (int)R1c;                   # 3rd param byte to word
76e6: 44,f2,14,42         ad3w  R42,R14,Rf2      R42 = R14 + Rf2;                  # address 8E5A + data offset
76ea: b3,43,d7,00,42      ldb   R42,[R42+d7]     R42 = [R42+d7];                   # read ROM at lookup address
76ef: 44,f2,14,3a         ad3w  R3a,R14,Rf2      R3a = R14 + Rf2;                  # same ROM address AGAIN
76f3: b3,3b,c1,00,3a      ldb   R3a,[R3a+c1]     R3a = [R3a+c1];                   # what is this byte RAM Table?
76f8: ac,1a,18            ldzbw R18,R1a          R18 = (uns)R1a;                   # 1st param byte to word
76fb: 71,07,18            an2b  R18,7            R18 &= 7;                         # mask out bottom 3 bits of first param (0 -7)
76fe: 65,c4,07,18         ad2w  R18,7c4          R18 += Kam_indexl;                # R18 is now a pointer to ?
7702: 01,1c               clrw  R1c              R1c = 0;
7704: 18,03,1a            shrb  R1a,3            R1a /= 8;                         # first param >> 3 (shift out offset bits) 5 bits left
7707: df,07               je    7710             if (R1a != 0)  {                  # zero value is special ( flag bits are biased up by one )
7709: 15,1a               decb  R1a              R1a--;
770b: 07,1c               incw  R1c              R1c++;                            # R1C = 0001 now
770d: 09,1a,1c            shlw  R1c,R1a          R1c <<= R1a; }                    # creates a mask of bit # (R1A - 1)
7710: a3,73,02,02,34      ldw   R34,[R72+202]    R34 = Fmem_monitor;               # 382 error bit flags word
7715: b3,15,aa,01,30      ldb   R30,[R14+1aa]    R30 = [R14+C14FIL];               # R14 is second param
771a: 98,42,00            cmpb  R0,R42                                             # value looked up above
771d: df,0d               je    772c             if (0 = R42) goto 772c;
771f: 33,2c,07            jnb   B3,R2c,7729      if (Wigflg = 1)  {
7722: b3,78,f2,3a         ldb   R3a,[R78+f2]     R3a = Wiglvl;
7726: b1,ff,42            ldb   R42,ff           R42 = ff; }
7729: 3b,2b,2a            jb    B3,R2b,7756      if (Error_detected = 0)  {
772c: 98,00,30            cmpb  R30,R0           
772f: df,02               je    7733             if (R30 != 0)  {
7731: 15,30               decb  R30              R30--; }
7733: 5b,78,7f,3a,3b      sb3b  R3b,R3a,[R78+7f] R3b = R3a - Filhys;
7738: 98,30,3b            cmpb  R3b,R30          
773b: d1,05               jleu  7742             if ((uns) R3b > R30 )  {
773d: 02,1c               cplw  R1c              R1c = ~R1c;                       # invert mask
773f: 60,1c,34            an2w  R34,R1c          R34 &= R1c; }                     # clear the error bit
7742: b1,28,42            ldb   R42,28           R42 = 28;
7745: 9b,15,ca,07,42      cmpb  R42,[R14+7ca]                                      # R14 is still? 3rd param byte (0x76E3)
774a: d9,08               jgtu  7754             if ((uns) R42 <= [R14+K14CNT])  {
774c: 12,1b               cplb  R1b              R1b = ~R1b;
774e: 72,18,1b            an2b  R1b,[R18]        R1b &= [R18];
7751: c6,18,1b            stb   R1b,[R18]        [R18] = R1b; }
7754: 20,37               sjmp  778d             goto 778d; }
7756: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
7759: 74,42,30            ad2b  R30,R42          R30 += R42;                       # add second param and looked up ROm value
775c: d3,03               jnc   7761             if ((uns) R30 >= 0)  {
775e: b1,ff,30            ldb   R30,ff           R30 = ff; }                       # clamp max value
7761: 98,30,3a            cmpb  R3a,R30                                            # compare second param sum and Table lookup value
7764: db,27               jc    778d             if (R3a > R30)  {
7766: 89,c6,07,18         cmpw  R18,7c6                                            # what is this address ?
776a: d7,13               jne   777f             if (R18 != 7c6) goto 777f;
776c: 51,f8,1b,33         an3b  R33,R1b,f8       R33 = R1b & f8;                   # clr bits 0,1,2
7770: df,0d               je    777f             if (R33 = 0) goto 777f;
7772: b2,18,33            ldb   R33,[R18]        R33 = [R18];
7775: 71,f8,33            an2b  R33,f8           R33 &= f8;                        # clr bits 0,1,2
7778: df,05               je    777f             if (R33 = 0) goto 777f;
777a: 70,1b,33            an2b  R33,R1b          R33 &= R1b;
777d: df,0b               je    778a             if (R33 != 0)  {
777f: 92,18,1b            orb   R1b,[R18]        R1b |= [R18];
7782: c6,18,1b            stb   R1b,[R18]        [R18] = R1b;
7785: c7,15,ca,07,00      stb   R0,[R14+7ca]     [R14+K14CNT] = 0; }
778a: 80,1c,34            orw   R34,R1c          R34 |= R1c; }                     # set the error bit
778d: 98,30,3a            cmpb  R3a,R30          
7790: db,03               jc    7795             if (R3a > R30)  {
7792: 91,80,d8            orb   Rd8,80           Threshold_lvl = 1; }
7795: c7,15,aa,01,30      stb   R30,[R14+1aa]    [R14+C14FIL] = R30;               # save ? R14 is second param (ie 1AA + 0D = 1B7)
779a: c3,73,02,02,34      stw   R34,[R72+202]    Fmem_monitor = R34;               # 382 error bit flags, bit 2 set = ECT grounded
779f: f0                  ret                    return;


  clear_KAM:
77a0: ad,1d,16            ldzbw R16,1d           R16 = (uns)1d;
77a3: c7,17,c3,07,00      stb   R0,[R16+7c3]     [R16+7c3] = 0;                    # clear Table 7C4 to 7D9
77a8: e0,16,f8            djnz  R16,77a3         R16--;
                                                 if (R16 != 0) goto 77a3;
77ab: f0                  ret                    return;


  Set_STO:
77ac: 91,80,d6            orb   Rd6,80           Sto_on = 1;                       # tweak flags. set STO on and return
77af: 91,20,46            orb   R46,20           Sto_state = 1;                    # LSO output line 5 (STO) ON (MIL)
# set STO off flag, set STO output low, and set STO trigger
77b2: 20,06               sjmp  77ba             goto 77ba;

  Reset_STO:
77b4: 91,40,d6            orb   Rd6,40           Sto_off = 1;                      # set STO OFF flag
77b7: 71,df,46            an2b  R46,df           Sto_state = 0;                    # LSO output line 5 (STO) OFF (MIL)
77ba: 91,04,2b            orb   R2b,4            Sto_trigger = 1;                  # set Self Test Output trigger
77bd: f0                  ret                    return;

################################################################
# copy specified bytes to R1A onwards (77c2)
# or where specified in R16 (77be) from GRANDCALLER subroutine.
# gets one byte from return address of caller function.
# gets reqd bytes from 'Grandcaller' function, and mods return addresses.
# IN  - 1 byte (caller subroutine), NumBytes (grandcaller subroutine)
# OUT - [R1a] or [x] onwards asigned bytes 
################################################################


  GetbytesR1a:
77be: a1,1a,00,16         ldw   R16,1a           R16 = 1a;                         # default destination is R1a onwards

  Getbytes:
77c2: cc,3c               pop   R3c              R3c = pop();                      # Caller's (normal) return address
77c4: b2,3d,3a            ldb   R3a,[R3c++]      R3a = [R3c++];                    # Get count of bytes, Inc return address
77c7: cc,42               pop   R42              R42 = pop();                      # Get GrandCaller's return address
77c9: b2,43,3b            ldb   R3b,[R42++]      R3b = [R42++];
77cc: c6,17,3b            stb   R3b,[R16++]      [R16++] = R3b;
77cf: e0,3a,f7            djnz  R3a,77c9         R3a--;
                                                 if (R3a != 0) goto 77c9;          # Get no of bytes into dest. addr
77d2: c8,42               push  R42              push(R42);
77d4: c8,3c               push  R3c              push(R3c);                        # and push modded returns back.
77d6: f0                  ret                    return;

################################################################
# extended filter ? gets 2 bytes from ROM
# R32 is OLD AD sensor value
# R34 is new AD sensor value
# R36 is manged filtering factor
################################################################


  SrolavT:
77d7: 2f,e5               scall 77be             GetbytesR1a(2);                   # get ROM bytes to R1A
77d9: 02                  #args                                                    # get 2 bytes into R1A from this caller's return addr
77da: a2,1a,32            ldw   R32,[R1a]        R32 = [R1a];                      # (address of) OLD AD sensor value
77dd: a3,72,96,34         ldw   R34,[R72+96]     R34 = EVP_Raw;                    # NEW AD sensor value 216 - raw EVP
77e1: a3,79,ca,00,36      ldw   R36,[R78+ca]     R36 = Vtcept;                     # manged filter factor
77e6: ef,7a,be            call  3663             Urolav();                         # filter
77e9: c2,1a,3e            stw   R3e,[R1a]        [R1a] = R3e;                      # save updated value
77ec: f0                  ret                    return;

################################################################


  Set_TC:
77ed: 2f,cf               scall 77be             GetbytesR1a(1);                   # get 1 ROM byte to R1A
77ef: 01                  #args  
77f0: 98,1a,40            cmpb  R40,R1a          
77f3: d7,03               jne   77f8             if (R40 != R1a) return;
77f5: 91,08,2b            orb   R2b,8            Error_detected = 1; }
77f8: f0                  ret                    return;

################################################################


  upd_flflg:
77f9: 2f,c3               scall 77be             GetbytesR1a(3);                   # get 3 ROM bytes to R1A
77fb: 03                  #args                                                    # 3 bytes to R1A,B,C from caller
77fc: 63,73,02,02,1a      an2w  R1a,[R72+202]    R1a &= Fmem_monitor;              # 382 word
7801: df,04               je    7807             if (R1a != 0)  {
7803: 90,1c,c5            orb   Rc5,R1c          Fmem_flags |= R1c;
7806: f0                  ret                    return; }

7807: 12,1c               cplb  R1c              R1c = ~R1c;
7809: 70,1c,c5            an2b  Rc5,R1c          Fmem_flags &= R1c;
780c: f0                  ret                    return;

################################################################
# Key On Engine Off (KOEO) Self -Tests
################################################################


  Do_KOEO:
780d: 3d,2c,25            jb    B5,R2c,7835      if (Disable_eolt = 0)  {          # jmp if disable EOLT set
7810: ef,a1,ff            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7813: ef,67,0a            call  827d             HW_Check();                       # do h/w RAM/ROM/CPU checks
7816: ef,37,f8            call  7050             Get_diag_vals();                  # load diagnostic testing registers
7819: 34,2a,05            jnb   B4,R2a,7821      if (Disable_nostart = 1)  {       # jump if not VIP mode flag : disable no start
781c: ef,8d,ff            call  77ac             Set_STO();                        # Set STO output on - diddle some flags?
781f: 27,fb               sjmp  781c             goto 781c; }                      # *HANG* - h/w error
7821: ef,20,00            call  7844             Do_Csum();                        # checksum the ROM
7824: 11,38               clrb  R38              R38 = 0;                          # test selector set to zero
7826: 38,30,0c            jb    B0,R30,7835      if (B0_R30 = 0)  {
7829: 91,10,2c            orb   R2c,10           Sto_hyper = 1;                    # STO very fast readout set
782c: ad,05,d4            ldzbw Rd4,5            Vip_code = (uns)5;
782f: ef,45,f7            call  6f77             Sub43();                          # the skip two returns do not return here
7832: 71,ef,2c            an2b  R2c,ef           Sto_hyper = 0; } }                # clear STO very fast readout
7835: 91,20,2c            orb   R2c,20           Disable_eolt = 1;                 # disable EOLT
7838: 91,40,2a            orb   R2a,40           No_start = 1;                     # Set VIP mode flag : no start
783b: 3f,46,05            jb    B7,R46,7843      if (Pump = 1) return;             # if LSO output line 7 is ON (Fuel Pump)
783e: 32,2a,02            jnb   B2,R2a,7843      if (Vip_enable = 0) return;       # jump if not VIP mode flag : VIP enable
7841: 20,88               sjmp  78cb             goto 78cb; }                      # zero 1CA VIP TIMER EX, incr R38 self test index, and return
7843: f0                  ret                    return;

############################################################
# ROM Checksum
############################################################


  Do_Csum:
7844: 01,30               clrw  R30              R30 = 0;
7846: 01,3c               clrw  R3c              R3c = 0;                          # 
7848: a1,6a,78,42         ldw   R42,786a         R42 = 786a;                       # Start address (2000)
784c: 46,43,00,3a         ad3w  R3a,R0,[R42++]   R3a = [R42++];                    # End address  (9fff)
7850: df,0d               je    785f             if (R3a != 0)  {                  # If real end address
7852: a2,43,3e            ldw   R3e,[R42++]      R3e = [R42++];
7855: 66,3b,3c            ad2w  R3c,[R3a++]      R3c += [R3a++];                   # add to sum
7858: 88,3e,3a            cmpw  R3a,R3e                                            # end address reached?
785b: d1,f8               jleu  7855             if ((uns) R3a <= R3e) goto 7855;  # loop
785d: 27,ed               sjmp  784c             goto 784c; }                      # load next ROM range
785f: 88,3c,00            cmpw  R0,R3c           
7862: df,03               je    7867             if (0 != R3c)  {                  # checksum zero ?
7864: 2b,48               scall 7bae             SaveTCode1(15);                   # E15 - EEC ROM fail
7866: 15                  #args                  }
7867: 20,62               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return


7869: ff                        

######################## ROM checksum adresses ##############

786a: 00,20               word   2000                                              # start address(set 0 for no checksum test)
 # Chkbase               checksum base address. Set t
                                                                                   o zero to clear error code 15
786c: fe,9f               word   9ffe                                              # last address of ROM checksum
786e: 00,00               word      0
#############################################################


  Test1:
7870: b0,30,32            ldb   R32,R30          R32 = R30;
7873: 28,f7               scall 796c             CompareTC(Ectmin,ECT_Raw,61);     # 61 ECT sensor circuit grounded
7875: 7e,90,12,01,61      #args  
787a: 28,f0               scall 796c             CompareTC(ECT_Raw,Ectmax,51);     # 51 ECT circuit open
787c: 12,01,80,90,51      #args  
7881: 98,30,32            cmpb  R32,R30          
7884: d7,09               jne   788f             if (R32 = R30)  {
7886: 2b,38               scall 7bc0             ChkRngeTC(ECT_Raw,Viect2,Viect1,21); # 21 ECT out of range
7888: 12,01,f8,90,f6,90,21 #args                 }
788f: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
7893: df,1a               je    78af             if (0 != [947b])  {
7895: b3,72,b6,42         ldb   R42,[R72+b6]     R42 = Baptmr;
7899: 9b,f3,16,01,42      cmpb  R42,[Rf2+116]    
789e: d1,05               jleu  78a5             if ((uns) R42 > Vbpmax )  {
78a0: 2b,0c               scall 7bae             SaveTCode1(22);                   # 22 MAP/BP sensor out of range
78a2: 22                  #args  
78a3: 20,0a               sjmp  78af             goto 78af; }
78a5: ef,18,03            call  7bc0             ChkRngeTC(BAP_Intvl,Vbpdl1,Vbpdl2,22); # 22 MAP/BP sensor out of range
78a8: 0a,01,02,91,04,91,22 #args                 }
78af: a3,72,a4,42         ldw   R42,[R72+a4]     R42 = MAF_Raw;
78b3: 8b,79,88,00,42      cmpw  R42,[R78+88]     
78b8: d3,11               jnc   78cb             if ((uns) R42 >= Vmafo1)  {
78ba: 8b,79,8e,00,42      cmpw  R42,[R78+8e]     
78bf: d3,05               jnc   78c6             if ((uns) R42 >= Maxmaf)  {
78c1: b1,56,1a            ldb   R1a,56           R1a = 56;                         # 56 MAF circuit above max voltage
78c4: 20,03               sjmp  78c9             goto 78c9; }
78c6: b1,26,1a            ldb   R1a,26           R1a = 26;                         # 26 MAF input out of range
78c9: 2a,e7               scall 7bb2             SaveTCode(); }                    # save code 26
78cb: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;                 # CALLED BELOW - zero timer, incr self test index and return
78cf: 17,38               incb  R38              R38++;
78d1: f0                  ret                    return;


  Test2:
78d2: 28,70               scall 7944             Sub67();
78d4: b0,30,32            ldb   R32,R30          R32 = R30;
78d7: 28,93               scall 796c             CompareTC(Actmin,ACT_Raw,64);     # 64 ACT sensor circuit grounded
78d9: 68,90,14,01,64      #args  
78de: 28,8c               scall 796c             CompareTC(ACT_Raw,Actmax,54);     # 54 ACT sensor circuit open
78e0: 14,01,6a,90,54      #args  
78e5: 98,30,32            cmpb  R32,R30          
78e8: d7,09               jne   78f3             if (R32 = R30)  {
78ea: 2a,d4               scall 7bc0             ChkRngeTC(ACT_Raw,Viact2,Viact1,Flags_24); # 24 ACT sensor out of range
78ec: 14,01,f0,90,ee,90,24 #args                 }
78f3: 3e,d9,1b            jb    B6,Rd9,7911      if (Vegrbp = 0)  {
78f6: 3e,e6,0d            jb    B6,Re6,7906      if (Pfehp_flg = 0)  {
78f9: ef,d3,05            call  7ecf             ChkSensor(EVP_Raw,Vevpll,Evpmin,3432); # 32 EGR not controlling,E34 Insufficient EGR flow
78fc: 16,01,b4,90,b0,90,32,34 #args  
7904: 20,0b               sjmp  7911             goto 7911; }
7906: ef,c6,05            call  7ecf             ChkSensor(EVP_Raw,Veptll,Eptmin,3434); # 34 Insufficient EGR flow
7909: 16,01,38,91,34,91,34,34 #args              }
7911: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;
7915: 99,03,42            cmpb  R42,3            
7918: d3,0b               jnc   7925             if ((uns) R42 >= 3)  {
791a: 99,04,42            cmpb  R42,4            
791d: d9,06               jgtu  7925             if ((uns) R42 <= 4)  {
791f: 37,e7,03            jnb   B7,Re7,7925      if (Ndsflg = 1)  {
7922: 2a,8a               scall 7bae             SaveTCode1(67);                   # 67 NPS circuit open with Air conditioning on
7924: 67                  #args                  } } }                             # 67 Neutral Pressure switch (NPS) circuit open
7925: 37,ee,03            jnb   B7,Ree,792b      if (A3C = 1)  {
7928: 2a,84               scall 7bae             SaveTCode1(79);                   # 79 A/C on / Defrost
792a: 79                  #args                  }
792b: b3,f6,14,42         ldb   R42,[Rf6+14]     R42 = Pspshp;
792f: 99,01,42            cmpb  R42,1            
7932: d7,07               jne   793b             if (R42 = 1)  {
7934: 34,27,04            jnb   B4,R27,793b      if (Powsfg = 1)  {
7937: ef,74,02            call  7bae             SaveTCode1(52);                   # 52 Power Steering Pressure Switch circuit open
793a: 52                  #args                  } }
793b: 28,2f               scall 796c             CompareTC(Vkypwr,Key_Pwr,19);     # 19 Failure in ECC reference voltage
793d: 52,90,0c,01,19      #args  
7942: 20,97               sjmp  79db             goto 79db;

  Sub67:
7944: b0,30,32            ldb   R32,R30          R32 = R30;
7947: 28,23               scall 796c             CompareTC(Tapmin,TPS_Raw,63);     # 63 TP sensor circuit below min voltage
7949: 70,90,22,01,63      #args  
794e: 28,1c               scall 796c             CompareTC(TPS_Raw,Tapmax,53);     # 53 TP sensor circuit open, above max voltage
7950: 22,01,6e,90,53      #args  
7955: 98,30,32            cmpb  R32,R30          
7958: d7,09               jne   7963             if (R32 != R30) return;
795a: 2a,64               scall 7bc0             ChkRngeTC(TPS_Raw,Vtap1,Vtap2,23); # 23 - TP out of range during self test
795c: 22,01,5c,90,5e,90,23 #args                 }
7963: f0                  ret                    return;

#######################################################
# Compare two values. First value must be less than second
# or error code is generated
# Entry points for FOUR and FIVE params( 2 addresses + optional byte)
# Both params can be plain or complex address types,complex marked by bit 15.
# four param sets flag for pass/fail, 
# five param has error code as fifth byte and set if fails
#######################################################


  Compare:
7964: 91,08,2b            orb   R2b,8            Error_detected = 1;               # mark as 4 bytes
7967: 2e,55               scall 77be             GetbytesR1a(4);                   # copy 4 bytes from caller to R1A onwards
7969: 04                  #args  
796a: 20,03               sjmp  796f             goto 796f;

# entry point for FIVE params

  CompareTC:
796c: 2e,50               scall 77be             GetbytesR1a(5);
796e: 05                  #args  
796f: 28,1a               scall 798b             GetAddr(1a);                      # make R1a,b into true address
7971: 1a,00               #args  
7973: 28,16               scall 798b             GetAddr(1c);                      # make R1c,d into true address
7975: 1c,00               #args  
7977: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];
797a: 8a,1c,42            cmpw  R42,[R1c]        
797d: d1,08               jleu  7987             if ((uns) R42 <= [R1c]) goto 7987; # Jump if PASSED (no codes)
797f: 3b,2b,08            jb    B3,R2b,798a      if (Error_detected = 1) return;   # jump if 4 params
7982: b0,1e,1a            ldb   R1a,R1e          R1a = R1e;                        # 5 params, error code
7985: 2a,2b               scall 7bb2             SaveTCode();                      # save errorno in (342) TROUBLE CODE Table
7987: 71,f7,2b            an2b  R2b,f7           Error_detected = 0; }             # clear error marker
798a: f0                  ret                    return;

#######################################################
# Decode complex addresses into their TRUE addresses (plain ones OK too)
# address decoded back to input register (via R16, R42 )
# Address is encoded as 1 bit=flag, 3 bits=base reg/2, 12 bits offset from reg
# NOTE encoding is HALF reg value (because of divide by 8)
# return value is then a POINTER (as a plain address) 
#######################################################


  GetAddr:
798b: a1,3e,00,16         ldw   R16,3e           R16 = 3e;
798f: 2e,31               scall 77c2             Getbytes(2);                      # get address (from args in caller)
7991: 02                  #args  
7992: a2,3e,42            ldw   R42,[R3e]        R42 = [R3e];                      # get data from address
7995: 37,43,14            jnb   B7,R43,79ac      if (B7_R43 = 0) return;           # address not encoded - return unchanged
7998: ac,43,3a            ldzbw R3a,R43          R3a = (uns)R43;                   # Hi byte of value
799b: 71,0f,43            an2b  R43,f            R43 &= f;                         # Clear top nibble.  R42 = Offset address
799e: 71,70,3a            an2b  R3a,70           R3a &= 70;                        # Clear bottom nibble and flag
79a1: 08,03,3a            shrw  R3a,3            R3a /= 8;                         # Rbase register (0-14 times 2 effectively)
79a4: 67,3b,f0,00,42      ad2w  R42,[R3a+f0]     R42 += [R3a+f0];                  # R42 += Rbase register (as pointer)
79a9: c2,3e,42            stw   R42,[R3e]        [R3e] = R42; }                    # update input pointer to new address
79ac: f0                  ret                    return;

# 716E Self test jump Table entry


  Sub68:
79ad: b3,78,f3,3a         ldb   R3a,[R78+f3]     R3a = V_fpmflg;
79b1: e0,3a,03            djnz  R3a,79b7         R3a--;
                                                 if (R3a != 0) goto 79b7;
79b4: 30,c4,04            jnb   B0,Rc4,79bb      if (Code_87 = 1)  {
79b7: 17,38               incb  R38              R38++;
79b9: 27,10               sjmp  78cb             goto 78cb; }                      # zero 1CA timer, incr R38 self test index, and return
79bb: 91,01,d9            orb   Rd9,1            Vip_fp_override = 1;
79be: 91,80,46            orb   R46,80           Pump = 1;                         # LSO output line 7 ON (Fuel Pump)
79c1: ef,77,04            call  7e3b             GetWord(V_fpmdly);
79c4: 74,90               #args  
79c6: 3c,df,03            jb    B4,Rdf,79cc      if (Fpm = 0)  {
79c9: 29,e3               scall 7bae             SaveTCode1(96);                   # E96 - Themactor Air System inoperative
79cb: 96                  #args                  }
79cc: 26,fd               sjmp  78cb             goto 78cb;

# 716E Self test jump Table entry

  Sub69:
79ce: ef,6a,04            call  7e3b             GetWord(V_fpmdly);
79d1: 74,90               #args  
79d3: 34,df,03            jnb   B4,Rdf,79d9      if (Fpm = 1)  {
79d6: 29,d6               scall 7bae             SaveTCode1(95);                   # E95 - Fuel Pump secondary circuit failure
79d8: 95                  #args                  }
79d9: 26,f0               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return
79db: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
79de: a1,f9,79,34         ldw   R34,79f9         R34 = 79f9;                       # 'return' address
79e2: 26,e7               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return

# 716E Self test jump Table entry
# where does R34 come from?

  Sub70:
79e4: 3d,e6,02            jb    B5,Re6,79e9      if (Vlfnon = 0)  {
79e7: 29,06               scall 7aef             Sub74(); }                        # force all LSO and HSO otputs off and STO on
79e9: b1,20,42            ldb   R42,20           R42 = 20;
79ec: c7,73,a2,00,42      stb   R42,[R72+a2]     Egrper = R42;
79f1: c7,73,a1,00,42      stb   R42,[R72+a1]     Egrcnt = R42;
79f6: c8,34               push  R34              push(R34);                        # address to jump to ?
79f8: f0                  ret                    return;

79f9: b3,fe,0b,3a         ldb   R3a,[Rfe+b]      R3a = Thrmhp;                     # 9E65 thermactor present switch = 1.0
79fd: e0,3a,0c            djnz  R3a,7a0c         R3a--;
                                                 if (R3a != 0) goto 7a0c;
# Idle Air Control Open Circuit Check, E81, limit, mask, - Idle Air Control
7a00: 28,74               scall 7a76             Test_IO(f681,4710);
7a02: 81,f6,10,47         #args  
# Air Management 1 Open Circuit Check, E82, limit, mask, - Air Management 1
7a06: 28,6e               scall 7a76             Test_IO(f882,4708);
7a08: 82,f8,08,47         #args                  }
# Canister purge Open Circuit Check, E85, limit, mask, # 12D Canister Purge on time
7a0c: b1,14,42            ldb   R42,14           R42 = 14;
7a0f: c7,72,ae,42         stb   R42,[R72+ae]     Purge_period = R42;
7a13: 28,7c               scall 7a91             OpenCChk(fe85,Purg_on_time);
7a15: 85,fe,2d,01         #args  
# Fuel Pump Open Circuit Check, E87, limit, mask, IO = Fuel Pump
7a19: 28,5b               scall 7a76             Test_IO(New_irqs,4680);
7a1b: 87,00,80,46         #args  
7a1f: 98,30,00            cmpb  R0,R30           
7a22: df,0d               je    7a31             if (0 != R30)  {
7a24: b3,31,41,03,3a      ldb   R3a,[R30+341]    R3a = [R30+341];
7a29: 99,87,3a            cmpb  R3a,87           
7a2c: d7,03               jne   7a31             if (R3a = 87)  {
7a2e: 91,01,c4            orb   Rc4,1            Code_87 = 1; } }
7a31: 3e,d9,06            jb    B6,Rd9,7a3a      if (Vegrbp = 0)  {
7a34: 28,5b               scall 7a91             OpenCChk(fc84,d3);                # check ? E84
7a36: 84,fc,d3,00         #args                  }
7a3a: 91,20,e6            orb   Re6,20           Vlfnon = 1;
7a3d: b3,f6,74,42         ldb   R42,[Rf6+74]     R42 = Fan_enble;
7a41: e0,42,11            djnz  R42,7a55         R42--;
                                                 if (R42 != 0) goto 7a55;
7a44: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
# Electro Drive Fan Open Circuit Check, E88, limit.mask = ElectroDriveFan
7a48: 28,2c               scall 7a76             Test_IO(Em,4720);
7a4a: 88,02,20,47         #args  
7a4e: ef,ea,03            call  7e3b             GetWord(Vdledf);
7a51: bd,90               #args  
7a53: 28,9a               scall 7aef             Sub74(); }
7a55: b3,f6,75,42         ldb   R42,[Rf6+75]     R42 = Hedfhp;
7a59: e0,42,0f            djnz  R42,7a6b         R42--;
                                                 if (R42 != 0) goto 7a6b;
7a5c: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
# Hi Fan Open Circuit Check, E83, limit,mask, R47 bit 6 - HiFan output line
7a60: 28,14               scall 7a76             Test_IO(fa83,4740);
7a62: 83,fa,40,47         #args  
7a66: ef,d2,03            call  7e3b             GetWord(Vdlhed);
7a69: be,90               #args                  }
7a6b: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
7a6e: 28,7f               scall 7aef             Sub74();                          # call set HSO Time Hold = Master IO Timer Lo + # 0003
7a70: 91,10,d9            orb   Rd9,10           Kam_codes = 1;
7a73: e7,03,06            jump  8079             goto Sub99;                       # clr 1CA timer, incr R38 self test index, set bit flag and return

#################################################################
# Four data bytes follow calls to this function (R1A,1B,1C,1D)
# R1A - is Trouble Code if there is an error
# R1B - ROM loc for limit 8F86 + this offset (word)
# R1C - parameter flag - mask to select the device (Fan, CANP, FuelPump etc)
# R1D - pointer to SFR flag byte usually R46 or 47 for output lines
# The OCC AD channel must be a supply voltage to the actuators
# This performs 'circuit' tests
# Measure any variation in voltage when the selected output line is switched
#################################################################

  Test_IO:
7a76: 28,29               scall 7aa1             Sub71();                          # load params from stack & OCC base line test of circuit
7a78: ac,1d,20            ldzbw R20,R1d          R20 = (uns)R1d;                   # fourth param byte to word
# toggle output line for this device
7a7b: b2,20,1d            ldb   R1d,[R20]        R1d = [R20];                      # load contents of SFR
7a7e: 94,1c,1d            xorb  R1d,R1c          R1d ^= R1c;                       # mask contents with third param
7a81: c6,20,1d            stb   R1d,[R20]        [R20] = R1d;                      # store back in [SFR]
7a84: 28,37               scall 7abd             Sub72();                          # read OCC and compare to level before - set Trouble code if out of range
7a86: 3d,e6,06            jb    B5,Re6,7a8f      if (Vlfnon = 0)  {
# retoggle output line for this same device
7a89: 94,1c,1d            xorb  R1d,R1c          R1d ^= R1c;                       # xor 3rd and fourth param (if calls did not change them)
7a8c: c6,20,1d            stb   R1d,[R20]        [R20] = R1d; }                    # store fourth param? to [SFR]
7a8f: 20,0d               sjmp  7a9e             goto 7a9e;                        # return to callers caller

################################################################
# Open Circuit Check ?
# Four data byte follow calls to this function
# (via 7aa1)
################################################################

  OpenCChk:
7a91: 28,0e               scall 7aa1             Sub71();                          # load params from stack & OCC base line test of circuit
7a93: b1,80,42            ldb   R42,80           R42 = 80;
7a96: c6,1c,42            stb   R42,[R1c]        [R1c] = R42;
7a99: 28,22               scall 7abd             Sub72();                          # read OCC and compre to level before - set Trouble code if out of range
7a9b: c6,1c,00            stb   R0,[R1c]         [R1c] = 0;
7a9e: cc,34               pop   R34              R34 = pop();
7aa0: f0                  ret                    return;

################################################################
# Read reference base level OCC AD channel for the test circuit line
################################################################


  Sub71:
7aa1: 28,33               scall 7ad6             Sub73();                          # Repeatedly read AD channels 2.4mS
7aa3: cc,1e               pop   R1e              R1e = pop();                      # back up stack by one call
7aa5: 2d,17               scall 77be             GetbytesR1a(4);                   # Get 4 bytes from Grandcaller into R1A
7aa7: 04                  #args  
7aa8: c8,1e               push  R1e              push(R1e);                        # restore stack
7aaa: bc,1b,1e            ldsbw R1e,R1b          R1e = (int)R1b;                   # circuit test param 2 - ROM location selector
7aad: 65,2c,01,1e         ad2w  R1e,12c          R1e += Purgdc;
7ab1: 64,f2,1e            ad2w  R1e,Rf2          R1e += Rf2;                       # R1E + ROM 8E5A + 12C = 8F86 + R1E
7ab4: a3,72,8e,16         ldw   R16,[R72+8e]     R16 = OCC_Raw;                    # 10E - OCC - Open Circuit Check AD value
7ab8: c3,72,5e,16         stw   R16,[R72+5e]     Occsav = R16;                     # 1DE - OCC reference level save value
7abc: f0                  ret                    return;

###############################################################
# Compare to the reference OCC level
# Read the switched OCC level for the test circuit line
###############################################################


  Sub72:
7abd: 28,17               scall 7ad6             Sub73();                          # Repeatedly read AD channels for 5161 IOtimes
7abf: a3,72,5e,16         ldw   R16,[R72+5e]     R16 = Occsav;                     # 1DE - OCC reference level save value
7ac3: 6b,72,8e,16         sb2w  R16,[R72+8e]     R16 -= OCC_Raw;                   # 10E - OCC - Open Circuit Check AD value - difference
7ac7: db,02               jc    7acb             if (R16 > 0)  {                   # jmp if positive
7ac9: 03,16               negw  R16              R16 = -R16; }                     # ABS OCC value
7acb: 8a,1e,16            cmpw  R16,[R1e]                                          # limit for this circuit
7ace: db,03               jc    7ad3             if ((uns) R16 >= [R1e]) goto 7ad3; # jmp if OCC >= ROM Limit - GOOD
7ad0: e7,32,04            jump  7f05             goto 7f05;                        # Post Trouble Code (in R1a) - open circuit error for X
7ad3: 11,1a               clrb  R1a              R1a = 0;                          # clr trouble code
7ad5: f0                  ret                    return;

################################################################
# Repeatedly read AD channels for 5161 IO times (12.4 mS)
########################################################


  Sub73:
7ad6: c0,3c,06            stw   R6,R3c           R3c = IO_Timer;                   # read start time
7ad9: 48,3c,06,3e         sb3w  R3e,R6,R3c       R3e = IO_Timer - R3c;             # = time passed
7add: 89,61,51,3e         cmpw  R3e,5161                                           # loop until 5161 IO times have passed
7ae1: db,0b               jc    7aee             if ((uns) R3e >= 5161) return;
7ae3: ef,8f,f5            call  7075             Save_diag_vals();                 # Save diagnostic testing registers
7ae6: ef,45,a7            call  222e             Read_AD();                        # read all the AD channels 
7ae9: ef,64,f5            call  7050             Get_diag_vals();                  # reload diagnostic testing registers
7aec: 27,eb               sjmp  7ad9             goto 7ad9; }
7aee: f0                  ret                    return;

########################################################
# This function forces all LSO lines and BiDir lines OFF
# sets Fan=1 (b5 R47) but clears rest of R46 and 47 and increments HSIO TIME 
# some kind of reset function ?
########################################################


  Sub74:
7aef: a1,00,20,46         ldw   R46,2000         IO_Port_State = 2000;             # set Fan=1 (b5 R47) 
7af3: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
7af8: 01,d2               clrw  Rd2              Egrdc = 0;
7afa: 01,b8               clrw  Rb8              Iscdty = 0;
7afc: c7,72,ac,00         stb   R0,[R72+ac]      Purgdc = 0;
7b00: f0                  ret                    return;

# 716E Self test jump Table entry


  Sub75:
7b01: 3b,d6,08            jb    B3,Rd6,7b0c      if (Sto_working = 0)  {
7b04: 17,38               incb  R38              R38++;                            # incr self test index
7b06: 2f,e7               scall 7aef             Sub74();                          # Reset ?
7b08: 85,00,00,46         xrw   R46,0            IO_Port_State ^= 0; }
7b0c: c3,72,42,00         stw   R0,[R72+42]      Outtmr = 0;
7b10: 71,f7,d8            an2b  Rd8,f7           Reqflg = 0;
7b13: 71,cf,e6            an2b  Re6,cf           Vhfnon = 0;
                                                 Vlfnon = 0;
7b16: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
7b1a: f0                  ret                    return;

########################################################


  Sub76:
7b1b: ef,07,f8            call  7325             Sub66();
7b1e: 3b,d6,f9            jb    B3,Rd6,7b1a      if (Sto_working = 1) goto 7b1a;
7b21: a3,78,e4,1c         ldw   R1c,[R78+e4]     R1c = Vtap5;
7b25: 8b,72,a2,1c         cmpw  R1c,[R72+a2]                                       # compare to raw TP
7b29: db,3b               jc    7b66             if (R1c > TPS_Raw)  {
7b2b: 91,08,d8            orb   Rd8,8            Reqflg = 1;
7b2e: 3d,46,35            jb    B5,R46,7b66      if (Sto_state = 0)  {             # if LSO output line 5 (STO) is ON (MIL)
7b31: b3,f6,75,42         ldb   R42,[Rf6+75]     R42 = Hedfhp;                     # fan high speed enable
7b35: e0,42,17            djnz  R42,7b4f         R42--;
                                                 if (R42 != 0) goto 7b4f;
7b38: 9b,78,40,18         cmpb  R18,[R78+40]     
7b3c: d1,11               jleu  7b4f             if ((uns) R18 > Vhfntm )  {
7b3e: 3c,e6,0c            jb    B4,Re6,7b4d      if (Vhfnon = 0)  {
7b41: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
7b44: 91,10,e6            orb   Re6,10           Vhfnon = 1;
7b47: ad,05,d4            ldzbw Rd4,5            Vip_code = (uns)5;
7b4a: ef,2a,f4            call  6f77             Sub43(); }
7b4d: 20,16               sjmp  7b65             return; } }                       # return
7b4f: b3,f6,74,42         ldb   R42,[Rf6+74]     R42 = Fan_enble;                  # fan control enable
7b53: e0,42,10            djnz  R42,7b66         R42--;
                                                 if (R42 != 0) goto 7b66;
7b56: 9b,78,3f,18         cmpb  R18,[R78+3f]     
7b5a: d1,09               jleu  7b65             if ((uns) R18 <= Vlfntm) return;
7b5c: 3d,e6,06            jb    B5,Re6,7b65      if (Vlfnon = 1) return;
7b5f: 91,20,e6            orb   Re6,20           Vlfnon = 1;
7b62: ef,0f,f4            call  6f74             Sub42();
7b65: f0                  ret                    return; } } }

7b66: 33,d8,37            jnb   B3,Rd8,7ba0      if (Reqflg = 0) goto 7ba0;
7b69: a3,78,e6,1c         ldw   R1c,[R78+e6]     R1c = Vtap6;
7b6d: 8b,72,a2,1c         cmpw  R1c,[R72+a2]     
7b71: d1,2d               jleu  7ba0             if ((uns) R1c <= TPS_Raw) goto 7ba0;
7b73: 35,46,02            jnb   B5,R46,7b78      if (Sto_state = 0) goto 7b78;
7b76: 27,8e               sjmp  7b06             goto 7b06;
7b78: 85,71,1a,46         xrw   R46,1a71         Scvac ^= 1;
                                                 Scvnt ^= 1;
                                                 Sto_state ^= 1;
                                                 WOT_AC ^= 1;
                                                 Canp ^= 1;
                                                 Sbs1 ^= 1;
                                                 Iac ^= 1;
7b7c: 35,e6,03            jnb   B5,Re6,7b82      if (Vlfnon = 1)  {
7b7f: 95,20,47            xorb  R47,20           Fan ^= 1; }
7b82: 34,e6,03            jnb   B4,Re6,7b88      if (Vhfnon = 1)  {
7b85: 95,40,47            xorb  R47,40           Hi_fan ^= 1; }
7b88: a1,00,80,42         ldw   R42,8000         R42 = 8000;
7b8c: c0,d2,42            stw   R42,Rd2          Egrdc = R42;
7b8f: c0,b8,42            stw   R42,Rb8          Iscdty = R42;
7b92: b1,10,1e            ldb   R1e,10           R1e = 10;
7b95: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
7b9a: c7,72,ac,43         stb   R43,[R72+ac]     Purgdc = R43;                     # = 80
7b9e: 27,6c               sjmp  7b0c             goto 7b0c;                        # exit w/o odd h/w instruction
7ba0: a3,72,42,1a         ldw   R1a,[R72+42]     R1a = Outtmr;                     # 1C2 timer?
7ba4: 89,58,02,1a         cmpw  R1a,258          
7ba8: d1,02               jleu  7bac             if ((uns) R1a <= 258) goto 7bac;
7baa: 27,5a               sjmp  7b06             goto 7b06;                        # exit
7bac: 27,68               sjmp  7b16             goto 7b16;

########################################################
# save R1A in TROUBLE CODE Table (at 342)
# save range error code up to index 19
# trouble code set in R1A (7bb2) or via inline param (7bae)
########################################################

  SaveTCode1:
7bae: ef,0d,fc            call  77be             GetbytesR1a(1);                   # Get 1 byte from caller to R1A
7bb1: 01                  #args  

  SaveTCode:
7bb2: 89,13,00,30         cmpw  R30,13                                             # 19 max error code positions in Table
7bb6: db,07               jc    7bbf             if ((uns) R30 >= 13) return;
7bb8: c7,31,42,03,1a      stb   R1a,[R30+342]    [R30+Serv_code_tab] = R1a;        # 342 is base of Hard Trouble Code Error Table
7bbd: 07,30               incw  R30              R30++; }
7bbf: f0                  ret                    return;

###############################################################
# Range test.  Error code to 342 Table
# 1st and 2nd params are AD value to check
# 3rd and 4th params are [encoded] value limit low
# 5th and 6th params are [encoded] value limit high
# 7th param is trouble code
# params are placed in R1A/1B/1C/1D/1E/1F/20
###############################################################


  ChkRngeTC:
7bc0: ef,fb,fb            call  77be             GetbytesR1a(7);                   # get 7 bytes to R1A - R20
7bc3: 07                  #args                                                    # copy this many bytes to R1A on
7bc4: 2d,c5               scall 798b             GetAddr(1c);                      # decode R1c value if high bit set
7bc6: 1c,00               #args  
7bc8: 2d,c1               scall 798b             GetAddr(1e);                      # decode R1e value if high bit set
7bca: 1e,00               #args  
7bcc: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];                      # actual AD value to check
7bcf: 8a,1c,42            cmpw  R42,[R1c]                                          # limit low
7bd2: d3,05               jnc   7bd9             if ((uns) R42 < [R1c]) goto 7bd9;
7bd4: 8a,1e,42            cmpw  R42,[R1e]                                          # limit high
7bd7: d1,06               jleu  7bdf             if ((uns) R42 <= [R1e]) return;
7bd9: b0,20,1a            ldb   R1a,R20          R1a = R20;
7bdc: ef,d3,ff            call  7bb2             SaveTCode(); }                    # save specified trouble code in Table
7bdf: f0                  ret                    return;

# 716E Self test jump Table entry


  Sub77:
7be0: ef,d1,fb            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7be3: 01,30               clrw  R30              R30 = 0;
7be5: 71,fd,2b            an2b  R2b,fd           Rvip_cyl_bal = 0;                 # clear Self Test Output trigger
7be8: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
7beb: c7,73,92,00,00      stb   R0,[R72+92]      Vcutout = 0;                      # 112 - clear ECT raw ?
7bf0: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7bf3: 9b,f3,8e,00,00      cmpb  R0,[Rf2+8e]      
7bf8: d7,42               jne   7c3c             if (0 = Vdisfm)  {
7bfa: 51,b8,c5,22         an3b  R22,Rc5,b8       R22 = Fmem_flags & b8;
7bfe: df,3c               je    7c3c             if (R22 != 0)  {
7c00: 2f,ac               scall 7bae             SaveTCode1(98);                   # E98 - Hard Fault present
7c02: 98                  #args  
7c03: a3,73,02,02,22      ldw   R22,[R72+202]    R22 = Fmem_monitor;
7c08: 30,22,03            jnb   B0,R22,7c0e      if (B0_R22 = 1)  {
7c0b: 2f,a1               scall 7bae             SaveTCode1(64);                   # E64 - ACT sensor grounded
7c0d: 64                  #args                  }
7c0e: 31,22,03            jnb   B1,R22,7c14      if (B1_R22 = 1)  {
7c11: 2f,9b               scall 7bae             SaveTCode1(54);                   # E54 - ACT sensor open
7c13: 54                  #args                  }
7c14: 32,22,03            jnb   B2,R22,7c1a      if (B2_R22 = 1)  {
7c17: 2f,95               scall 7bae             SaveTCode1(61);                   # E61 - ECT sensor grounded
7c19: 61                  #args                  }
7c1a: 33,22,03            jnb   B3,R22,7c20      if (B3_R22 = 1)  {
7c1d: 2f,8f               scall 7bae             SaveTCode1(51);                   # E51 - ECT sensor open
7c1f: 51                  #args                  }
7c20: 36,22,03            jnb   B6,R22,7c26      if (B6_R22 = 1)  {
7c23: 2f,89               scall 7bae             SaveTCode1(63);                   # E63 - TP sensor  below min voltage
7c25: 63                  #args                  }
7c26: 37,22,03            jnb   B7,R22,7c2c      if (B7_R22 = 1)  {
7c29: 2f,83               scall 7bae             SaveTCode1(53);                   # E53 - TP sensor  above max voltage
7c2b: 53                  #args                  }
7c2c: 31,23,03            jnb   B1,R23,7c32      if (B1_R23 = 1)  {
7c2f: 2f,7d               scall 7bae             SaveTCode1(56);                   # E56 - TPS sensor below min voltage
7c31: 56                  #args                  }
7c32: 30,23,03            jnb   B0,R23,7c38      if (B0_R23 = 1)  {
7c35: 2f,77               scall 7bae             SaveTCode1(66);                   # E66 - TPS sensor above max voltage
7c37: 66                  #args                  }
7c38: b1,22,38            ldb   R38,22           R38 = 22;
7c3b: f0                  ret                    return; } }

7c3c: a3,fe,2c,1c         ldw   R1c,[Rfe+2c]     R1c = [9e86];
7c40: c3,73,8a,00,1c      stw   R1c,[R72+8a]     Lambse1 = R1c;                    # HEGO1 delta time initial value?
7c45: c3,73,8c,00,1c      stw   R1c,[R72+8c]     Lambse2 = R1c;                    # HEGO2 delta time initial value?
7c4a: a3,fe,32,3e         ldw   R3e,[Rfe+32]     R3e = [9e8c];
7c4e: c3,72,6e,3e         stw   R3e,[R72+6e]     Rviprpm = R3e;
7c52: 71,bf,4f            an2b  R4f,bf           Knock_enabled = 0;                # clr Knock Enabled
7c55: 01,9e               clrw  R9e              Eftr = 0;
7c57: a1,00,01,42         ldw   R42,100          R42 = TP_Filt;
7c5b: c3,73,34,06,42      stw   R42,[R72+634]    Kamrf1 = R42;
7c60: c3,73,36,06,42      stw   R42,[R72+636]    Kamrf2 = R42;
7c65: a3,78,d0,c2         ldw   Rc2,[R78+d0]     Saf = Vipspk;
7c69: 01,d2               clrw  Rd2              Egrdc = 0;
7c6b: 91,40,46            orb   R46,40           WOT_AC = 1;                       # LSO output line 6 ON (Wide Open THrottle A/C cutout)
7c6e: 71,f7,46            an2b  R46,f7           Isc = 0;                          # LSO output line 3 OFF (Idle Speed Control)
7c71: 71,ef,47            an2b  R47,ef           Iac = 0;                          # R47 bit 4 OFF (Air management2)
7c74: c7,72,ac,00         stb   R0,[R72+ac]      Purgdc = 0;                       # 12C
7c78: 91,03,d7            orb   Rd7,3            Code_75 = 1;
                                                 Code_74 = 1;                      # DOO trouble codes ?
7c7b: 71,f3,e6            an2b  Re6,f3           Powoff = 0;
                                                 Powon = 0;
7c7e: ef,98,f6            call  7319             Sub65();
7c81: e7,8a,02            jump  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub78:
7c84: 29,b5               scall 7e3b             GetWord(9e8a);
7c86: 30,f0               #args  
7c88: a3,fe,32,32         ldw   R32,[Rfe+32]     R32 = [9e8c];
7c8c: 09,05,32            shlw  R32,5            R32 *= 20;
7c8f: 6b,72,88,32         sb2w  R32,[R72+88]     R32 -= RPM_Filt1;                 # - filtered RPM
7c93: d6,02               jge   7c97             if (R32 < 0)  {
7c95: 03,32               negw  R32              R32 = -R32; }
7c97: 2c,d3               scall 796c             CompareTC(32,9e8e,Tmr_OVF_cnt);   # E12 - Cannot control RPM during high RPM test
7c99: 32,00,34,f0,12      #args  
7c9e: 91,10,2b            orb   R2b,10           Disable_isc = 1;
7ca1: 22,6b               sjmp  7f0e             goto 7f0e;

  Sub79:
7ca3: 2f,1b               scall 7bc0             ChkRngeTC(ECT_Raw,Viect4,Viect3,21); # E21 - ECT out of range during self test
7ca5: 12,01,fc,90,fa,90,21 #args  
7cac: 2f,12               scall 7bc0             ChkRngeTC(MAF_Raw,Vmafr1,Vmafr2,Flags_26); # E26 - MAF ? sensor out of range during self test
7cae: 24,01,0a,91,0c,91,26 #args  
7cb5: 2f,09               scall 7bc0             ChkRngeTC(TPS_Raw,Vtap3,Vtap4,23); # E23 - TP sensor out of range during self test
7cb7: 22,01,60,90,62,90,23 #args  
7cbe: 2f,00               scall 7bc0             ChkRngeTC(ACT_Raw,Viact4,Viact3,Flags_24); # E24 - ACT sensor out of range during self test
7cc0: 14,01,f4,90,f2,90,24 #args  
7cc7: 22,45               sjmp  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub80:
7cc9: a3,72,88,42         ldw   R42,[R72+88]     R42 = RPM_Filt1;                  # filtered sensor output - in place (0108) - filtered RPM
7ccd: 8b,78,d8,42         cmpw  R42,[R78+d8]     
7cd1: db,04               jc    7cd7             if (R42 > Vnmin)  {
7cd3: b1,12,38            ldb   R38,12           R38 = 12;
7cd6: f0                  ret                    return; }

7cd7: 91,e0,d7            orb   Rd7,e0           Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
7cda: 28,ff               scall 7ddb             Sub87();
7cdc: d7,03               jne   7ce1             if (Tc_flags = 0)  {
7cde: 91,1c,d7            orb   Rd7,1c           Code_67_94 = 1;
                                                 Code_45_92 = 1;
                                                 Code_77_91 = 1; }
7ce1: 29,53               scall 7e36             Sub88();
7ce3: 22,29               sjmp  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub81:
7ce5: 37,2b,03            jnb   B7,R2b,7ceb      if (Egoste1 = 1)  {               # jump if no HEGO1 cross over voltage detected yet
7ce8: 71,bf,d7            an2b  Rd7,bf           Code_42_72 = 0; }
7ceb: 36,2b,03            jnb   B6,R2b,7cf1      if (Egoste2 = 1)  {               # jump if no HEGO2 cross over voltage detected yet
7cee: 71,f7,d7            an2b  Rd7,f7           Code_45_92 = 0; }
7cf1: 3e,d7,07            jb    B6,Rd7,7cfb      if (Code_42_72 = 0)  {
7cf4: 3b,d7,04            jb    B3,Rd7,7cfb      if (Code_45_92 = 0)  {
7cf7: 29,3d               scall 7e36             Sub88();
7cf9: 22,13               sjmp  7f0e             goto 7f0e; } }
7cfb: 28,eb               scall 7de8             Scale_time_delta2(Viplr1);
7cfd: 56,90               #args  
7cff: 29,3a               scall 7e3b             GetWord(9e88);
7d01: 2e,f0               #args  
7d03: 36,d7,03            jnb   B6,Rd7,7d09      if (Code_42_72 = 1)  {
7d06: 2e,a6               scall 7bae             SaveTCode1(42);                   #E42 - EGO sensor indicates system rich
7d08: 42                  #args                  }
7d09: 33,d7,03            jnb   B3,Rd7,7d0f      if (Code_45_92 = 1)  {
7d0c: 2e,a0               scall 7bae             SaveTCode1(TPtr);
7d0e: 92                  #args                  }
7d0f: 20,b7               sjmp  7dc8             goto 7dc8;
#E92 - Air/Fuel mixture not within Self test range
# Diagnostic Proc Table A

  Sub82:
7d11: 3f,2b,03            jb    B7,R2b,7d17      if (Egoste1 = 0)  {               # jump if HEGO1 cross over voltage detected
7d14: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0; }
7d17: 3e,2b,03            jb    B6,R2b,7d1d      if (Egoste2 = 0)  {               # jump if HEGO2 cross over voltage detected
7d1a: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; }
7d1d: 3f,d7,05            jb    B7,Rd7,7d25      if (Code_25_41 = 0)  {
7d20: 3c,d7,02            jb    B4,Rd7,7d25      if (Code_77_91 = 1) goto 7d25;
7d23: 21,e9               sjmp  7f0e             goto 7f0e; }
7d25: 28,bc               scall 7de3             Scale_Time_delta(Viprr1);         # 'filter' to scale time delta (ROM range limited to 10A)
7d27: 54,90               #args  
7d29: a3,73,8a,00,42      ldw   R42,[R72+8a]     R42 = Lambse1;
7d2e: 8b,fe,28,42         cmpw  R42,[Rfe+28]     
7d32: d1,04               jleu  7d38             if ((uns) R42 > [9e82] )  {
7d34: 15,38               decb  R38              R38--;
7d36: 21,d6               sjmp  7f0e             goto 7f0e; }
7d38: 29,01               scall 7e3b             GetWord(942f);
7d3a: 87,b0               #args  
7d3c: 37,d7,03            jnb   B7,Rd7,7d42      if (Code_25_41 = 1)  {
7d3f: 2e,6d               scall 7bae             SaveTCode1(41);                   #E41 - EGO sensor indicates system lean
7d41: 41                  #args                  }
7d42: 34,d7,03            jnb   B4,Rd7,7d48      if (Code_77_91 = 1)  {
7d45: 2e,67               scall 7bae             SaveTCode1(Slice_ptr);            #E91 - Air/Fuel mixture not with Self test range
7d47: 91                  #args                  }
7d48: 20,7e               sjmp  7dc8             goto 7dc8;
# Diagnostic Proc Table A

  Sub83:
7d4a: b3,78,cd,1a         ldb   R1a,[R78+cd]     R1a = Vairfl;
7d4e: 30,1a,77            jnb   B0,R1a,7dc8      if (B0_R1a = 0) goto 7dc8;
7d51: b3,fe,0b,1a         ldb   R1a,[Rfe+b]      R1a = Thrmhp;                     # Thermactor present?
7d55: 30,1a,70            jnb   B0,R1a,7dc8      if (B0_R1a = 0) goto 7dc8;
7d58: 28,89               scall 7de3             Scale_Time_delta(Viprr1);         # 'filter' to scale time delta (ROM range limited to 10A)
7d5a: 54,90               #args  
7d5c: 28,dd               scall 7e3b             GetWord(Vdly1);
7d5e: 56,91               #args  
7d60: 91,08,47            orb   R47,8            Sbs1 = 1;                         # (Air management1)
7d63: 91,10,47            orb   R47,10           Iac = 1;                          # (Air management2)
7d66: 21,a6               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub84:
7d68: 37,2b,03            jnb   B7,R2b,7d6e      if (Egoste1 = 1)  {               # jump if no HEGO1 cross over voltage detected yet
7d6b: 71,df,d7            an2b  Rd7,df           Code_44_73 = 0; }
7d6e: 36,2b,03            jnb   B6,R2b,7d74      if (Egoste2 = 1)  {               # jump if no HEGO2 cross over voltage detected yet
7d71: 71,fb,d7            an2b  Rd7,fb           Code_67_94 = 0; }
7d74: 3d,d7,03            jb    B5,Rd7,7d7a      if (Code_44_73 = 1) goto 7d7a;
7d77: 32,d7,12            jnb   B2,Rd7,7d8c      if (Code_67_94 = 1)  {
7d7a: 28,bf               scall 7e3b             GetWord(Viptm2);
7d7c: 58,91               #args  
7d7e: 32,d7,03            jnb   B2,Rd7,7d84      if (Code_67_94 = 1)  {
7d81: 2e,2b               scall 7bae             SaveTCode1(94);                   #E94 Thermactor Air System inoperative
7d83: 94                  #args                  }
7d84: 35,d7,03            jnb   B5,Rd7,7d8a      if (Code_44_73 = 1)  {
7d87: 2e,25               scall 7bae             SaveTCode1(HSOut_Flags);          #E44 Thermactor Air System inoperative
7d89: 44                  #args                  }
7d8a: 20,36               sjmp  7dc2             goto 7dc2; }
7d8c: 71,ef,47            an2b  R47,ef           Iac = 0;
7d8f: 21,7d               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub85:
7d91: 28,48               scall 7ddb             Sub87();
7d93: d7,03               jne   7d98             if (Flags_47 != 0) goto 7d98;
7d95: 36,2b,0a            jnb   B6,R2b,7da2      if (Egoste2 = 1)  {               # HEGO2 cross over voltage detected
7d98: 37,2b,07            jnb   B7,R2b,7da2      if (Egoste1 = 1)  {               # HEGO1 cross over voltage detected
7d9b: 28,9e               scall 7e3b             GetWord(Vatmr2);
7d9d: 59,91               #args  
7d9f: 2e,0d               scall 7bae             SaveTCode1(45);                   #E45 Thermactor air upstream during Self test
7da1: 45                  #args                  } }
7da2: 71,f7,47            an2b  R47,f7           Sbs1 = 0;                         # R47 bit 3 OFF (Air management1)
7da5: 91,10,47            orb   R47,10           Iac = 1;                          # R47 bit 4 ON (Air management2)
7da8: 21,64               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub86:
7daa: b3,78,ce,1a         ldb   R1a,[R78+ce]     R1a = Vtabfl;
7dae: 30,1a,11            jnb   B0,R1a,7dc2      if (B0_R1a = 1)  {
7db1: 28,88               scall 7e3b             GetWord(Vdly2);
7db3: 57,91               #args  
7db5: 28,24               scall 7ddb             Sub87();
7db7: d7,03               jne   7dbc             if (Flags_47 != 0) goto 7dbc;
7db9: 36,2b,06            jnb   B6,R2b,7dc2      if (Egoste2 = 1)  {               # HEGO2 cross over voltage detected
7dbc: 37,2b,03            jnb   B7,R2b,7dc2      if (Egoste1 = 1)  {               # HEGO1 cross over voltage detected
7dbf: 2d,ed               scall 7bae             SaveTCode1(IO_Port_State);        #E46 Thermactor air not by-passed during Self test
7dc1: 46                  #args                  } } }
7dc2: 71,ef,47            an2b  R47,ef           Iac = 0;                          # Air management2
7dc5: 71,f7,47            an2b  R47,f7           Sbs1 = 0;                         # Air management1
7dc8: a3,fe,2c,1c         ldw   R1c,[Rfe+2c]     R1c = [9e86];
7dcc: c3,73,8a,00,1c      stw   R1c,[R72+8a]     Lambse1 = R1c;
7dd1: c3,73,8c,00,1c      stw   R1c,[R72+8c]     Lambse2 = R1c;
7dd6: b1,0a,38            ldb   R38,a            R38 = a;
7dd9: 21,33               sjmp  7f0e             goto 7f0e;

  Sub87:
7ddb: b3,fe,16,42         ldb   R42,[Rfe+16]     R42 = No_hegos;                   # no of HEGOs
7ddf: 99,02,42            cmpb  R42,2            
7de2: f0                  ret                    return;


########################################################
# Very odd routine
# Word behind caller is 'filter' to scale time delta (ROM range limited to 10A)
########################################################


  Scale_Time_delta:
7de3: 91,10,28            orb   R28,10           Ramp_rich = 1;
7de6: 20,03               sjmp  7deb             goto 7deb;

  Scale_time_delta2:
7de8: 71,ef,28            an2b  R28,ef           Ramp_rich = 0;
7deb: ef,d0,f9            call  77be             GetbytesR1a(2);                   # copy byte following call count bytes from stackptr2 to 001A
7dee: 02                  #args                                                    # copy this many bytes to 001A from this callers return address
7def: ef,99,fb            call  798b             GetAddr(1a);                      # mangle the value at 001A into ROM if high bit set
7df2: 1a,00               #args  
7df4: 4b,72,60,06,34      sb3w  R34,R6,[R72+60]  R34 = IO_Timer - Viplatm;         # 00E0 IO time since last visit to this proc
7df9: 6d,44,28,34         ml2w  R34,2844         R34 *= 2844;                      # time since ? * ?
7dfd: 4e,1a,36,3c         ml3w  R3c,R36,[R1a]    R3c = R36 * [R1a];                # R36 is Hi 16 bits of prior result times "filter"
7e01: 34,28,16            jnb   B4,R28,7e1a      if (Ramp_rich = 0) goto 7e1a;
7e04: a3,73,8a,00,1c      ldw   R1c,[R72+8a]     R1c = Lambse1;                    # 10A ? MAP/BP ? time?
7e09: 68,3e,1c            sb2w  R1c,R3e          R1c -= R3e;                       # time delta * # 2844 * filterFactor
7e0c: d1,06               jleu  7e14             if ((uns) R1c <= 0) goto 7e14;
7e0e: 8b,fe,28,1c         cmpw  R1c,[Rfe+28]                                       # 9E82 - 6000
7e12: db,18               jc    7e2c             if (R1c > [9e82])  {
7e14: a3,fe,28,1c         ldw   R1c,[Rfe+28]     R1c = [9e82];                     # 9E82 - 6000 - clamp if too low
7e18: 20,12               sjmp  7e2c             goto 7e2c;
7e1a: 47,73,8a,00,3e,1c   ad3w  R1c,R3e,[R72+8a] R1c = R3e + Lambse1;              # 10A Table ?
7e20: db,06               jc    7e28             if ((uns) R1c >= 0) goto 7e28;
7e22: 8b,fe,2a,1c         cmpw  R1c,[Rfe+2a]                                       # 9E84 - A666
7e26: d1,04               jleu  7e2c             if ((uns) R1c > [9e84] )  {
7e28: a3,fe,2a,1c         ldw   R1c,[Rfe+2a]     R1c = [9e84]; } }                 # 9E84 - A666 - clamp if too high
7e2c: c3,73,8a,00,1c      stw   R1c,[R72+8a]     Lambse1 = R1c;                    # 10A
7e31: c3,73,8c,00,1c      stw   R1c,[R72+8c]     Lambse2 = R1c;                    # 10C - ? store to raw KEYPWR?

  Sub88:
7e36: c3,72,60,06         stw   R6,[R72+60]      Viplatm = IO_Timer;               # store last time tweaked
7e3a: f0                  ret                    return;
########################################################


  GetWord:
7e3b: ef,80,f9            call  77be             GetbytesR1a(2);                   # copy byte following call count bytes from stackptr2 to 001A
7e3e: 02                  #args                                                    # copy this many bytes to 001A from this callers return address
7e3f: ef,49,fb            call  798b             GetAddr(1a);                      # mangle the value at 001A into ROM if high bit set
7e42: 1a,00               #args  
7e44: 9a,1a,18            cmpb  R18,[R1a]        
7e47: db,02               jc    7e4b             if ((uns) R18 >= [R1a]) return;
7e49: cc,00               pop   R0               R0 = pop(); }                     # nasty! return back two addresses
7e4b: f0                  ret                    return;

# Diagnostic proc Table A


  Sub89:
7e4c: 36,d9,04            jnb   B6,Rd9,7e53      if (Vegrbp = 1)  {
7e4f: b1,0f,38            ldb   R38,f            R38 = f;
7e52: f0                  ret                    return; }

7e53: 3e,e6,1b            jb    B6,Re6,7e71      if (Pfehp_flg = 0)  {
7e56: 28,77               scall 7ecf             ChkSensor(EVP_Raw,Vevpll,Evpmin,3432); # limit Low,Limit High,Trouble Codes, Lo limit,Hi limit
7e58: 16,01,b4,90,b0,90,32,34 #args  
7e60: 34,1a,04            jnb   B4,R1a,7e67      if (B4_R1a = 1)  {
7e63: b1,0f,38            ldb   R38,f            R38 = f;
7e66: f0                  ret                    return; }

7e67: a3,72,96,42         ldw   R42,[R72+96]     R42 = EVP_Raw;
7e6b: c3,72,70,42         stw   R42,[R72+70]     Tpsav = R42;
7e6f: 20,18               sjmp  7e89             goto 7e89; }
7e71: 28,5c               scall 7ecf             ChkSensor(Fiept,Veptrl,Eptmin,3432);
7e73: 80,03,3c,91,34,91,32,34 #args  
7e7b: 34,1a,02            jnb   B4,R1a,7e80      if (B4_R1a = 0) goto 7e80;
7e7e: 20,47               sjmp  7ec7             goto 7ec7;
7e80: a3,73,00,02,42      ldw   R42,[R72+200]    R42 = Fiept;
7e85: c3,72,70,42         stw   R42,[R72+70]     Tpsav = R42;
7e89: b3,78,2b,d3         ldb   Rd3,[R78+2b]     Rd3 = Vdcmin;
7e8d: 20,7f               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table D
# Diagnostic proc Table A

  Sub90:
7e8f: 3e,e6,0e            jb    B6,Re6,7ea0      if (Pfehp_flg = 0)  {
7e92: a3,72,96,42         ldw   R42,[R72+96]     R42 = EVP_Raw;
7e96: 6b,72,70,42         sb2w  R42,[R72+70]     R42 -= Tpsav;
7e9a: 8b,78,38,42         cmpw  R42,[R78+38]     
7e9e: 20,0e               sjmp  7eae             goto 7eae; }
7ea0: a3,72,70,42         ldw   R42,[R72+70]     R42 = Tpsav;
7ea4: 6b,73,00,02,42      sb2w  R42,[R72+200]    R42 -= Fiept;
7ea9: 8b,79,c4,00,42      cmpw  R42,[R78+c4]     
7eae: d2,17               jgt   7ec7             if (R42 <= Veptdl)  {
7eb0: 9b,78,2c,d3         cmpb  Rd3,[R78+2c]     
7eb4: db,0e               jc    7ec4             if (Rd3 > Vdcmax)  {
7eb6: 5f,78,2a,18,42      ml3b  R42,R18,[R78+2a] R42 = R18 * Vegrat;
7ebb: 08,03,42            shrw  R42,3            R42 /= 8;
7ebe: 57,78,2b,42,d3      ad3b  Rd3,R42,[R78+2b] Rd3 = R42 + Vdcmin;
7ec3: f0                  ret                    return; }

7ec4: 2c,e8               scall 7bae             SaveTCode1(33);                   # E33 - EGR valve (PFE and sonic) not opening
7ec6: 33                  #args                  }
7ec7: a0,00,d2            ldw   Rd2,R0           Egrdc = 0;
7eca: b1,0e,38            ldb   R38,e            R38 = e;
7ecd: 20,3f               sjmp  7f0e             goto 7f0e;

########################################################
# data params follow the call here
# param word 0 (1A) - sensor value EVP ?
# param word 1 (1C) - Lo
# param word 2 (1E) - Hi
# param byte 3 (20) - Trouble Code for ? voltage lower than mangle Lo
# param byte 4 (21) - Trouble Code for ? voltage lower than mangle Hi
########################################################

  ChkSensor:
7ecf: ef,ec,f8            call  77be             GetbytesR1a(8);
7ed2: 08                  #args  
7ed3: ef,b5,fa            call  798b             GetAddr(1c);
7ed6: 1c,00               #args  
7ed8: ef,b0,fa            call  798b             GetAddr(1e);
7edb: 1e,00               #args  
7edd: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];
7ee0: 01,1a               clrw  R1a              R1a = 0;
7ee2: 8a,1d,42            cmpw  R42,[R1c++]      
7ee5: db,0d               jc    7ef4             if ((uns) R42 >= [R1c++]) goto 7ef4;
7ee7: b1,31,1a            ldb   R1a,31           R1a = 31;                         # 35 - PFE/EPT/EVP below min voltage
7eea: 8a,1e,42            cmpw  R42,[R1e]        
7eed: d1,16               jleu  7f05             if ((uns) R42 <= [R1e]) goto 7f05;
7eef: b0,20,1a            ldb   R1a,R20          R1a = R20;
7ef2: 20,11               sjmp  7f05             goto 7f05;
7ef4: 8a,1c,42            cmpw  R42,[R1c]        
7ef7: d1,14               jleu  7f0d             if ((uns) R42 > [R1c] )  {
7ef9: b0,21,1a            ldb   R1a,R21          R1a = R21;
7efc: 8b,1e,02,42         cmpw  R42,[R1e+2]      
7f00: d3,03               jnc   7f05             if ((uns) R42 >= [R1e+2])  {
7f02: b1,35,1a            ldb   R1a,35           R1a = 35; }                       # 35 - PFE/EPT/EVP above max voltage
7f05: 51,62,2a,42         an3b  R42,R2a,62       R42 = VIP_flags & 62;             # VSCST, running, no start
7f09: df,02               je    7f0d             if (R42 = 0) return;
7f0b: 2c,a5               scall 7bb2             SaveTCode(); }                    # save R1A in 342 TROUBLE CODE Table
7f0d: f0                  ret                    return;

7f0e: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
7f12: 17,38               incb  R38              R38++;
7f14: f0                  ret                    return;

# Diagnostic proc Table A


  Sub91:
7f15: b3,79,d4,00,42      ldb   R42,[R78+d4]     R42 = Vspten;
7f1a: e0,42,33            djnz  R42,7f50         R42--;
                                                 if (R42 != 0) goto 7f50;
7f1d: a3,79,d2,00,c2      ldw   Rc2,[R78+d2]     Saf = Vspret;
7f22: 27,ea               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub92:
7f24: 2f,15               scall 7e3b             GetWord(Vsptdl);
7f26: 55,91               #args  
7f28: a3,72,88,42         ldw   R42,[R72+88]     R42 = RPM_Filt1;
7f2c: c3,72,6a,42         stw   R42,[R72+6a]     Nsav = R42;
7f30: a3,79,d0,00,c2      ldw   Rc2,[R78+d0]     Saf = Vspadv;
7f35: 27,d7               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub93:
7f37: 2f,02               scall 7e3b             GetWord(Vsptdl);
7f39: 55,91               #args  
7f3b: a3,79,ce,00,22      ldw   R22,[R78+ce]     R22 = Vsprpm;
7f40: 67,72,6a,22         ad2w  R22,[R72+6a]     R22 += Nsav;
7f44: ef,25,fa            call  796c             CompareTC(22,RPM_Filt1,18);
7f47: 22,00,08,01,18      #args  
7f4c: a3,78,d0,c2         ldw   Rc2,[R78+d0]     Saf = Vipspk;
7f50: b1,11,38            ldb   R38,11           R38 = 11;
7f53: 27,b9               sjmp  7f0e             goto 7f0e;                        # 18 - SPOUT circuit open (grounded? )

# Diagnostic proc Table A

  Sub94:
7f55: a3,fe,3a,3e         ldw   R3e,[Rfe+3a]     R3e = [9e94];
7f59: c3,72,6e,3e         stw   R3e,[R72+6e]     Rviprpm = R3e;
7f5d: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7f60: 27,ac               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub95:
7f62: 2e,d7               scall 7e3b             GetWord(9e90);
7f64: 36,f0               #args  
7f66: a3,fe,3a,32         ldw   R32,[Rfe+3a]     R32 = [9e94];
7f6a: 09,05,32            shlw  R32,5            R32 *= 20;
7f6d: 6b,72,88,32         sb2w  R32,[R72+88]     R32 -= RPM_Filt1;
7f71: d6,02               jge   7f75             if (R32 < 0)  {
7f73: 03,32               negw  R32              R32 = -R32; }
7f75: ef,f4,f9            call  796c             CompareTC(32,9e92,13);            # 13 Cannot control RPM during low RPM test
7f78: 32,00,38,f0,13      #args  
7f7d: 27,8f               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub96:
7f7f: 9b,78,0c,00         cmpb  R0,[R78+c]       
7f83: d7,05               jne   7f8a             if (0 = Goosw)  {
7f85: b1,16,38            ldb   R38,16           R38 = 16;
7f88: 20,ba               sjmp  8044             goto 8044; }
7f8a: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # is knock sensor present
7f8e: df,1f               je    7faf             if (0 != Kihp)  {
7f90: 91,02,2c            orb   R2c,2            Kflg_local = 1;
7f93: a3,78,08,c2         ldw   Rc2,[R78+8]      Saf = Goospk;
7f97: a3,79,80,00,42      ldw   R42,[R78+80]     R42 = Vrlam2;
7f9c: c3,73,8a,00,42      stw   R42,[R72+8a]     Lambse1 = R42;
7fa1: c3,73,8c,00,42      stw   R42,[R72+8c]     Lambse2 = R42;
7fa6: af,78,0d,1a         ldzbw R1a,[R78+d]      R1a = (uns)Vkts;
7faa: c3,73,a8,00,1a      stw   R1a,[R72+a8]     Htime_delta = R1a; }
7faf: 27,5d               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub97:
7fb1: 2e,88               scall 7e3b             GetWord(9e89);
7fb3: 2f,f0               #args  
7fb5: 91,f0,d7            orb   Rd7,f0           Code_77_91 = 1;
                                                 Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
7fb8: a3,72,88,1c         ldw   R1c,[R72+88]     R1c = RPM_Filt1;                  # filtered sensor output - in place (0108) - filtered RPM
7fbc: c3,72,6a,1c         stw   R1c,[R72+6a]     Nsav = R1c;
7fc0: 71,f7,d9            an2b  Rd9,f7           Vip_knock = 0;
7fc3: ef,ae,ef            call  6f74             Sub42();
7fc6: 27,46               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub98:
7fc8: 31,2c,0a            jnb   B1,R2c,7fd5      if (Kflg_local = 1)  {
7fcb: 33,d9,07            jnb   B3,Rd9,7fd5      if (Vip_knock = 1)  {
7fce: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0;
7fd1: a3,f2,50,c2         ldw   Rc2,[Rf2+50]     Saf = Vipspk; } }
7fd5: 4b,72,6a,ae,1c      sb3w  R1c,Rae,[R72+6a] R1c = Rpmx4 - Nsav;
7fda: d3,0a               jnc   7fe6             if ((uns) R1c >= 0)  {
7fdc: 8b,f3,86,00,1c      cmpw  R1c,[Rf2+86]     
7fe1: d3,03               jnc   7fe6             if ((uns) R1c >= Goosn)  {
7fe3: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; } }
7fe6: 4b,72,70,aa,42      sb3w  R42,Raa,[R72+70] R42 = TP - Tpsav;
7feb: d6,02               jge   7fef             if (R42 < 0)  {
7fed: 03,42               negw  R42              R42 = -R42; }
7fef: 8b,f3,8a,00,42      cmpw  R42,[Rf2+8a]     
7ff4: d3,03               jnc   7ff9             if ((uns) R42 >= Goostp)  {
7ff6: 71,cf,d7            an2b  Rd7,cf           Code_77_91 = 0;
                                                 Code_44_73 = 0; }
7ff9: 35,d7,03            jnb   B5,Rd7,7fff      if (Code_44_73 = 0) goto 7fff;
7ffc: 3c,d7,12            jb    B4,Rd7,8011      if (Code_77_91 = 0)  {
7fff: 39,d8,0f            jb    B1,Rd8,8011      if (Vf1 = 0)  {
8002: 91,02,d8            orb   Rd8,2            Vf1 = 1;
8005: b3,f3,84,00,1a      ldb   R1a,[Rf2+84]     R1a = Goosec;
800a: 79,0c,1a            sb2b  R1a,c            R1a -= c;
800d: c7,72,4a,1a         stb   R1a,[R72+4a]     Vip_timer_ex = R1a; } }
8011: 2e,28               scall 7e3b             GetWord(Goosec);
8013: 84,90               #args  
8015: 31,2c,0e            jnb   B1,R2c,8026      if (Kflg_local = 1)  {
8018: a3,fe,2c,42         ldw   R42,[Rfe+2c]     R42 = [9e86];
801c: c3,73,8a,00,42      stw   R42,[R72+8a]     Lambse1 = R42;
8021: c3,73,8c,00,42      stw   R42,[R72+8c]     Lambse2 = R42; }
8026: 34,d7,06            jnb   B4,Rd7,802f      if (Code_77_91 = 1)  {
8029: ef,82,fb            call  7bae             SaveTCode1(77);                   # E77 Operator error during Dynamic Response Test or Cyl Balance Test
802c: 77                  #args  
802d: 20,11               sjmp  8040             goto 8040; }
802f: 35,d7,04            jnb   B5,Rd7,8036      if (Code_44_73 = 1)  {
8032: ef,79,fb            call  7bae             SaveTCode1(73);                   # E73 Insufficient TPS change during Dynamic Response Test
8035: 73                  #args                  }
8036: 31,2c,07            jnb   B1,R2c,8040      if (Kflg_local = 1)  {
8039: 37,d7,04            jnb   B7,Rd7,8040      if (Code_25_41 = 1)  {
803c: ef,6f,fb            call  7bae             SaveTCode1(Flags_25);             # E25 Knock not sensed during Dynamic Response Test
803f: 25                  #args                  } }
8040: a3,78,d0,c2         ldw   Rc2,[R78+d0]     Saf = Vipspk;
8044: b3,78,12,42         ldb   R42,[R78+12]     R42 = Vbisw;
8048: e0,42,15            djnz  R42,8060         R42--;
                                                 if (R42 != 0) goto 8060;
804b: b3,f6,13,42         ldb   R42,[Rf6+13]     R42 = Bihp;
804f: e0,42,0e            djnz  R42,8060         R42--;
                                                 if (R42 != 0) goto 8060;
8052: 31,d7,04            jnb   B1,Rd7,8059      if (Code_74 = 1)  {
8055: ef,56,fb            call  7bae             SaveTCode1(Rp2);                  # E74 Brake on/off switch circuit open
8058: 74                  #args                  }
8059: 30,d7,04            jnb   B0,Rd7,8060      if (Code_75 = 1)  {
805c: ef,4f,fb            call  7bae             SaveTCode1(75);                   # E75 Brake on/off switch circuit closed
805f: 75                  #args                  } } }
8060: b3,79,cc,00,42      ldb   R42,[R78+cc]     R42 = Vpssw;
8065: e0,42,11            djnz  R42,8079         R42--;
                                                 if (R42 != 0) goto Sub99;
8068: b3,f6,14,42         ldb   R42,[Rf6+14]     R42 = Pspshp;
806c: e0,42,0a            djnz  R42,8079         R42--;
                                                 if (R42 != 0) goto Sub99;
806f: 32,e6,03            jnb   B2,Re6,8075      if (Powoff = 0) goto 8075;
8072: 3b,e6,04            jb    B3,Re6,8079      if (Powon = 0)  {
8075: ef,36,fb            call  7bae             SaveTCode1(52);                   #E52 Power Steering Pressure Switch circuit open
# Diagnostic Proc Table A
8078: 52                  #args                  } } }

  Sub99:
8079: 91,07,d6            orb   Rd6,7            High_speed = 1;
                                                 Lowspeed_repeat = 1;
                                                 Low_speed = 1;
# Diagnostic Proc Table D
807c: 26,90               sjmp  7f0e             goto 7f0e;

  Sub100:
807e: a3,3b,d8,71,1a      ldw   R1a,[R3a+71d8]   R1a = [R3a+71d8];
8083: 20,0c               sjmp  8091             goto 8091;
# Diagnostic Proc Table D

  Sub101:
8085: a3,3b,80,71,1a      ldw   R1a,[R3a+7180]   R1a = [R3a+7180];
808a: 20,05               sjmp  8091             goto 8091;
# Diagnostic proc Table A

  Sub102:
808c: a3,3b,6a,71,1a      ldw   R1a,[R3a+716a]   R1a = [R3a+716a];
8091: 37,1b,08            jnb   B7,R1b,809c      if (B7_R1b = 1)  {
8094: ef,f4,f8            call  798b             GetAddr(1a);
8097: 1a,00               #args  
8099: b2,1a,1a            ldb   R1a,[R1a]        R1a = [R1a]; }
809c: 98,1a,18            cmpb  R18,R1a          
809f: d9,01               jgtu  80a2             if ((uns) R18 <= R1a)  {
80a1: f0                  ret                    return; }

80a2: 17,38               incb  R38              R38++;
80a4: 26,68               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub103:
80a6: b1,04,36            ldb   R36,4            R36 = 4;
80a9: 38,2b,0b            jb    B0,R2b,80b7      if (Rvip_cyl_quit = 1) goto 80b7;
80ac: 9b,78,1f,00         cmpb  R0,[R78+1f]      
80b0: df,05               je    80b7             if (0 = Vcbflg) goto 80b7;
80b2: de,08               jlt   80bc             if (0 >= Vcbflg)  {
80b4: 31,2b,05            jnb   B1,R2b,80bc      if (Rvip_cyl_bal = 1)  {
80b7: b1,1f,38            ldb   R38,1f           R38 = 1f;
80ba: 26,52               sjmp  7f0e             goto 7f0e; } }
80bc: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
80bf: b1,1e,38            ldb   R38,1e           R38 = 1e;
80c2: 27,f6               sjmp  80ba             goto 80ba;
# Diagnostic proc Table A

  Sub104:
80c4: ef,74,fd            call  7e3b             GetWord(Vcbdly);
80c7: 9e,90               #args  
80c9: 39,2b,06            jb    B1,R2b,80d2      if (Rvip_cyl_bal = 0)  {
80cc: a3,78,18,1c         ldw   R1c,[R78+18]     R1c = Vcbpct;
80d0: 20,14               sjmp  80e6             goto 80e6; }
# diagnostic proc Table A
80d2: a3,72,74,1c         ldw   R1c,[R72+74]     R1c = Vcbpct_this_time;
80d6: 67,78,16,1c         ad2w  R1c,[R78+16]     R1c += Vcbpad;
80da: db,06               jc    80e2             if ((uns) R1c >= 0) goto 80e2;
80dc: 8b,78,14,1c         cmpw  R1c,[R78+14]     
80e0: d1,04               jleu  80e6             if ((uns) R1c > Vcbclp )  {
80e2: a3,78,14,1c         ldw   R1c,[R78+14]     R1c = Vcbclp; }
80e6: c3,72,74,1c         stw   R1c,[R72+74]     Vcbpct_this_time = R1c;
80ea: 91,10,2b            orb   R2b,10           Disable_isc = 1;
80ed: b1,19,38            ldb   R38,19           R38 = 19;
80f0: 27,c8               sjmp  80ba             goto 80ba;
# diagnostic proc Table A

  Sub105:
80f2: 28,d6               scall 81ca             Sub112();
80f4: ef,44,fd            call  7e3b             GetWord(Visdl4);
80f7: a0,90               #args  
80f9: fa                  di                     disable ints;
80fa: 28,e4               scall 81e0             Sub113();
80fc: 26,10               sjmp  7f0e             goto 7f0e;

  Sub106:
80fe: 28,ca               scall 81ca             Sub112();
8100: ef,38,fd            call  7e3b             GetWord(Vcbtm1);
8103: a2,90               #args  
8105: fa                  di                     disable ints;
8106: 28,f0               scall 81f8             Sub114();
8108: a1,00,80,1c         ldw   R1c,8000         R1c = 8000;
810c: 6b,72,74,1c         sb2w  R1c,[R72+74]     R1c -= Vcbpct_this_time;
8110: 6f,72,72,1c         ml2w  R1c,[R72+72]     R1c *= Vcbn;
8114: 0d,01,1c            shldw R1c,1            R1c *= 2;
8117: c0,36,1e            stw   R1e,R36          R36 = R1e;
811a: c7,73,92,00,34      stb   R34,[R72+92]     Vcutout = R34;                    # store to raw ECT AD
811f: 25,ed               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub107:
8121: 28,a7               scall 81ca             Sub112();
8123: ef,15,fd            call  7e3b             GetWord(Visdl5);
8126: a1,90               #args  
8128: fa                  di                     disable ints;
8129: 28,b5               scall 81e0             Sub113();
812b: 25,e1               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub108:
812d: 28,9b               scall 81ca             Sub112();
812f: ef,09,fd            call  7e3b             GetWord(Vcbtm2);
8132: a3,90               #args  
8134: fa                  di                     disable ints;
8135: 28,c1               scall 81f8             Sub114();
8137: 88,1c,36            cmpw  R36,R1c          
813a: d9,09               jgtu  8145             if ((uns) R36 <= R1c)  {
813c: b0,34,1a            ldb   R1a,R34          R1a = R34;
813f: 19,04,1a            shlb  R1a,4            R1a *= 10;
8142: ef,6d,fa            call  7bb2             SaveTCode(); }                    # save R1A in 342 TROUBLE CODE Table
8145: c7,73,92,00,00      stb   R0,[R72+92]      Vcutout = 0;                      # store to raw ECT AD
814a: e0,34,9d            djnz  R34,80ea         R34--;
                                                 if (R34 != 0) goto 80ea;
814d: a3,fe,3a,1a         ldw   R1a,[Rfe+3a]     R1a = [9e94];
8151: c3,72,6e,1a         stw   R1a,[R72+6e]     Rviprpm = R1a;
8155: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
8158: a3,fe,2c,42         ldw   R42,[Rfe+2c]     R42 = [9e86];
815c: c3,73,8a,00,42      stw   R42,[R72+8a]     Lambse1 = R42;
8161: c3,73,8c,00,42      stw   R42,[R72+8c]     Lambse2 = R42;                    # store to raw KEYPWR
8166: 88,30,00            cmpw  R0,R30           
8169: d7,04               jne   816f             if (0 = R30)  {
816b: ef,40,fa            call  7bae             SaveTCode1(Last_HSI);             # E 90 - Pass Cyl Balance Test
816e: 90                  #args                  }
816f: 91,02,2b            orb   R2b,2            Rvip_cyl_bal = 1;
8172: b1,1d,38            ldb   R38,1d           R38 = 1d;
8175: 25,97               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub109:
8177: 33,d6,05            jnb   B3,Rd6,817f      if (Sto_working = 1)  {
817a: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
817e: f0                  ret                    return; }

817f: 99,20,18            cmpb  R18,20           
8182: db,01               jc    8185             if (R18 > 20)  {
8184: f0                  ret                    return; }

8185: b1,16,38            ldb   R38,16           R38 = 16;
8188: 26,ef               sjmp  8079             goto Sub99;                       # clr 1CA timer, incr R38 self test index, set bit flag and return

# Diagnostic proc Table A

  Sub110:
818a: 3f,d0,03            jb    B7,Rd0,8190      if (Cl_thrtl = 0)  {
818d: 91,01,2b            orb   R2b,1            Rvip_cyl_quit = 1; }
8190: 30,2b,27            jnb   B0,R2b,81ba      if (Rvip_cyl_quit = 1)  {
8193: 37,d0,24            jnb   B7,Rd0,81ba      if (Cl_thrtl = 1)  {
8196: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
8199: 01,30               clrw  R30              R30 = 0;
819b: b3,fe,07,34         ldb   R34,[Rfe+7]      R34 = PIPsC;
819f: a3,78,1c,1a         ldw   R1a,[R78+1c]     R1a = Viscn1;
81a3: c3,72,6e,1a         stw   R1a,[R72+6e]     Rviprpm = R1a;
81a7: a3,78,1a,42         ldw   R42,[R78+1a]     R42 = Vlamcb;
81ab: c3,73,8a,00,42      stw   R42,[R72+8a]     Lambse1 = R42;
81b0: c3,73,8c,00,42      stw   R42,[R72+8c]     Lambse2 = R42;
81b5: b1,18,38            ldb   R38,18           R38 = 18;
81b8: 27,00               sjmp  80ba             goto 80ba; } }

# Diagnostic proc Table A

  Sub111:
81ba: 99,f0,18            cmpb  R18,f0           
81bd: d1,0a               jleu  81c9             if ((uns) R18 <= f0) return;
81bf: c7,72,4a,00         stb   R0,[R72+4a]      Vip_timer_ex = 0;
81c3: 15,36               decb  R36              R36--;
81c5: d2,02               jgt   81c9             if (R36 > 0) return;
81c7: 25,49               sjmp  7f12             goto 7f12; }
81c9: f0                  ret                    return;


  Sub112:
81ca: 3f,d0,12            jb    B7,Rd0,81df      if (Cl_thrtl = 1) return;
81cd: c7,73,92,00,00      stb   R0,[R72+92]      Vcutout = 0;
81d2: 01,30               clrw  R30              R30 = 0;
81d4: ef,d7,f9            call  7bae             SaveTCode1(77);
81d7: 77                  #args  
81d8: 91,01,2b            orb   R2b,1            Rvip_cyl_quit = 1;
81db: cc,00               pop   R0               R0 = pop();
81dd: 27,6e               sjmp  814d             goto 814d; }
81df: f0                  ret                    return;


  Sub113:
81e0: c3,72,76,00         stw   R0,[R72+76]      Vcb_pip_cnt = 0;
81e4: a3,73,4e,01,1c      ldw   R1c,[R72+14e]    R1c = Prev_PIP_time;
81e9: c3,72,78,1c         stw   R1c,[R72+78]     Vcb_pip_timer = R1c;
81ed: af,73,50,01,1c      ldzbw R1c,[R72+150]    R1c = (uns)Prev_PIP_timeH;
81f2: c3,72,7a,1c         stw   R1c,[R72+7a]     Vcb_pip_htimer = R1c;
81f6: fb                  ei                     enable ints;
81f7: f0                  ret                    return;


  Sub114:
81f8: a3,72,76,1a         ldw   R1a,[R72+76]     R1a = Vcb_pip_cnt;
81fc: a3,73,4e,01,20      ldw   R20,[R72+14e]    R20 = Prev_PIP_time;
8201: af,73,50,01,22      ldzbw R22,[R72+150]    R22 = (uns)Prev_PIP_timeH;
8206: fb                  ei                     enable ints;
8207: 6b,72,78,20         sb2w  R20,[R72+78]     R20 -= Vcb_pip_timer;
820b: bb,72,7a,22         sbbb  R22,[R72+7a]     R22 -= Vcb_pip_htimer - CY;
820f: 8c,1a,20            divw  R20,R1a          R20 /= R1a;
8212: af,fe,07,1a         ldzbw R1a,[Rfe+7]      R1a = (uns)PIPsC;
8216: a3,1b,9c,3d,1e      ldw   R1e,[R1a+3d9c]   R1e = [R1a+3d9c];
821b: a3,1b,a2,3d,1c      ldw   R1c,[R1a+3da2]   R1c = [R1a+3da2];
8220: 8c,20,1c            divw  R1c,R20          R1c /= R20;
8223: c3,72,72,1c         stw   R1c,[R72+72]     Vcbn = R1c;
8227: f0                  ret                    return;
#################################################################
# Tasklist Routine at 2151, routine offset 9A
#################################################################


  Sub115:
8228: 31,ea,05            jnb   B1,Rea,8230      if (Biflg = 1)  {                 # If equal to 1, Brake is on.
822b: 71,fd,d7            an2b  Rd7,fd           Code_74 = 0;
822e: 20,03               sjmp  8233             goto 8233; }
8230: 71,fe,d7            an2b  Rd7,fe           Code_75 = 0;
8233: 34,27,05            jnb   B4,R27,823b      if (Powsfg = 1)  {                # power steering on
8236: 91,08,e6            orb   Re6,8            Powon = 1;
8239: 20,03               sjmp  823e             return; }
823b: 91,04,e6            orb   Re6,4            Powoff = 1;
823e: f0                  ret                    return;
#################################################################
# Check HEGO sensors
# Tasklist Routine at 2151, routine offset 98
#################################################################


  CHk_HEGO:
823f: ef,54,ee            call  7096             Set_EGRFlags();                   # Set up EGR flags
8242: a3,72,4c,32         ldw   R32,[R72+4c]     R32 = Egobar1;                    # OLD average HEGO1
8246: a3,72,9c,34         ldw   R34,[R72+9c]     R34 = EGO1_Raw;                   # NEW value - raw HEGO1
824a: a3,78,02,36         ldw   R36,[R78+2]      R36 = Vtcego;                     # filter factor
824e: ef,12,b4            call  3663             Urolav();                         # filter HEGO1
8251: c3,72,4c,3e         stw   R3e,[R72+4c]     Egobar1 = R3e;                    # save new filtered value
8255: 71,7f,2b            an2b  R2b,7f           Egoste1 = 0;                      # clear HEGO1 cross over voltage detected
8258: 89,c0,d5,3e         cmpw  R3e,d5c0                                           # O2S TRIP VOLTAGE
825c: d1,03               jleu  8261             if ((uns) R3e > d5c0 )  {
825e: 91,80,2b            orb   R2b,80           Egoste1 = 1; }                    # signal HEGO1 voltage cross?
8261: a3,72,4e,32         ldw   R32,[R72+4e]     R32 = Egobar2;                    # OLD average HEGO2
8265: a3,72,9e,34         ldw   R34,[R72+9e]     R34 = EGO2_Raw;                   # NEW value HEGO2 raw
8269: ef,f9,b3            call  3665             Srolav();                         # filter oxygen sensor?
826c: c3,72,4e,3e         stw   R3e,[R72+4e]     Egobar2 = R3e;                    # filtered value (new HEGO2 avg)
8270: 71,bf,2b            an2b  R2b,bf           Egoste2 = 0;                      # clear HEGO2 cross over voltage detected
8273: 89,c0,d5,3e         cmpw  R3e,d5c0                                           # O2S TRIP VOLTAGE
8277: d1,03               jleu  827c             if ((uns) R3e <= d5c0) return;
8279: 91,40,2b            orb   R2b,40           Egoste2 = 1; }                    # signal HEGO2 voltage cross?
827c: f0                  ret                    return;

#################################################################
# CPU test 
# range of 8061 ALU, addressing, push/pop etc.
#################################################################


  HW_Check:
827d: fa                  di                     disable ints;
827e: ff                  nop                    
827f: ff                  nop                    
8280: c3,73,46,01,10      stw   R10,[R72+146]    SvStack = STACK;                  # save old stack ptr
8285: ff                  nop                    
8286: a1,58,00,10         ldw   R10,58           STACK = 58;                       # set new stack pointer
828a: a1,7c,a1,3c         ldw   R3c,a17c         R3c = a17c;
828e: a1,7c,a1,3a         ldw   R3a,a17c         R3a = a17c;
8292: 05,3a               decw  R3a              R3a--;
8294: 88,3a,3c            cmpw  R3c,R3a          
8297: ff                  nop                    
8298: db,03               jc    829d             if ((uns) R3c >= R3a) goto 829d;
829a: 20,e2               sjmp  837e             goto 837e;                        # exit CPU ALU error


829c: f8                                                                           # safety catch ?

829d: d3,fb               jnc   829a             if ((uns) R3c < R3a) goto 829a;
829f: 65,63,75,3c         ad2w  R3c,7563         R3c += 7563;
82a3: db,04               jc    82a9             if ((uns) R3c >= 0) goto 82a9;
82a5: 27,f3               sjmp  829a             goto 829a;


82a7: ff,f8               ??                                                       # safety catch ?

82a9: d3,ef               jnc   829a             if ((uns) R3c < 0) goto 829a;
82ab: f9                  stc                    CY = 1
82ac: 00                  skip                   goto 82ae;


82ad: f8                        

82ae: d3,ea               jnc   829a             if ((uns) R3c < 0) goto 829a;
82b0: a1,e5,4b,3a         ldw   R3a,4be5         R3a = 4be5;
82b4: 64,3a,3c            ad2w  R3c,R3a          R3c += R3a;                       # test ADD
82b7: 89,c4,62,3c         cmpw  R3c,62c4         
82bb: d7,dd               jne   829a             if (R3c != 62c4) goto 829a;
82bd: 09,01,3c            shlw  R3c,1            R3c *= 2;
82c0: 69,63,75,3c         sb2w  R3c,7563         R3c -= 7563;                      # test SHIFT and SUB
82c4: 89,25,50,3c         cmpw  R3c,5025         
82c8: d7,d0               jne   829a             if (R3c != 5025) goto 829a;
82ca: 85,82,b0,3c         xrw   R3c,b082         Word_tmr ^= 1;
                                                 Seconds ^= 1;
                                                 B12_R3c ^= 1;
                                                 B13_R3c ^= 1;
                                                 B15_R3c ^= 1;
82ce: 85,82,b0,3c         xrw   R3c,b082         Word_tmr ^= 1;
                                                 Seconds ^= 1;
                                                 B12_R3c ^= 1;
                                                 B13_R3c ^= 1;
                                                 B15_R3c ^= 1;                     # test XOR
82d2: 89,25,50,3c         cmpw  R3c,5025         
82d6: d7,c2               jne   829a             if (R3c != 5025) goto 829a;
82d8: 61,82,b0,3c         an2w  R3c,b082         Free_run = 0;
                                                 Decrement = 0;
                                                 Inverse = 0;
                                                 B4_R3c = 0;
                                                 Millisecs = 0;
                                                 Eighths = 0;
                                                 B8_R3c = 0;
                                                 B9_R3c = 0;
                                                 B10_R3c = 0;
                                                 B11_R3c = 0;
                                                 B14_R3c = 0;                      # test AND
82dc: 89,00,10,3c         cmpw  R3c,1000         
82e0: d7,b8               jne   829a             if (R3c != 1000) goto 829a;
82e2: 81,31,ce,3c         orw   R3c,ce31         Free_run = 1;
                                                 B4_R3c = 1;
                                                 Millisecs = 1;
                                                 B9_R3c = 1;
                                                 B10_R3c = 1;
                                                 B11_R3c = 1;
                                                 B14_R3c = 1;
                                                 B15_R3c = 1;                      # test OR
82e6: 89,31,de,3c         cmpw  R3c,de31         
82ea: d7,ae               jne   829a             if (R3c != de31) goto 829a;
82ec: b1,31,33            ldb   R33,31           R33 = 31;
82ef: c7,73,0f,02,33      stb   R33,[R72+20f]    Xram2H = R33;
82f4: b1,92,33            ldb   R33,92           R33 = 92;
82f7: 57,73,0f,02,33,32   ad3b  R32,R33,[R72+20f] R32 = R33 + Xram2H;
82fd: 99,c3,32            cmpb  R32,c3           
8300: d7,7c               jne   837e             if (R32 != c3) goto 837e;
8302: b1,7b,30            ldb   R30,7b           R30 = 7b;
8305: b1,c5,32            ldb   R32,c5           R32 = c5;
8308: 5c,30,32,34         ml3b  R34,R32,R30      R34 = R32 * R30;
830c: 89,a7,5e,34         cmpw  R34,5ea7         
8310: d7,6c               jne   837e             if (R34 != 5ea7) goto 837e;
8312: 9c,32,34            divb  R34,R32          R34 /= R32;
8315: 99,7b,34            cmpb  R34,7b           
8318: d7,64               jne   837e             if (R34 != 7b) goto 837e;
831a: 01,30               clrw  R30              R30 = 0;
831c: 01,32               clrw  R32              R32 = 0;
831e: 11,3c               clrb  R3c              R3c = 0;
8320: 0f,3c,30            norm  R0,R3c           R3c = nrml(0);                    # test norml
8323: 99,7b,34            cmpb  R34,7b           
8326: d7,56               jne   837e             if (R34 != 7b) goto 837e;
8328: 99,1f,3c            cmpb  R3c,1f           
832b: d7,51               jne   837e             if (R3c != 1f) goto 837e;
832d: a1,7c,a1,3c         ldw   R3c,a17c         R3c = a17c;
8331: c3,73,0c,02,3c      stw   R3c,[R72+20c]    Xram1L = R3c;
8336: 28,4b               scall 8383             POP_test();                       # stack test - push and pop
8338: 8b,73,0e,02,3c      cmpw  R3c,[R72+20e]    
833d: d7,3f               jne   837e             if (R3c != Xram2L) goto 837e;
833f: 8b,73,10,02,3c      cmpw  R3c,[R72+210]    
8344: d7,38               jne   837e             if (R3c != Xram3L) goto 837e;
8346: 88,30,3c            cmpw  R3c,R30          
8349: d7,33               jne   837e             if (R3c != R30) goto 837e;
834b: a1,00,04,10         ldw   R10,400          STACK = 400;                      # stack to absolute address test locations
834f: a1,75,55,3c         ldw   R3c,5575         R3c = 5575;
8353: c3,73,0c,02,3c      stw   R3c,[R72+20c]    Xram1L = R3c;
8358: 28,29               scall 8383             POP_test();                       # test stack push/pop
835a: 8b,73,0e,02,3c      cmpw  R3c,[R72+20e]    
835f: d7,1d               jne   837e             if (R3c != Xram2L) goto 837e;
8361: 8b,73,10,02,3c      cmpw  R3c,[R72+210]    
8366: d7,16               jne   837e             if (R3c != Xram3L) goto 837e;
8368: 88,30,3c            cmpw  R3c,R30          
836b: d7,11               jne   837e             if (R3c != R30) goto 837e;
836d: b1,aa,30            ldb   R30,aa           R30 = aa;                         # indexed fetch test
8370: c7,73,0f,02,30      stb   R30,[R72+20f]    Xram2H = R30;
8375: a1,8f,03,32         ldw   R32,38f          R32 = Xram2H;
8379: 9a,32,30            cmpb  R30,[R32]        
837c: df,1c               je    839a             if (R30 = [R32]) goto RAM_test;   # OK if equal, run RAM test
837e: 91,10,2a            orb   R2a,10           Disable_nostart = 1;
8381: 20,50               sjmp  83d3             goto 83d3;                        # reset stack ptr, enable ints and return

### push and pop test (called above) ######

  POP_test:
8383: cb,73,0c,02         push  [R72+20c]        push(Xram1L);
8387: cf,73,0e,02         pop   [R72+20e]        Xram2L = pop();
838b: cb,73,0e,02         push  [R72+20e]        push(Xram2L);
838f: cc,30               pop   R30              R30 = pop();
8391: c8,30               push  R30              push(R30);
8393: cf,73,10,02         pop   [R72+210]        Xram3L = pop();
8397: f0                  ret                    return;

# safety catch for push and pop ?



8398: 27,e4               ??    

#############################################################
# memory RAM test from 100 to 8FF
# uses odd and even bit patterns (aaaa and 5555)
 and restores stack at end of test
############################################################



  RAM_test:
839a: a1,ff,08,3a         ldw   R3a,8ff          R3a = 8ff;                        # RAM test start and end addresses
839e: a1,00,01,42         ldw   R42,100          R42 = TP_Filt;
83a2: a1,aa,aa,30         ldw   R30,aaaa         R30 = aaaa;
83a6: a1,55,55,32         ldw   R32,5555         R32 = 5555;
83aa: 95,40,02            xorb  R2,40            CPU_OK ^= 1;
83ad: 17,05               incb  R5               WDG_Timer++;
83af: a2,42,34            ldw   R34,[R42]        R34 = [R42];                      # backup contents of test location
83b2: 95,40,02            xorb  R2,40            CPU_OK ^= 1;
83b5: c2,42,30            stw   R30,[R42]        [R42] = R30;                      # test odd bits
83b8: a2,42,36            ldw   R36,[R42]        R36 = [R42];
83bb: 88,30,36            cmpw  R36,R30          
83be: d7,1a               jne   83da             if (R36 != R30) goto 83da;
83c0: c2,42,32            stw   R32,[R42]        [R42] = R32;                      # test even bits
83c3: a2,42,36            ldw   R36,[R42]        R36 = [R42];
83c6: 88,32,36            cmpw  R36,R32          
83c9: d7,0f               jne   83da             if (R36 != R32) goto 83da;
83cb: c2,43,34            stw   R34,[R42++]      [R42++] = R34;                    # restore contents of test location
83ce: 88,3a,42            cmpw  R42,R3a          
83d1: d3,d7               jnc   83aa             if ((uns) R42 < R3a) goto 83aa;   # loop to end
83d3: a3,73,46,01,10      ldw   R10,[R72+146]    STACK = SvStack;
83d8: fb                  ei                     enable ints;
83d9: f0                  ret                    return;

83da: e7,a1,ff            jump  837e             goto 837e;                        # RAM error

################################################################

  Sub116:
83dd: 35,2b,05            jnb   B5,R2b,83e5      if (Stiflg = 1)  {

  Sub117:
83e0: c3,72,40,00         stw   R0,[R72+40]      Miltmr = 0;
83e4: f0                  ret                    return; }

83e5: 3f,a1,36            jb    B7,Ra1,841e      if (Cranking = 1) goto 841e;
83e8: 51,fa,c5,34         an3b  R34,Rc5,fa       R34 = Fmem_flags & fa;
83ec: d7,16               jne   8404             if (R34 = 0)  {
83ee: b3,72,32,42         ldb   R42,[R72+32]     R42 = C41FIL;
83f2: 9b,78,49,42         cmpb  R42,[R78+49]     
83f6: d9,0c               jgtu  8404             if ((uns) R42 <= C41LVL)  {
83f8: b3,72,3c,42         ldb   R42,[R72+3c]     R42 = C91FIL;
83fc: 9b,78,53,42         cmpb  R42,[R78+53]     
8400: d9,02               jgtu  8404             if ((uns) R42 > C91LVL ) goto 8404;
8402: 20,27               sjmp  842b             goto 842b; } }
8404: a3,79,98,00,40      ldw   R40,[R78+98]     R40 = Fmdtm;                      # timer value for ?
8409: 6b,72,40,40         sb2w  R40,[R72+40]     R40 -= Miltmr;                    # Check Engine LP?
840d: db,1e               jc    842d             if ((uns) R40 >= 0) goto 842d;
840f: 01,42               clrw  R42              R42 = 0;
8411: 8f,79,9c,00,40      divw  R40,[R78+9c]     R40 /= Miltm1;
8416: dd,03               jv    841b             if (OVF = 1) goto Sub118;
8418: 38,40,12            jb    B0,R40,842d      if (B0_R40 = 1) goto 842d;

  Sub118:
841b: e7,8e,f3            jump  77ac             goto Set_STO;                     # tweak flags, set STO on and return
841e: 3c,2a,0a            jb    B4,R2a,842b      if (Disable_nostart = 1) goto 842b; # jump if VIP mode flag : disable no start
8421: 3c,2d,07            jb    B4,R2d,842b      if (First_pip = 1) goto 842b;
8424: 8b,79,9a,00,00      cmpw  R0,[R78+9a]      
8429: d7,05               jne   8430             if (0 = Millim)  {
842b: 2f,b3               scall 83e0             Sub117();
842d: e7,84,f3            jump  77b4             goto Reset_STO; }                 # set STO off flag, set STO output low, and set STO trigger
8430: 2f,e9               scall 841b             Sub118();
8432: 27,ac               sjmp  83e0             goto Sub117;

################################################################
# Diagnostic proc Table A
# jump Table entry 0x71C8
# reset lots of stuff and jump back to cycling thru procs
# switch out of self test to run mode ?
## function/maps/scalars
################################################################

  Sub119:
8434: 3b,d6,4d            jb    B3,Rd6,8484      if (Sto_working = 0)  {
8437: 3a,2b,4a            jb    B2,R2b,8484      if (Sto_trigger = 1) return;
843a: 30,2a,03            jnb   B0,R2a,8440      if (Vscdt = 1)  {
843d: 91,20,2a            orb   R2a,20           Self_test = 1; }
8440: fa                  di                     disable ints;
8441: ff                  nop                    
8442: a1,8c,04,10         ldw   R10,48c          STACK = 48c;                      # force new stack pointer ?
8446: ef,a6,f6            call  7aef             Sub74();                          # Reset Low speed outputs ?
8449: 01,46               clrw  R46              IO_Port_State = 0;                # clear all LSO outputs
844b: 31,2a,03            jnb   B1,R2a,8451      if (Vscst = 1)  {
844e: 91,40,2a            orb   R2a,40           No_start = 1; }
8451: ef,de,9b            call  2032             Reset_All();                      # Reset EEC - init Tables and ports
8454: 30,2a,06            jnb   B0,R2a,845d      if (Vscdt = 1)  {
8457: 71,fe,2a            an2b  R2a,fe           Vscdt = 0;
845a: 91,80,2a            orb   R2a,80           Disable_vscdt = 1; }
845d: 31,2a,0c            jnb   B1,R2a,846c      if (Vscst = 1)  {
8460: 71,bd,2a            an2b  R2a,bd           Vscst = 0;
                                                 No_start = 0;
8463: a1,00,28,42         ldw   R42,2800         R42 = 2800;
8467: c3,01,34,01,42      stw   R42,[R0+134]     Putmr = R42; }                    # Counts up after h/w reset
846c: 35,2a,06            jnb   B5,R2a,8475      if (Self_test = 1)  {             # not self test mode
846f: 71,db,2a            an2b  R2a,db           Vip_enable = 0;
                                                 Self_test = 0;
8472: 91,18,2a            orb   R2a,18           Disable_running = 1;
                                                 Disable_nostart = 1; }
8475: 36,2a,06            jnb   B6,R2a,847e      if (No_start = 1)  {
8478: 71,bb,2a            an2b  R2a,bb           Vip_enable = 0;
                                                 No_start = 0;
847b: 91,10,2a            orb   R2a,10           Disable_nostart = 1; }
847e: ef,33,f3            call  77b4             Reset_STO();                      # Reset STO
8481: e7,cd,9c            jump  2151             goto Backg_loop; }
8484: f0                  ret                    return;

###################################################################
# Handle HSI line 7 data (Ignition Diagnostic Moniter)
###################################################################


  Idm_inth:
8485: 71,7f,87            an2b  R87,7f           Idm_irq = 0;
8488: 37,90,03            jnb   B7,R90,848e      if (B7_Last_HSI = 1)  {
848b: 91,10,4e            orb   R4e,10           New_idm = 1; }
848e: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 1C
#################################################################


  Set_ign_timers:
848f: 37,4e,07            jnb   B7,R4e,8499      if (New_pip = 1)  {
8492: 71,7f,4e            an2b  R4e,7f           New_pip = 0;
8495: c3,72,be,00         stw   R0,[R72+be]      Tslpip = 0; }
8499: 38,2c,0a            jb    B0,R2c,84a6      if (Idm_bypass = 0)  {
849c: 34,4e,07            jnb   B4,R4e,84a6      if (New_idm = 1)  {
849f: 71,ef,4e            an2b  R4e,ef           New_idm = 0;
84a2: c3,72,44,00         stw   R0,[R72+44]      Tslidm = 0; } }
84a6: 36,4e,07            jnb   B6,R4e,84b0      if (New_bap = 0) return;
84a9: 71,bf,4e            an2b  R4e,bf           New_bap = 0;
84ac: c7,72,b6,00         stb   R0,[R72+b6]      Baptmr = 0; }
84b0: f0                  ret                    return;

#############################################################
# Tasklist Routine at 2151, routine offset 0
# On start bit 4 of R24 is set, but this routine clrs it at end so,
# check for and set up calibration console
# copy calibration pointers from 2022 to 00F0
# if 0D00 is 2A, Enconsole is present
# this routine called only at reset
# this routine skips console ck the first time thru, then checks every time
#############################################################


  Check_ConsoleD:
84b1: fa                  di                     disable ints;

  Check_console:
84b2: a3,01,00,0d,14      ldw   R14,[R0+d00]     R14 = [d00];                      # Console status
84b7: 99,2a,15            cmpb  R15,2a           
84ba: d7,2c               jne   84e8             if (R15 = 2a)  {                  # console present?
84bc: 3c,24,1b            jb    B4,R24,84da      if (Console_flag = 0)  {
84bf: 38,0a,18            jb    B0,Ra,84da       if (HSO_OVF = 0)  {
84c2: 47,01,0e,20,06,80   ad3w  R80,R6,[R0+200e] HSO_time = IO_Timer+200e;         # add 5D to current IOTime
84c8: d7,02               jne   84cc             if (HSO_time = 0)  {
84ca: 07,80               incw  R80              HSO_time++; }                     # increment past zero
84cc: c3,01,1a,c1,80      stw   R80,[R0+c11a]    [c11a] = HSO_time;                # to console locaion ?
84d1: a0,80,0e            ldw   Re,R80           HSO_Time = HSO_time;
84d4: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f;                      # request interrupt (in 5D IOtimes)
84d7: ef,2c,4b            call  d006             d006(); } }                       # Console call
84da: a3,01,80,0c,14      ldw   R14,[R0+c80]     R14 = [c80];                      # flags for data pointers
84df: 36,14,06            jnb   B6,R14,84e8      if (Csmode = 1)  {
84e2: a1,00,c2,14         ldw   R14,c200         R14 = c200;                       # use these calibration pointers for console
84e6: 20,09               sjmp  84f1             goto 84f1; } }
84e8: c7,01,00,c0,00      stb   R0,[R0+c000]     [c000] = 0;                       # h/w switch for console?
84ed: a1,22,20,14         ldw   R14,2022         R14 = 2022;                       # calibration Table pointers
84f1: 3c,24,01            jb    B4,R24,84f5      if (Console_flag = 0)  {          # enable ints if console enabled
84f4: fb                  ei                     enable ints; }
84f5: a1,f0,00,18         ldw   R18,f0           R18 = f0;                         # copy int vectors here
84f9: b3,01,20,20,1a      ldb   R1a,[R0+2020]    R1a = [2020];
84fe: a2,15,1c            ldw   R1c,[R14++]      R1c = [R14++];                    # set 8 vectors from 2022 to Rf0 -f8
8501: c2,19,1c            stw   R1c,[R18++]      [R18++] = R1c;
8504: e0,1a,f7            djnz  R1a,84fe         R1a--;
                                                 if (R1a != 0) goto 84fe;          # loop
8507: 3c,24,22            jb    B4,R24,852c      if (Console_flag = 0)  {          # exit
850a: a3,01,f2,1f,42      ldw   R42,[R0+1ff2]    R42 = [1ff2];                     # console value ?
850f: 89,1c,1f,42         cmpw  R42,1f1c                                           # console signature?
8513: d7,17               jne   852c             if (R42 = 1f1c)  {
8515: a1,a5,a5,42         ldw   R42,a5a5         R42 = a5a5;
8519: c3,01,f6,1f,42      stw   R42,[R0+1ff6]    [1ff6] = R42;                     # read/write console ?
851e: 8b,01,f6,1f,42      cmpw  R42,[R0+1ff6]    
8523: d7,07               jne   852c             if (R42 = [1ff6])  {
8525: c9,2c,85            push  852c             push(Sub120);                     # return address
8528: cb,01,f2,1f         push  [R0+1ff2]        push([1ff2]); } } }               # call here if 1FF6 is a R/W register

  Sub120:
852c: 71,ef,24            an2b  R24,ef           Console_flag = 0;
852f: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 22
# EVP something
#################################################################


  Evp_?:
8530: 36,e6,6f            jnb   B6,Re6,85a2      if (Pfehp_flg = 1)  {
8533: b3,01,c0,07,16      ldb   R16,[R0+7c0]     R16 = Kam_flags;
8538: a3,72,b4,14         ldw   R14,[R72+b4]     R14 = Putmr;
853c: 8b,f8,50,14         cmpw  R14,[Rf8+50]     
8540: db,0c               jc    854e             if (R14 > [9480])  {
8542: 71,fd,28            an2b  R28,fd           Ptpflg = 0;
8545: 3f,28,03            jb    B7,R28,854b      if (Kam_error = 1) goto 854b;
8548: 3f,16,03            jb    B7,R16,854e      if (B7_R16 = 0)  {
854b: 91,20,ec            orb   Rec,20           Bpuflg = 1; } }
854e: 3a,a1,09            jb    B2,Ra1,855a      if (Undsp = 0)  {
8551: 9b,f8,56,c8         cmpb  Rc8,[Rf8+56]     
8555: d1,03               jleu  855a             if ((uns) Atmr1 > [9486] )  {
8557: 71,7f,16            an2b  R16,7f           B7_R16 = 0; } }
855a: 35,ec,40            jnb   B5,Rec,859d      if (Bpuflg = 1)  {
855d: 39,28,3d            jb    B1,R28,859d      if (Ptpflg = 0)  {
8560: 8b,f8,52,14         cmpw  R14,[Rf8+52]     
8564: d3,37               jnc   859d             if ((uns) R14 >= [9482])  {
8566: 8b,f8,54,14         cmpw  R14,[Rf8+54]     
856a: d9,31               jgtu  859d             if ((uns) R14 <= [9484])  {
856c: a1,80,a2,3e         ldw   R3e,a280         R3e = a280;
8570: a3,72,96,34         ldw   R34,[R72+96]     R34 = EVP_Raw;
8574: 8b,f3,38,01,34      cmpw  R34,[Rf2+138]    
8579: d1,1d               jleu  8598             if ((uns) R34 > Veptll )  {
857b: 8b,f3,3a,01,34      cmpw  R34,[Rf2+13a]    
8580: db,16               jc    8598             if (R34 > Vepthl)  {
8582: 67,f8,4e,34         ad2w  R34,[Rf8+4e]     R34 += [947e];
8586: d3,03               jnc   858b             if ((uns) R34 >= 0)  {
8588: bd,ff,34            ldsbw R34,ff           R34 = (int)ff; }
858b: a3,01,ee,07,32      ldw   R32,[R0+7ee]     R32 = KEptzer;                    # old filtered EVP
8590: ef,cb,b0            call  365e             Srolav1T(97f0);                   # new value in R34
8593: 48,d0               #args                                                    # filter factor
8595: 91,80,16            orb   R16,80           B7_R16 = 1; } }
8598: c3,01,ee,07,3e      stw   R3e,[R0+7ee]     KEptzer = R3e; } } } }            # new filtered EVP
859d: c7,01,c0,07,16      stb   R16,[R0+7c0]     Kam_flags = R16; }
85a2: f0                  ret                    return;

#############################################################
# Checksum the KAM tables  0x704 - 7AF
#
# Checksum stored at 0x702 (word)  - What is at 7e0 ?
# New checksum is OK if within 1 of saved sum, then updated 
# otherwise tables are cleared (set to 128)
# called only at reset
#############################################################


  Check_Kam_1:
85a3: ad,56,30            ldzbw R30,56           R30 = (uns)56;                    # 86 byte tables
85a6: 01,38               clrw  R38              R38 = 0;                          # start new csum
85a8: af,31,03,07,3a      ldzbw R3a,[R30+703]    R3a = (uns)[R30+KCsumh];          # Table 1
85ad: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
85b0: af,31,59,07,3a      ldzbw R3a,[R30+759]    R3a = (uns)[R30+Ktmtb185];        # Table 2
85b5: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
85b8: e0,30,ed            djnz  R30,85a8         R30--;
                                                 if (R30 != 0) goto 85a8;          # loop
85bb: a3,01,02,07,3a      ldw   R3a,[R0+702]     R3a = KCsuml;                     # current csum
85c0: 68,38,3a            sb2w  R3a,R38          R3a -= R38;
85c3: db,02               jc    85c7             if (R3a > 0)  {
85c5: 03,3a               negw  R3a              R3a = -R3a; }
85c7: 89,01,00,3a         cmpw  R3a,1            
85cb: d9,06               jgtu  85d3             if ((uns) R3a <= 1)  {
85cd: c3,01,02,07,38      stw   R38,[R0+702]     KCsuml = R38;                     # OK, save new csum
85d2: f0                  ret                    return; }

# checksum is bad - Clear tables


  Sub121:
85d3: b1,80,3a            ldb   R3a,80           R3a = 80;                         # set cells to 128
85d6: ad,56,30            ldzbw R30,56           R30 = (uns)56;
85d9: c7,31,03,07,3a      stb   R3a,[R30+703]    [R30+KCsumh] = R3a;               # Table 1
85de: c7,31,59,07,3a      stb   R3a,[R30+759]    [R30+Ktmtb185] = R3a;             # Table 2
85e3: e0,30,f3            djnz  R30,85d9         R30--;
                                                 if (R30 != 0) goto 85d9;
85e6: a1,00,56,38         ldw   R38,5600         R38 = 5600;                       # new csum = (56+56)*128
85ea: c3,01,02,07,38      stw   R38,[R0+702]     KCsuml = R38;                     # save sum
85ef: c7,01,e0,07,00      stb   R0,[R0+7e0]      Kwuctr = 0;
85f4: f0                  ret                    return;

#############################################################
# checksum KAM Table 0x7E4-7EA (7EC is csum) 4 words ?
# clear cells to zero if checksum is off by more than 1
# this routine called only at reset
#############################################################


  Check_Kam_2:
85f5: a1,08,00,30         ldw   R30,8            R30 = 8;
85f9: 01,32               clrw  R32              R32 = 0;
85fb: 67,31,e2,07,32      ad2w  R32,[R30+7e2]    R32 += [R30+Kamqc];               # add words 7E4-7EA
8600: 79,02,30            sb2b  R30,2            R30 -= 2;
8603: d7,f6               jne   85fb             if (R30 != 0) goto 85fb;
8605: 4b,01,ec,07,32,34   sb3w  R34,R32,[R0+7ec] R34 = R32+KIsksum;                # old sum (cksum? )
860b: d6,02               jge   860f             if (R34 < 0)  {
860d: 03,34               negw  R34              R34 = -R34; }
860f: 89,01,00,34         cmpw  R34,1            
8613: d1,0e               jleu  8623             if ((uns) R34 > 1 )  {
8615: a1,08,00,32         ldw   R32,8            R32 = 8;
8619: a1,e4,07,30         ldw   R30,7e4          R30 = KIsckam0L;
861d: c6,31,00            stb   R0,[R30++]       [R30++] = 0;                      # zero cells
8620: e0,32,fa            djnz  R32,861d         R32--;
                                                 if (R32 != 0) goto 861d; }
8623: c3,01,ec,07,32      stw   R32,[R0+7ec]     KIsksum = R32;                    # new csum
8628: f0                  ret                    return;


#############################################################
#  end of routines 
#############################################################


#############################################################
# Initialisation lists
#
# Start of each list has 
# Word 0 - top byte of address for list (bottom byte from each item)
# word 1 - next list START (i.e. end of this list +1)
# then has pairs of bytes -
# byte 0 address  (top byte for list + this byte)
# byte 1 data which is OR'ed into address
#
# addresses are cleared by the loop at 203d
# so this is same as assigning them, except can check result this way
#############################################################



8629: ff                        

862a: 00,00               word      0                                              # high byte address = 0
862c: 50,86               word   8650                                              # next list, and end of this one

862e: ee,04   struct            Flags_ee,  4                                       # start of 1st init list
8630: a1,84   struct            a1_Flags, 84                                       #a1_Flags
8632: 4f,01   struct            Flags_4F,  1                                       #Flags_4F
8634: c1,80   struct             c1, 80                                            #
8636: 9c,01   struct            Anpip1,  1                                         #Anpip1
8638: 9d,01   struct            Anpip2,  1                                         #Anpip2
863a: ae,40   struct            Rpmx4, 40                                          #Rpmx4 = 640 =160rpm
863c: af,06   struct             af,  6                                            #
863e: b0,1e   struct            ECT, 1e                                            #ECT
8640: b1,1e   struct            ACT, 1e                                            #ACT
8642: c2,28   struct            Saf, 28                                            #Saf
8644: dc,01   struct            Pip_counter,  1                                    #Pip_counter
8646: d0,ff   struct            Apt, ff                                            #Apt
8648: c6,01   struct            Dol_count,  1                                      #Dol_count
864a: 46,10   struct            IO_Port_State, 10                                  #IO_Port_State
864c: 47,40   struct            Flags_47, 40                                       #Flags_47
864e: 9b,01   struct            Vsc_count,  1                                      #Vsc_count

8650: 5a,86               word   865a                                              # next list start 
8652: ff,ff               word   ffff
8654: ff,ff               word   ffff
8656: ff,ff               word   ffff
8658: ff,ff               word   ffff
865a: 00,01               word    100                                              # Addresses + 0x100 for this list
865c: 8e,86               word   868e                                              # start of next list 

865e: 00,c0   struct            TP_Filt, c0                                        #TP_Filt = 0x5bc0
8660: 01,5b   struct            101, 5b                                            #
8662: 02,c0   struct            EGR_Filt, c0                                       #EGR_Filt
8664: 03,4c   struct            Ranmul, 4c                                         #Ranmul
8666: 04,80   struct            EPT_Filt, 80                                       #EPT_Filt = 0xa280
8668: 05,a2   struct            105, a2                                            #
866a: 08,40   struct            RPM_Filt1, 40                                      #RPM_Filt1 = 0x640
866c: 09,06   struct            109,  6                                            #
866e: 16,c0   struct            EVP_Raw, c0                                        #EVP_Raw = 0x4cc0
8670: 17,4c   struct            117, 4c                                            #
8672: 26,80   struct            TPS_Min, 80                                        #TPS_Min
8674: 27,3e   struct            127, 3e                                            #
8676: 28,c0   struct            EVP_Def, c0                                        #EVP_Def
8678: 29,4c   struct            129, 4c                                            #
867a: 31,d8   struct            Bapbar, d8                                         #Bapbar
867c: 41,08   struct            Secs_ext,  8                                       #Secs_ext
867e: 52,01   struct            Rannum,  1                                         #Rannum
8680: 53,20   struct            153, 20                                            #
8682: 69,01   struct            169,  1                                            #
8684: 70,c0   struct            Evp, c0                                            #Evp
8686: 71,4c   struct            171, 4c                                            #
8688: 7c,80   struct            Conpr, 80                                          #Conpr
868a: 7d,a2   struct            17d, a2                                            #
868c: fe,d8   struct            Bp, d8                                             #Bp

868e: 98                  word   98                                                # next list
868f: 86                  word   86
8690: ff                  word   ff
8691: ff                  word   ff
8692: ff                  word   ff
8693: ff                  word   ff
8694: ff                  word   ff
8695: ff                  word   ff
8696: ff                  word   ff
8697: ff                  word   ff
8698: 00                  word    0                                                # Addresses + 0x200 for this list
8699: 02                  word    2
869a: ca                  word   ca
869b: 86                  word   86

869c: 0b,80   struct            20b, 80                                            #
869e: 0d,80   struct            20d, 80                                            #
86a0: 11,c8   struct            Vbat, c8                                           #Vbat
86a2: 16,ff   struct            Acctmr, ff                                         #Acctmr
86a4: 17,ff   struct            217, ff                                            #
86a6: 26,99   struct            Htime_beta, 99                                     #Htime_beta
86a8: 27,79   struct            227, 79                                            #
86aa: 2a,80   struct            Tbart, 80                                          #Tbart
86ac: 2b,3e   struct            Spkadv, 3e                                         #Spkadv
86ae: 3a,22   struct            Dwlbst, 22                                         #Dwlbst
86b0: 3b,08   struct            23b,  8                                            #
86b2: 68,01   struct            Enpip1,  1                                         #Enpip1
86b4: 69,01   struct            Enpip2,  1                                         #Enpip2
86b6: 6a,01   struct            Inj_pip_cnt1,  1                                   #Inj_pip_cnt1
86b8: 6b,01   struct            Inj_pip_cnt2,  1                                   #Inj_pip_cnt2
86ba: bb,ff   struct            Tslmph, ff                                         #Tslmph
86bc: b9,0a   struct            Vsc_on_count,  a                                   #Vsc_on_count
86be: c5,03   struct            HSOQ,  3                                           #HSOQ
86c0: d4,ff   struct            Q1, ff                                             #Q1
86c2: e0,ff   struct            Q2, ff                                             #Q2
86c4: ea,ff   struct            Q3, ff                                             #Q3
86c6: f4,ff   struct            Q4, ff                                             #Q4
86c8: fe,ff   struct            Q5, ff                                             #Q5

86ca: d4,86               word   86d4
86cc: ff,ff               word   ffff
86ce: ff,ff               word   ffff
86d0: ff,ff               word   ffff
86d2: ff,ff               word   ffff
86d4: 00,03               word    300                                              # Addresses + 0x300 for this list
86d6: e6,86               word   86e6

86d8: 08,ff   struct            Q6, ff                                             #Q6
86da: 12,ff   struct            Q7, ff                                             #Q7
86dc: 1c,ff   struct            Q8, ff                                             #Q8
86de: 22,ff   struct            Q9, ff                                             #Q9
86e0: c3,19   struct            3c3, 19                                            #
86e2: c0,6c   struct            Min_pip_dly, 6c                                    #Min_pip_dly
86e4: c1,05   struct            3c1,  5                                            #

86e6: ff,ff               word   ffff                                              # end of all lists



## 86e8 to 8aff = 0xff  (filler ?) ## 



8b00: ff,ff               word   ffff



## 8b02 to 8bff = 0xff  (filler ?) ## 



######################### Reg 0xF0 points here (8c00)

8c00: 5a,8e               word   8e5a                                              # pointer to next block (RF2)
8c02: 80,3e               word   3e80                                              # default/start value for filtered TP (Throttle)
8c04: 54,00               word     54
8c06: fa,00               word     fa                                              # Heated Windscreen Transition Time Threshold
8c08: e8,03               word    3e8                                              # Heated Windscreen Recognition Time Threshold - HWRT
8c0a: 48,01               word    148            Ssfctr                            # Steady State Factor -  Used in MKAY and signature KAY calculations.
8c0c: 60,3b               word   3b60                                              # Shift Indicator Light Timer Enable RPM - SPTRPM
8c0e: 20,4e               word   4e20                                              # Shift Indicator Light RPM -  Shift indicator light is turned on at this rpm regardless of any o
                                                                                   ther condition evaluations. 

8c10: 0c                  byte    c                                                # time before shift light turned on (1/8 sec = 1.5 secs)
8c11: 20                  byte   20                                                # time before shift light turned off (= 4 secs)
## Min PIP periods 4,6,8 cyls - at 6500rpm ? - (ref 3e67)
# RPM at which the PIP signal is regarded as unreliable. Set slightly higher than Rev Limit Half Fuel On.

8c12: 83,07               word    783                                              # 4.615mS - 4 cyl  
8c14: 02,05               word    502                                              # 3.076mS - 6 cyl
8c16: c1,03               word    3c1            Min_pip                           # 2.306ms - 8 cyl (min pip period, = 6250000/rpm)

# Fuel Forward Lambda Decrement Time

8c18: 7f,19   func               127, 25
8c1a: 23,19   func                35, 25
8c1c: 1e,2d   func                30, 45
8c1e: 80,2d   func              -128, 45
8c20: 80,2d   func              -128, 45
8c22: 80,2d   func              -128, 45
8c24: 80,2d   func              -128, 45

# Time Before Drive - FN394F

8c26: 7f,03   func               127,  3
8c28: 80,03   func              -128,  3
8c2a: 80,03   func              -128,  3
8c2c: 80,03   func              -128,  3
8c2e: 80,03   func              -128,  3
8c30: 80,03   func              -128,  3
8c32: 80,03   func              -128,  3

# Shift Indicator Light RPM vs ECT - FN651


  Fn651:
8c34: ff,7f,00,00   func         32767,    0
8c38: 55,00,00,00   func            85,    0
8c3c: 41,00,a0,0f   func            65, 4000
8c40: 00,80,a0,0f   func        -32768, 4000
8c44: 00,80,a0,0f   func        -32768, 4000
8c48: 00,80,a0,0f   func        -32768, 4000
8c4c: 00,80,a0,0f   func        -32768, 4000

# Shift Indicator Light RPM vs Load - FN652A


  Fn652A:
8c50: ff,ff,80,3e   func        65535,16000
8c54: 9a,59,80,3e   func        22938,16000
8c58: 33,33,10,27   func        13107,10000
8c5c: 9a,19,00,1e   func         6554, 7680
8c60: 00,00,00,1e   func            0, 7680
8c64: 00,00,00,1e   func            0, 7680
8c68: 00,00,00,1e   func            0, 7680
8c6c: 00,00,00,1e   func            0, 7680
8c70: 00,00,00,1e   func            0, 7680
8c74: 00,00,00,1e   func            0, 7680

# BAP Transfer


  Bapxfr:
8c78: ff,ff,d1,f7   func        65535,63441
8c7c: 41,a2,d1,f7   func        41537,63441
8c80: 56,8a,75,b8   func        35414,47221
8c84: d8,74,a3,78   func        29912,30883
8c88: 00,00,a3,78   func            0,30883
8c8c: 00,00,a3,78   func            0,30883

# Startup Fuel Scaler for Time


  Fn018:
8c90: ff,70   func              255,112
8c92: 2d,70   func               45,112
8c94: 0f,40   func               15, 64
8c96: 0a,30   func               10, 48
8c98: 06,20   func                6, 32
8c9a: 00,00   func                0,  0
8c9c: 00,00   func                0,  0

##### Accel Enrichment Fuel Scaler for Throttle Rate


  Fn019B:
8c9e: ff,70   func              255,112
8ca0: f4,70   func              244,112
8ca2: 22,00   func               34,  0
8ca4: 00,00   func                0,  0
8ca6: 00,00   func                0,  0

##### Accel Enrichment Fuel Scaler for ECT/ACT


  Fn020B:
8ca8: 7f,60   func               127, 96
8caa: 7d,60   func               125, 96
8cac: e7,00   func               -25,  0
8cae: 80,00   func              -128,  0
8cb0: 80,00   func              -128,  0

################ Func: EEC Load Scaling
# Table - emission load scaling. Spark, MAF Backflow Scaler for Load 
# Scale: 256.0 Offset: 0.0 Math: 1
# Scale: 32768.0 Offset: 0.0 Math: 1
# X: Raw Load
# Y: Table Row Pointer
#################


  Emm_lscale:
8cb2: ff,ff,00,07   func        65535, 1792
8cb6: 00,60,00,07   func        24576, 1792
8cba: cd,4c,00,06   func        19661, 1536
8cbe: cd,0c,00,01   func         3277,  256
8cc2: 66,06,00,00   func         1638,    0
8cc6: 00,00,00,00   func            0,    0
8cca: 00,00,00,00   func            0,    0

8cce: 00,00,00,00               

# Startup Fuel Scaler for ECT/ACT 


  Ectflscale:
8cd2: 7f,90   func               127,144
8cd4: 78,90   func               120,144
8cd6: f1,00   func               -15,  0
8cd8: 80,00   func              -128,  0
8cda: 80,00   func              -128,  0
8cdc: 80,00   func              -128,  0

#################################
# RPM scaling table
# Spark, Injector Timing, MAF Backflow Scaler for RPM 
# Table 8CDE Engine speed rpm scaler 0-9 for tables
# 4000 RPM up = 9, 3000 RPM = 8, 1500 RPM = 5, 500 RPM = 0
#################################


  Rpmscale:
8cde: ff,ff,00,09   func        65535, 2304
8ce2: 80,3e,00,09   func        16000, 2304
8ce6: e0,2e,00,08   func        12000, 2048
8cea: 70,17,00,05   func         6000, 1280
8cee: d0,07,00,00   func         2000,    0
8cf2: 00,00,00,00   func            0,    0
8cf6: 00,00,00,00   func            0,    0

########## Table - Spark load scaling
# Emissions & Spark Scaler for Load 


  Ldscale:
8cfa: ff,ff,00,07   func        65535, 1792
8cfe: 00,60,00,07   func        24576, 1792
8d02: cd,4c,00,06   func        19661, 1536
8d06: cd,0c,00,01   func         3277,  256
8d0a: 66,06,00,00   func         1638,    0
8d0e: 00,00,00,00   func            0,    0
8d12: 00,00,00,00   func            0,    0

########## Table - fuel load scaling
# Base Fuel Scaler for Load 


  Fn072A:
8d16: ff,ff,70,00   func        65535,  112
8d1a: 33,73,70,00   func        29491,  112
8d1e: 9a,59,50,00   func        22938,   80
8d22: 33,33,30,00   func        13107,   48
8d26: 33,13,10,00   func         4915,   16
8d2a: 9a,09,00,00   func         2458,    0
8d2e: 00,00,00,00   func            0,    0

# Fuel & EGR Scaler for Load.


  Fn082:
8d32: ff,ff,00,02   func        65535,  512
8d36: 8f,42,00,02   func        17039,  512
8d3a: 7b,24,00,01   func         9339,  256
8d3e: ae,17,00,00   func         6062,    0
8d42: 00,00,00,00   func            0,    0

# Fuel & EGR Scaler for RPM.


  Fn083:
8d46: ff,ff,00,03   func        65535,  768
8d4a: 40,1f,00,03   func         8000,  768
8d4e: 10,0e,00,00   func         3600,    0
8d52: 00,00,00,00   func            0,    0

# A/C Time Delay vs TP


  Fn087:
8d56: ff,ff,ff,00   func        65535,  255
8d5a: 00,8c,ff,00   func        35840,  255
8d5e: 00,8c,00,00   func        35840,    0
8d62: 00,00,00,00   func            0,    0
8d66: 00,00,00,00   func            0,    0
8d6a: 00,00,00,00   func            0,    0

# Fuel C/L Ramp Rate - FN339


  Fn339:
8d6e: ff,ff   func              255,255
8d70: cd,c8   func              205,200
8d72: 9a,a2   func              154,162
8d74: 58,80   func               88,128
8d76: 00,80   func                0,128

# Fuel C/L Jump to Bias - FN342


  Fn342:
8d78: ff,00   func              255,  0
8d7a: 58,00   func               88,  0
8d7c: 33,22   func               51, 34
8d7e: 1a,40   func               26, 64
8d80: 0a,59   func               10, 89
8d82: 05,65   func                5,101
8d84: 00,80   func                0,128

# Fuel C/L Jump From Bias - FN344


  Fn344:
8d86: ff,5b   func              255, 91
8d88: e6,5b   func              230, 91
8d8a: 9a,6e   func              154,110
8d8c: 58,80   func               88,128
8d8e: 00,80   func                0,128

# Ignition Expected Pips - FN346


  Fn346:
8d90: ff,f3   func              255,243
8d92: e6,f3   func              230,243
8d94: cd,7a   func              205,122
8d96: b3,52   func              179, 82
8d98: 9a,3e   func              154, 62
8d9a: 80,32   func              128, 50
8d9c: 57,27   func               87, 39
8d9e: 1a,19   func               26, 25
8da0: 05,14   func                5, 20
8da2: 00,10   func                0, 16
8da4: 00,10   func                0, 16

# Fuel Accel Enrichment vs BP - FN378


  Fn378:
8da6: ff,80   func              255,128
8da8: f0,80   func              240,128
8daa: e0,70   func              224,112
8dac: a0,50   func              160, 80
8dae: 00,40   func                0, 64

############## ECT or ACT A/D to degrees F
# ECT/ACT Transfer -  Input is a rough hi byte only conversion.


  Fn703A:
8db0: ff,ec   func              255, -20
8db2: e8,ec   func              232, -20
8db4: e0,fb   func              224,  -5
8db6: d1,0a   func              209,  10
8db8: b8,17   func              184,  23
8dba: 49,43   func               73,  67
8dbc: 25,5a   func               37,  90
8dbe: 14,6f   func               20, 111
8dc0: 0d,7f   func               13, 127
8dc2: 00,7f   func                0, 127


  Fn825A:
8dc4: 7f,06   func               127,  6                                           # ISC Adder vs ECT - FN825A
8dc6: 6e,06   func               110,  6
8dc8: 67,00   func               103,  0
8dca: 5a,00   func                90,  0
8dcc: 50,09   func                80,  9
8dce: 37,09   func                55,  9
8dd0: f3,29   func               -13, 41
8dd2: 80,29   func              -128, 41


  Fn825B:
8dd4: 7f,09   func               127,  9                                           # ISC Adder vs ACT - FN825B
8dd6: 71,09   func               113,  9
8dd8: 64,06   func               100,  6
8dda: 58,00   func                88,  0
8ddc: 80,00   func              -128,  0
8dde: 80,00   func              -128,  0
8de0: 80,00   func              -128,  0

#############################################################
# Func: MAF Transfer function (volts => Kg per hr)
# Scale: 4.0 Offset: 0.0 Math: 1
# Scale: 4096.0 Offset: 0.0 Math: 1
# X: MAF Voltage
# Y: Mass Flow Kg/hr MAF Transfer - FN036
#############################################################


  Maf_tfr:
8de2: ff,ff,4d,0a   func        65535, 2637
8de6: 4a,4c,4d,0a   func        19530, 2637
8dea: 17,47,93,08   func        18199, 2195
8dee: d5,42,59,07   func        17109, 1881
8df2: 2d,3e,29,06   func        15917, 1577
8df6: b4,38,ec,04   func        14516, 1260
8dfa: ae,35,49,04   func        13742, 1097
8dfe: 62,32,a5,03   func        12898,  933
8e02: 8f,2e,00,03   func        11919,  768
8e06: 1b,2b,7d,02   func        11035,  637
8e0a: 50,29,40,02   func        10576,  576
8e0e: 33,27,fd,01   func        10035,  509
8e12: 0e,25,c1,01   func         9486,  449
8e16: 77,22,7b,01   func         8823,  379
8e1a: d3,1f,3c,01   func         8147,  316
8e1e: 3d,1e,1d,01   func         7741,  285
8e22: d9,1c,04,01   func         7385,  260
8e26: 0e,1b,e6,00   func         6926,  230
8e2a: 2f,19,c5,00   func         6447,  197
8e2e: 7d,17,ab,00   func         6013,  171
8e32: 23,15,8d,00   func         5411,  141
8e36: e9,12,74,00   func         4841,  116
8e3a: 75,11,67,00   func         4469,  103
8e3e: 25,0e,4b,00   func         3621,   75
8e42: 00,0c,3b,00   func         3072,   59
8e46: 23,09,2b,00   func         2339,   43
8e4a: 00,00,2b,00   func            0,   43
8e4e: 00,00,2b,00   func            0,   43
8e52: 00,00,2b,00   func            0,   43
8e56: 00,00,2b,00   func            0,   43

################################################### RF2 points here (8e5a)


8e5a: d6,8f               word   8fd6                                              # next register value (RF4)

8e5c: 00                  byte    0              Bfulsw

8e5d: ff                        

8e5e: 00,20               word   2000            Fkskay
8e60: 00,a0               word   a000            Sigkll
8e62: 55,d5               word   d555            Sigklu
8e64: 00,83               word   8300            Thbpsc
8e66: 00,06               word    600            Thbpsh
8e68: 20,4e               word   4e20            Niac
8e6a: d0,07               word    7d0            Niach                             # RPM IAC Hysterysis - "
8e6c: 80,0c               word    c80            Debamp
8e6e: 00,0c               word    c00            Hi_off
8e70: 00,e6               word   e600            Low_on
8e72: c0,0c               word    cc0            Lcoast
8e74: 80,2f               word   2f80            Hcoast
8e76: 40,38               word   3840            Laccel
8e78: 00,5d               word   5d00            Haccel
8e7a: 80,62               word   6280            Lresum
8e7c: c0,91               word   91c0            Hresum
8e7e: 40,92               word   9240            Lohold
8e80: 00,c7               word   c700            Hihold
8e82: 91,01               word    191            Dcbias
8e84: b8,1e               word   1eb8            Setgn
8e86: cd,2c               word   2ccd            Vehgn
8e88: c3,04               word    4c3            Tapgn
8e8a: 29,00               word     29            Debtim
8e8c: 00,32               word   3200            Minvsp
8e8e: 00,c8               word   c800            Maxvsp
8e90: 80,57               word   5780            Vsnmax
8e92: 00,14               word   1400            Mphded
8e94: 00,02               word    200            Mphh
8e96: 00,06               word    600            Aclded
8e98: 00,03               word    300            Aclinc
8e9a: 00,01               word    100            Hldref

8e9c: fe                  byte   fe              Vsmpg                             # MFA MPH Min -  Minimum speed to remain in MFA mode.
8e9d: 0a                  byte    a              Vsmpgh                            # MFA MPH Hysterysis - VSMPGH
8e9e: 26                  byte   26              Hldrng                            # VSS Error Deadband -  No pulses required at this speed
8e9f: b0                  byte   b0              Lowbat                            # SCCS Low Battery - LOWBAT
8ea0: 32                  byte   32              Vscfrq                            # VSS Frequency - VSCFRQ
8ea1: 01                  byte    1              Vstype                            # MPH Sensor Present -  0 = no sensor, 1 = mph sensor, 2 = mph sensor and cruise control
8ea2: 0d                  byte    d              Dasmph                            # ISC Dashpot Min MPH - DASMPH
8ea3: 04                  byte    4              Dasmhyst                          # ISC Dashpot Hysteresis For MPH - DASMHYST

8ea4: 80,01               word    180            Dasmin                            # ISC Min Daspot Clip For Declutch - DASMIN

8ea6: 03                  byte    3              Mfmhys                            # Managed Failure Mode Hysteresis - MFMHYS
8ea7: 01                  byte    1              Vairfl
8ea8: 01                  byte    1              Vtabfl

8ea9: ff                        

8eaa: 78,00               word     78            Vipspk                            # VIP Spark
8eac: 00,32               word   3200            Vkypwr
8eae: 66,06               word    666            Viprr1
8eb0: 33,03               word    333            Viplr1
8eb2: 10,0e               word    e10            Vnmin                             # HEGO Test Min RPM


  Vdly8:
8eb4: 00,ff               ??    

8eb6: 00,19               word   1900            Vtap1                             # VTAP1 - VTAP1
8eb8: 80,3e               word   3e80            Vtap2                             # VTAP2 - VTAP2
8eba: 00,19               word   1900            Vtap3                             # VTAP3 - VTAP3
8ebc: 80,3e               word   3e80            Vtap4                             # VTAP4 - VTAP4
8ebe: 00,64               word   6400            Vtap5                             # VTAP5 - VTAP5
8ec0: 80,57               word   5780            Vtap6
8ec2: 00,0a               word    a00            Actmin                            # ACT min  (checked in 38A1 and 7XXX)
8ec4: c0,e9               word   e9c0            Actmax                            # ACT max

8ec6: 3c                  byte   3c              Vect5

8ec7: ff                        

8ec8: 80,f7               word   f780            Tapmax                            # TPS Max - TAPMAX
8eca: 00,0a               word    a00            Tapmin                            # TPS Min - TAPMIN

8ecc: c8                  byte   c8              Wiglvl
8ecd: 01                  byte    1              V_fpmflg

8ece: 10,08               word    810            V_fpmdly

8ed0: 10                  byte   10              Vidmst                            # VIDMST 

8ed1: ff                        

8ed2: 82,00               word     82            Vidmtm
8ed4: d0,07               word    7d0            Vlorpm
8ed6: 5a,00               word     5a            Vpiptm
8ed8: 00,0a               word    a00            Ectmin                            # ECT min
 # ECT range low

################################################### R78 points here (8eda - why not use Rf2 ?)
8eda: c0,e9               word   e9c0            Ectmax                            # ECT range high
 # ECT max 
8edc: 00,05               word    500            Vtcego

8ede: 78                  byte   78              Goosec                            # Goose C


  Goosmp:
8edf: 50                        

8ee0: 40,06               word    640            Goosn                             # Goose RPM
8ee2: a8,00               word     a8            Goospk
8ee4: 00,32               word   3200            Goostp                            # Goose TP - Min throttle voltage delta for goose.

8ee6: 00                  byte    0              Goosw
8ee7: 14                  byte   14              Vkts
8ee8: 00                  byte    0              Vdisfm

8ee9: ff                        

8eea: 00,0b               word    b00            Vtcdsn

8eec: 01                  byte    1              Vbisw                             # VBISW

8eed: ff                        

8eee: 7b,04               word    47b            Vcbclp
8ef0: 48,01               word    148            Vcbpad
8ef2: ec,01               word    1ec            Vcbpct                            # VCBPCT
8ef4: 33,73               word   7333            Vlamcb
8ef6: c2,00               word     c2            Viscn1
8ef8: b0,01               word    1b0            Vcbdly                            # VCBDLY
8efa: 30,30               word   3030            Visdl4
8efc: 18,18               word   1818            Vcbtm1
8efe: 01                  byte    1              Vegobp                            # VEGOBP

8eff: 08                  byte    8              Vegosw                            # VIP EGO Switch Required
8f00: f0                  byte   f0              Vegotm                            # VIP EGO Time
8f01: 0a                  byte    a              Vptcnt                            # VPTCNT -
8f02: 10                  byte   10              Vectmr
8f03: 6d                  byte   6d              Vcrtdc
8f04: 09                  byte    9              Vegrat
8f05: 20                  byte   20              Vdcmin
8f06: 6d                  byte   6d              Vdcmax

8f07: ff                        

8f08: cd,2c               word   2ccd            Vegrload
8f0a: 00,0a               word    a00            Evpmin                            # EVP min
8f0c: 40,f6               word   f640            Evpmax                            # EVP max
8f0e: 00,0f               word    f00            Vevpll
8f10: 80,22               word   2280            Vevphl
8f12: 00,14               word   1400            Vevpdl
8f14: 00,28               word   2800            Vevpcl

8f16: 10                  byte   10              Veitmr

8f17: 10,10               word   1010            Vdledf
8f19: 50                  byte   50              Vlfntm

8f1a: 78                  byte   78              Vhfntm


  C14LVL:
8f1b: c8,c8,fe,c8,fe,c8,fe,c8 ??                                                   # Error 33 Threshold -  EGR did not flow

8f23: c8                  byte   c8              C41LVL


  C51LVL:
8f24: c8,c8,c8,c8,c8,c8,c8,c8,c8                                                   # Error 54 Threshold -  ACT high
 # Error 87 Threshold -  Fuel pump circuit fault

8f2d: c8                  byte   c8              C91LVL                            # Error 91 Threshold -  Lack of left HEGO switching.


  C95LVL:
8f2e: c8,c8,c8,64,64,0a,64,14 ??                                                   # Error 22 Up Count -  BAP sensor out of range.

  C33UP:
8f36: 0a,14,64,64,64,64,64,14 ??                                                   # Error 35 Up Count -  EVP input high

  C61UP:
8f3e: 64,64,64,14,ff,64,64,64 ??                                                   # Error 61 Up Count -  ECT low
 # Error 91 Up Count -  Lack of left HEGO switching.
 # Error 95 U
                                                                                   p Count -  Fuel pump open circuit

  Idmup:
8f46: 32,ff               ??    

8f48: 40,b3               word   b340            Viact1
8f4a: c0,0f               word    fc0            Viact2
8f4c: 40,be               word   be40            Viact3
8f4e: c0,0f               word    fc0            Viact4
8f50: 40,b3               word   b340            Viect1
8f52: c0,0f               word    fc0            Viect2
8f54: c0,3a               word   3ac0            Viect3
8f56: c0,0f               word    fc0            Viect4

8f58: 4b                  byte   4b              Vect3                             # warm up /Normal temp thrshhold ?
8f59: 05                  byte    5              Filhys

8f5a: 33,73               word   7333            Vrlam2
8f5c: b0,04               word    4b0            Vbpdl1
8f5e: f7,06               word    6f7            Vbpdl2
8f60: 28,00               word     28            Vmafpiplmt
8f62: 00,2d               word   2d00            Vmafo1
8f64: 40,1f               word   1f40            Vmafr1
8f66: c0,5d               word   5dc0            Vmafr2
8f68: 00,f5               word   f500            Maxmaf                            # max MAF voltage (mass air max) 
8f6a: c0,12               word   12c0            Vmamin                            # min MAF voltage (mass air min)
8f6c: 50,46               word   4650            Vmarpm                            # Max RPM (4500) for MAF Max Voltage Test 
8f6e: cd,0c               word    ccd            Vsload

8f70: 9a                  byte   9a              Vbpmax

8f71: ff                        

8f72: 00,00               word      0            Fmdtm                             # MIL Delay Time. delay before turning light on after fault detected.
8f74: 08,00               word      8            Millim
8f76: 00,00               word      0            Miltm1                            # MIL Freq.  The light will flash at frequency =  1 / (2 * MILTM1).


  Vnd1:
8f78: 00,00,00,80,80,07,80,07 ?? 
# next limits are the min that Open Circuit Check needs to see when line toggles, else circuit is faulty
 # AM1 Open Circuit Check.
 # AM2 Open Circuit Check.

  Occdt3:
8f80: 00,00,80,07,80,07,80,07 ??                                                   # High Speed Fan Open Circuit Check.
 # EVR Open Circuit Check.
 # Canister Purge Open Circuit Ch
                                                                                   eck.
 # Fuel Pump Open Circuit Check.

  Occdt8:
8f88: 00,00,40,06,40,06   ??                                                       # Low Speed Fan Open Circuit Check.
 # SCVNT Open Circuit Check.

8f8e: 00,0a               word    a00            Eptmin


  Eptmax:
8f90: 40,f6               ??    

8f92: 80,98               word   9880            Veptll
8f94: 00,b4               word   b400            Vepthl
8f96: c0,99               word   99c0            Veptrl


  Veptrh:
8f98: 80,d4               ??    

8f9a: 40,97               word   9740            Veptil


  Veptih:
8f9c: 80,d4               ??    

8f9e: 00,14               word   1400            Veptdl
8fa0: 00,96               word   9600            Veptcl
8fa2: a0,0f               word    fa0            Vn                                # Max Idle RPM for EPT Test
8fa4: 1a,00               word     1a            Vtcept

8fa6: 00                  byte    0              Vpssw

8fa7: ff                        

8fa8: 58,02               word    258            Vsprpm
8faa: 78,00               word     78            Vspadv
8fac: 14,00               word     14            Vspret

8fae: 01                  byte    1              Vspten

8faf: 28,08               word    828            Vsptdl
8fb1: 18,50               word   5018            Vdly2
8fb3: 50,e5               word   e550            Vatmr2
8fb5: 00,e5               word   e500
8fb7: 00,8f               word   8f00
8fb9: 02,00               word      2
8fbb: 06,00               word      6
8fbd: 78,9a               word   9a78
8fbf: 04,a0               word   a004
8fc1: a0,50               word   50a0            Vipt2
8fc3: 78                  byte   78              Vdly10


  Vdly11:
8fc4: 18,ff               ??    

8fc6: 00,05               word    500            Vtpld
8fc8: 00,05               word    500            Vtplu
8fca: 26,01               word    126            Vdcbia

8fcc: f0                  byte   f0              Vvscet


  Vsmapl:
8fcd: 38                        

8fce: 60,22               word   2260            Vsamin
8fd0: 70,17               word   1770            Vsmmin

8fd2: 0a                  byte    a              Vssmn1
8fd3: 01                  byte    1              Vsssw
8fd4: 18                  byte   18              Vsstim

8fd5: ff                        

############## RF4 points here (8fd6) #####################################

8fd6: a8,93               word   93a8

8fd8: 4b                  byte   4b              Mfatm3


  Mfatm2:
8fd9: bd,00,00,bd         ??    

8fdd: 01                  byte    1              Mfasw                             # Allow MFA fuel economy mode strategy if set.
8fde: 00                  byte    0              Cintsw                            # Enable Special Injector Timing In Neutral
8fdf: 74                  byte   74              Cintv                             # Injector Timing Value in Neutral
8fe0: 7f                  byte   7f              Cthin                             # Maximum ECT at cold start to use open loop fuel multiplier.
8fe1: 7b                  byte   7b              Numpr                             # O/L Fuel Startup Neutral Multiplier
8fe2: 26                  byte   26              Olmtd1                            # O/L Fuel Multiplier Time Delay
8fe3: ff                  byte   ff              Agb                               # Fuel Shut Off Deceleration Time Delay

8fe4: c0,5d               word   5dc0            Mfanlo                            # MFA State Min RPM
8fe6: e8,1c               word   1ce8            Mfanhi                            # MFA State Max RPM
8fe8: 90,01               word    190            Mfasn                             # MFA State Constant RPM Entry Condition
8fea: 00,80               word   8000            Mfalh                             # MFA State Max Load Condition

8fec: 64                  byte   64              Swtcnt                            # MFA State EGO Switch Requirement

8fed: ff                        

8fee: 20,03               word    320            Mfanhh                            # MFA State Max RPM Hysterysis
8ff0: 90,01               word    190            Mfanlh                            # MFA State Min RPM Hysterysis
8ff2: 00,80               word   8000            Mfall                             # MFA State Min Load
8ff4: 66,66               word   6666            Mfalhh                            # MFA State Max Load Condition Hysterysis

8ff6: d0                  byte   d0              Mpmnbp                            # MFA Min BP for Fuel Economy Mode
8ff7: 0a                  byte    a              Mpnbph                            # MFA Min BP for Fuel Economy Hysterysis
8ff8: 0d                  byte    d              Mfarmp                            # MFA Ramp Increment

8ff9: ff                        

8ffa: 01,00               word      1            Injref                            # Injection Timing Pulse Edge -  0 = Use rising edge, 1 = Use falling  edge
8ffc: 00,80               word   8000            Idkmul                            # Injector delay timing multiplier
8ffe: 00,00               word      0            Inj_dly                           # injector delay global

9000: 00                  byte    0              Alpha

9001: ff                        

9002: 33,00               word     33            Gaclmult                          # global accel pump multiplier


  Aeflag:
9004: 01,ff               ??    

9006: c0,ff               word   ffc0            Tpdlta                            # Fuel Accel Min TP Delta -  Conversion wrong.
9008: df,ff               word   ffdf            Aeacld                            # Delta Load for Intake Manifold Filling - AEACLD

900a: 14                  byte   14              Aetar
900b: 00                  byte    0              Frctae
900c: 4d                  byte   4d              Kft                               # Fuel Transient Comp Multiplier

900d: ff                        

900e: 20,03               word    320            Tfsmn                             # Fuel Transient Min RPM Idle - TFSMN

9010: 03                  byte    3              Tfctm
9011: 02                  byte    2              Mteisf                            # Fuel Equilib Intake Surf Multiplier - MTEISF
9012: 10                  byte   10              Mteftc                            # Fuel Time Constant Multiplier - MTEFTC
9013: 01                  byte    1              Tfcisw                            # Fuel Transient Compenstation - TFCISW
9014: 9a                  byte   9a              Meftra                            # Fuel Decel Multuplier - MEFTRA
9015: 80                  byte   80              Meftrd

9016: 1a,00               word     1a            Tfcded
9018: 00,00               word      0            Archlk
901a: 4a,1b               word   1b4a            Engdisp                           # Engine displacement 1B4A = 6986 (unit = 0.0430981 Cubic Inches)
901c: 64,3b               word   3b64            Low_slope                         # low injector slope (unit = 0.00171662 lbs/hr)
901e: b2,2c               word   2cb2            Hi_slope                          # high injector slope (unit = 0.00171662 lbs/hr)
9020: 00,00               word      0            Faminc
9022: 7e,00               word     7e            Kpsinu                            # ISC Gain For Underspeed in Neutral. 
9024: 7e,00               word     7e            Kpsind                            # ISC Gain For Overspeed in Neutral. 
9026: 7e,00               word     7e            Kpsidu                            # ISC Gain For Underspeed in Drive. 
9028: 7e,00               word     7e            Kpsidd                            # ISC Gain For Overspeed in Drive. 
902a: 66,06               word    666            Psibrm                            #  and gain modulator, used as input in IPSIBR calculation.
902c: 9a,f9               word   f99a            Psibrn                            #  and gain modulator, used as input in IPSIBR calculation.
902e: cd,08               word    8cd            Ithbma                            # Throttle Body Air Flow
9030: cd,00               word     cd            Debycp                            # ISC Min Airflow 
9032: c3,f5               word   f5c3            Dasptk                            # ISC Gain Associated With The Desired DASPOT Airflow
9034: cd,00               word     cd            Daspto                            # ISC Offset term applied to the DASPOT calculation
9036: 40,03               word    340            Delhys                            # ISC TP Hysterysis
9038: 58,02               word    258            Rpmctl                            # ISC RPM Control Adder -  Added to desired idle rpm as part of evaluating if ISC C/L rpm control
                                                                                    is allowed
903a: f0,0f               word    ff0            Ndif                              # ISC RPM Deviation Allowed Over ISC Time

903c: 08                  byte    8              Minmph                            # ISC Min Speed To Enter C/L RPM Control

903d: ff                        

903e: 64,00               word     64            Rpmded                            # ISC RPM Deadband
9040: 40,03               word    340            Delrat                            # ISC Throttle Position Adder

9042: 02                  byte    2              Samrat                            # Airmass Filter Sample Rate
9043: 04                  byte    4              Isctm                             # ISC Time Interval The Change In RPM Is Evaluated
9044: 00                  byte    0              Lowlod
9045: 00                  byte    0              Aclod                             # A/C Load Adder
9046: 01                  byte    1              Updisc
9047: 03                  byte    3              Updatm                            # ISC KAM Update Rate
9048: ff                  byte   ff              Niold                             # Neutral idle open loop delay (time in closed loop control before going open loop, secs)
9049: 02                  byte    2              Drv_rpm                           # drive idle (rpm in drive)

904a: 54,00               word     54            Nubase                            # Base Idle Speed (target) in Neutral (672rpm) before additions
904c: 54,00               word     54            Neu_rpm                           # Base Idle Speed (target) in Drive (672rpm) before additions
904e: 08,00               word      8            Bzzrpm                            # Buzz RPM -  Additional rpm added at start up to idle rpm to clear engine.
9050: 03,00               word      3            Dnac                              # Idle RPM Adder For A/C
9052: 67,00               word     67            Isclpd                            # Idle GPAS Clip Limit
9054: 8f,02               word    28f            Famlim
9056: 00,a0               word   a000            Maxfam
9058: 00,00               word      0            Ndppm                             # ISC Air Neutral To Drive
905a: 00,00               word      0            Dnppm                             # ISC Air Drive To Neutral
905c: 66,00               word     66            Acppm
905e: 66,00               word     66            Dacppm
9060: 00,00               word      0            Psppm
9062: 28,00               word     28            Dactm
9064: 00,00               word      0            Dnpows

9066: 19                  byte   19              Tkdtm                             # ISC Startup Kickdown Time
9067: 50                  byte   50              Bzztm                             # Buzz RPM Time -  Duration that Buzz rpm is added to base target idle rpm at startup.
9068: 00                  byte    0              Nddelt                            # ISC Time Before N/D or D/N Switch Registers

# MFA Fuel Table -  Possibly the fuel table used in closed loop


  Fn1328:
9069: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9073: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
907d: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9087: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9091: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
909b: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
90a5: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
90af: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128

# MFA Altitude Multiplier vs BP - FN311


  Fn389:
90b9: ff,80   func              255,128
90bb: e0,80   func              224,128
90bd: b0,00   func              176,  0
90bf: 00,00   func                0,  0
90c1: 00,00   func                0,  0

90c3: 00                  byte    0

90c4: 00,ff               ??                                                       # TP Scaler for MAF Failure 


  Fn098:
90c6: ff,ff,00,06   func        65535, 1536
90ca: 00,7d,00,06   func        32000, 1536
90ce: 00,19,00,02   func         6400,  512
90d2: 00,00,00,00   func            0,    0
90d6: 00,00,00,00   func            0,    0
90da: 00,00,00,00   func            0,    0
90de: 00,00,00,00   func            0,    0

# Failed Mass Air Flow Sensor
#  -  Substitution air mass value used if both the MAF and TP sensors have failed.

90e2: ff,ff,37,1a   func        65535, 6711
90e6: 80,3e,37,1a   func        16000, 6711
90ea: 10,27,f0,16   func        10000, 5872
90ee: 40,1f,a9,13   func         8000, 5033
90f2: 70,17,6b,0e   func         6000, 3691
90f6: 30,11,d5,09   func         4400, 2517
90fa: 10,0e,8e,06   func         3600, 1678
90fe: 00,00,f6,0d   func            0, 3574

# Failed Mass Air Flow Sensor (TP OK)
# -  Substitution air mass value used if the MAF sensor has failed and the TP sensor is ok.

9102: 1a,15,0a,0a,0a,09,08,07,06,06   table  26, 21, 10, 10, 10,  9,  8,  7,  6,  6
910c: 44,41,3a,2f,22,19,13,11,0f,0e   table  68, 65, 58, 47, 34, 25, 19, 17, 15, 14
9116: 58,57,55,51,4b,42,32,28,1d,19   table  88, 87, 85, 81, 75, 66, 50, 40, 29, 25
9120: 60,64,68,69,6a,69,64,5a,4b,3e   table  96,100,104,105,106,105,100, 90, 75, 62
912a: 62,69,6b,6d,6e,6f,71,72,71,6f   table  98,105,107,109,110,111,113,114,113,111
9134: 64,6a,6d,70,72,75,77,7d,90,90   table 100,106,109,112,114,117,119,125,144,144
913e: 83,88,8c,90,93,94,9d,aa,df,df   table 131,136,140,144,147,148,157,170,223,223

# Injector Timing Scaler for Load 


  Inj_lt_scl:
9148: ff,ff,70,00   func        65535,  112
914c: 00,60,70,00   func        24576,  112
9150: cd,4c,60,00   func        19661,   96
9154: cd,0c,10,00   func         3277,   16
9158: 66,06,00,00   func         1638,    0
915c: 00,00,00,00   func            0,    0

# Injector Timing - FN1315
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: Load []   .05,.15,.23,.30,.40,.50,.60,.75
#  - injector timing (global injector delay in crank degrees)  


  Inj_time:
9160: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
916a: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
9174: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
917e: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
9188: 58,58,58,58,58,5f,64,64,64,64   table  88, 88, 88, 88, 88, 95,100,100,100,100
9192: 5f,5f,5f,5f,5f,5f,69,69,74,74   table  95, 95, 95, 95, 95, 95,105,105,116,116
919c: 69,69,69,69,69,69,69,74,74,74   table 105,105,105,105,105,105,105,116,116,116
91a6: 69,69,69,69,69,69,69,74,74,74   table 105,105,105,105,105,105,105,116,116,116

# Injector Output Port  (Links injector to fuel pulsewidth, 0 = use Fuel Pulsewidth)

  Inj_opport:
91b0: 00,00,00,00,00,02,02,02,02,01   table   0,  0,  0,  0,  0,  2,  2,  2,  2,  1

# Injector Firing Order - FN1329

# Func: Accelerator Enrichment Multiplier vs TPS ( accelerator enrichment vs TP voltage) - FN331B
91ba: 03,07,02,06,05,04,08,ff,00,d5   table   3,  7,  2,  6,  5,  4,  8,255,  0,213

91c4: 00,71,26,32,7a,00,80 ??   

 # Accel Enrichment Fuel (lbs/min)- FN1303
# 7 Rows: ECT [DegF] -30,0,30,50,100,150,200
# 8 Cols: Throttle Rate [Deg/sec] 15,33,48,63,77,90,110,125


  Accelrich:
91cb: 54,5c,68,70,7c,88,9c,e0   table  84, 92,104,112,124,136,156,224
91d3: 30,38,40,48,68,78,98,dc   table  48, 56, 64, 72,104,120,152,220
91db: 14,20,28,30,42,54,6c,b4   table  20, 32, 40, 48, 66, 84,108,180
91e3: 10,14,18,20,32,44,66,88   table  16, 20, 24, 32, 50, 68,102,136
91eb: 08,08,0c,12,20,32,48,74   table   8,  8, 12, 18, 32, 50, 72,116
91f3: 06,06,08,0c,12,20,30,50   table   6,  6,  8, 12, 18, 32, 48, 80
91fb: 06,06,08,0c,12,20,30,48   table   6,  6,  8, 12, 18, 32, 48, 72

9203: ff                        

# Max Air Charge vs RPM -  The maximum air charge based upon rpm.

9204: ff,ff,65,aa   func        65535,43621
9208: 00,00,65,aa   func            0,43621
920c: 00,00,65,aa   func            0,43621
9210: 00,00,65,aa   func            0,43621
9214: 00,00,65,aa   func            0,43621
9218: 00,00,65,aa   func            0,43621
921c: 00,00,65,aa   func            0,43621
9220: 00,00,65,aa   func            0,43621
9224: 00,00,65,aa   func            0,43621
9228: 00,00,65,aa   func            0,43621

# Table - injector breakpoint vs battery voltage ( voltage, lbs/rev)

922c: ff,ff,e0,1f   func        65535, 8160
9230: 00,00,e0,1f   func            0, 8160
9234: 00,00,e0,1f   func            0, 8160
9238: 00,00,e0,1f   func            0, 8160
923c: 00,00,e0,1f   func            0, 8160
9240: 00,00,e0,1f   func            0, 8160
9244: 00,00,e0,1f   func            0, 8160
9248: 00,00,e0,1f   func            0, 8160

# ISC Startup Scaler for ECT.


  ISC_ECT_SC:
924c: 7f,60   func               127, 96
924e: 7d,60   func               125, 96
9250: e7,00   func               -25,  0
9252: 80,00   func              -128,  0
9254: 80,00   func              -128,  0

# ISC Transfer -  Alter if air flow characteristics through the ISC valve have changed.

9256: ff,ff,00,80   func        65535,32768
925a: 9a,25,00,80   func         9626,32768
925e: f6,24,9a,79   func         9462,31130
9262: ec,21,cd,6c   func         8684,27853
9266: 9a,1f,66,66   func         8090,26214
926a: 00,18,e1,5a   func         6144,23265
926e: 00,0c,9a,49   func         3072,18842
9272: 00,08,00,40   func         2048,16384
9276: 00,04,ec,31   func         1024,12780
927a: ec,01,d7,23   func          492, 9175
927e: 00,00,cd,0c   func            0, 3277

9282: 00,00,00,00               

# ISC Adder vs RPM - FN810

9286: ff,ff,00,00   func        65535,    0
928a: 60,09,00,00   func         2400,    0
928e: 08,07,ae,03   func         1800,  942
9292: 78,05,00,08   func         1400, 2048
9296: 00,00,00,08   func            0, 2048

# ISC Dutycycle Multiplier vs Load - FN820B

929a: ff,ff,80,00   func        65535,  128
929e: 00,00,80,00   func            0,  128
92a2: 00,00,80,00   func            0,  128
92a6: 00,00,80,00   func            0,  128
92aa: 00,00,80,00   func            0,  128
92ae: 00,00,80,00   func            0,  128

# ISC Gain vs RPM Error - FN824

92b2: ff,c0   func              255,192
92b4: 38,c0   func               56,192
92b6: 2b,40   func               43, 64
92b8: 29,40   func               41, 64
92ba: 1f,ff   func               31,255
92bc: 00,ff   func                0,255
92be: 00,ff   func                0,255

# ISC Startup RPM vs ECT - FN826A

92c0: 7f,00   func               127,  0
92c2: 32,06   func                50,  6
92c4: 26,36   func                38, 54
92c6: 19,06   func                25,  6
92c8: 0a,06   func                10,  6
92ca: 00,13   func                 0, 19
92cc: 80,13   func              -128, 19

# Spark Idle Multiplie vs Dashpot - FN839

92ce: ff,7f   func              255,127
92d0: 06,7f   func                6,127
92d2: 00,53   func                0, 83
92d4: 00,53   func                0, 83

# ISC Error Spark Multiplier Drive - FN841D

92d6: ff,7f,7f,00   func         32767,  127
92da: 64,00,7f,00   func           100,  127
92de: 28,00,71,00   func            40,  113
92e2: 00,00,60,00   func             0,   96
92e6: b0,ff,46,00   func           -80,   70
92ea: 00,80,46,00   func        -32768,   70
92ee: 00,80,46,00   func        -32768,   70

# ISC Error Spark Multiplier Neutral - FN841N

92f2: ff,7f,7c,00   func         32767,  124
92f6: b8,01,7c,00   func           440,  124
92fa: 00,00,53,00   func             0,   83
92fe: 10,ff,3e,00   func          -240,   62
9302: 00,80,3e,00   func        -32768,   62
9306: 00,80,3e,00   func        -32768,   62
930a: 00,80,3e,00   func        -32768,   62

# ISC C/L RPM Correction Rate - FN860

930e: ff,7f,05,00   func         32767,    5
9312: 00,80,05,00   func        -32768,    5
9316: 00,80,05,00   func        -32768,    5
931a: 00,80,05,00   func        -32768,    5
931e: 00,80,05,00   func        -32768,    5
9322: 00,80,05,00   func        -32768,    5
9326: 00,80,05,00   func        -32768,    5

# Table - dashpot decrement rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))- FN879
# X: RPM  # Y: Dashpot Clip [lb/min]


  Dash_dec:
932a: ff,ff,00,01   func        65535,  256
932e: 00,0c,00,01   func         3072,  256
9332: 66,0a,b8,00   func         2662,  184
9336: 33,07,1d,00   func         1843,   29
933a: 9a,05,08,00   func         1434,    8
933e: fe,00,0c,00   func          254,   12
9342: 00,00,0e,00   func            0,   14

# Max Dashpot Pre Position Clip (maximum dashpot airflow by rpm in Kg/Hr)- FN882


  Dash_max:
9346: ff,ff,9a,19   func        65535, 6554
934a: 40,1f,9a,19   func         8000, 6554
934e: 70,17,00,10   func         6000, 4096
9352: d0,07,ec,01   func         2000,  492
9356: 00,00,ec,01   func            0,  492

# ISC duty cycle during crank (keyed off ect at start) - FN884


  Crankisc:
935a: 7f,4d   func               127, 77
935c: 5a,4d   func                90, 77
935e: 50,7f   func                80,127
9360: 80,7f   func              -128,127
9362: 80,7f   func              -128,127
9364: 80,7f   func              -128,127

# Desired Airflow Multiplier -  Multiplier of desired idle airflow to adjust for ECT and time in run mode.
# Airflow multiplier vs. ECT and ATMR3


  ECT_AM_Mult:
9366: a6,80,66,5a,4d,48,44   table 166,128,102, 90, 77, 72, 68
936d: a6,80,66,53,4d,48,44   table 166,128,102, 83, 77, 72, 68
9374: a6,9a,66,4d,4a,48,44   table 166,154,102, 77, 74, 72, 68
937b: 9a,90,5a,46,4a,48,44   table 154,144, 90, 70, 74, 72, 68
9382: 86,7a,53,46,4a,48,44   table 134,122, 83, 70, 74, 72, 68
9389: 6d,66,53,46,40,40,40   table 109,102, 83, 70, 64, 64, 64

# Desired idle airflow in drive (Kg/Hr)


  Drv_aflw:
9390: ff,ff   func              255,255
9392: 7a,ff   func              122,255
9394: 5e,ca   func               94,202
9396: 3f,8d   func               63,141
9398: 2a,60   func               42, 96
939a: 00,00   func                0,  0

# Desired idle airflow in neutral


  Neu_aflw:
939c: ff,ff   func              255,255
939e: 7a,fa   func              122,250
93a0: 2a,60   func               42, 96
93a2: 00,00   func                0,  0
93a4: 00,00   func                0,  0
93a6: 00,00   func                0,  0

################################################### Reg 0xF6 points here (93a8)


93a8: 30,94               word   9430
93aa: 33,33               word   3333            Fkarch                            # Air Charge Manifold filling model slow filter constant
93ac: 00,40               word   4000            Fkarc1                            # Air Charge Manifold filling model fast filter constant
93ae: 1a,01               word    11a            Filfrc                            # Air Charge Fraction to select slow transient vs fast

93b0: 01                  byte    1

93b1: ff                        

93b2: 2c,01               word    12c            SSFCTR
93b4: 00,00               word      0

93b6: 00                  byte    0

93b7: 00,00,00,01         ??    

93bb: 00                  byte    0              Bihp                              # Brake Input H/w Present - Set if brake pedal switch present.
93bc: 00                  byte    0              Pspshp                            # Power Steering Pressure Switch Present
93bd: 00                  byte    0
93be: 71                  byte   71
93bf: 76                  byte   76
93c0: 05                  byte    5

93c1: ff                        

93c2: 90,01               word    190
93c4: a0,0f               word    fa0

93c6: 14                  byte   14
93c7: 9b                  byte   9b
93c8: 03                  byte    3

93c9: ff                        

93ca: 66,66               word   6666
93cc: ae,07               word    7ae

93ce: 38                  byte   38

93cf: 5f,00,00,00         ??    

93d3: 00                  byte    0

93d4: 66,66               word   6666
93d6: d7,03               word    3d7

93d8: ff                  byte   ff

93d9: ff                        

93da: 48,0d               word    d48
93dc: 20,03               word    320

93de: 3c                  byte   3c
93df: ff                  byte   ff
93e0: 00                  byte    0
93e1: 00                  byte    0              EcadHP                            # Electronically Controlled Accessory Drive Present - ECADHP
93e2: 71                  byte   71              ECADQ1
93e3: 48                  byte   48              ECadn
93e4: 1e                  byte   1e              ECADVS                            # H/w Present (Electronic Control Assembly ? )
93e5: 6c                  byte   6c
93e6: 22                  byte   22              EDNHYS
93e7: 1a                  byte   1a              EDVSHYS
93e8: 00                  byte    0              EDTM3

93e9: 00,00,00,00               

93ed: 76                  byte   76
93ee: 03                  byte    3
93ef: 00                  byte    0                                                # Canister Purge O/L Enable - PURGSW
93f0: 01                  byte    1

93f1: ff,88,13,20,03      ??    

93f6: a5                  byte   a5                                                # Purge Hot Startup Delay -

93f7: dc,00,00,dc         ??    

93fb: 05                  byte    5
93fc: 00                  byte    0
93fd: 18                  byte   18                                                # A/C Min Time Before Fan Is On - ACWDLY

93fe: 0c,00               word      c
9400: f6,00               word     f6                                              # A/C Clutch Engage Delay

9402: 79                  byte   79                                                # A/C Clutch Engage Max Temp - CTAC
9403: 04                  byte    4                                                # A/C Clutch Engage Max Temp Hysterysis - CTACH

9404: c8,00               word     c8
9406: 90,01               word    190
9408: 00,87               word   8700
940a: 00,05               word    500
940c: 0c,00               word      c

940e: 00                  byte    0              Hpacl                             # Set if Adjustable Dampers Present

940f: ff                        

9410: d5,09               word    9d5                                              # Min Air Charge for Adjustable Damper -  The minimum air charge to indicate hard acceleration.
9412: 80,a2               word   a280                                              # Min TP for Adjustable Damper -  The minimum voltage above closed throttle to indicate hard acce
                                                                                   leration.

9414: 6e                  byte   6e              Fan_temp                          # coolant fan low speed temp (220DegF)
9415: 02                  byte    2                                                # High Speed Fan Temperature Hysteresis - HSFHYS
9416: 02                  byte    2                                                # Low Speed Fan Temperature Hysterysis - LSFHYS
9417: 50                  byte   50                                                # Low Speed Fan MPH - LSFVS
9418: 0a                  byte    a                                                # Low Speed Fan MPH Hysterysis - LSFVSH
9419: 0a                  byte    a                                                # Low Speed Fan Min Time Before High Speed - EDFTM

941a: e0,01               word    1e0                                              # A/C Min Time Off Before Turning Fan Off - ACMNFT

941c: 00                  byte    0              Fan_enble                         # Low Speed Fan Present/Enable
941d: 00                  byte    0              Hedfhp                            # High Speed Fan Present/Enable
941e: 75                  byte   75              Ect_hs1                           # fan high speed temp 1(234DegF)
 # ect1 fan on 
941f: 79                  byte   79              Ect_hs2                           # ect2 fan on fan high speed temp 2(242DegF)
9420: 71                  byte   71                                                # Fan High Speed Min RPM - HSFRPM
9421: 50                  byte   50                                                # Fan High Speed Min MPH - HSFVS

9422: 00,c0               word   c000                                              # Fan High Speed Min Load - HSFLOD
9424: 66,46               word   4666                                              # Default ISC Dutycycle -  Default ISC dutycyle when both TPS and MAF failed flags are set

9426: 32                  byte   32                                                # Default Desired Idle RPM -  Default desired idle rpm when both TPS and MAF failed flags are set
                                                                                   
9427: 4b                  byte   4b
9428: 4b                  byte   4b                                                # Default ECT value?

9429: ff                        

942a: 00,02               word    200
942c: cd,03               word    3cd

942e: ef                  byte   ef

942f: 50,a8               word   a850

################################################### Reg 0xF8 points here (9430)
9431: 97,00               word     97                                              # closed throttle spark adder
9433: 00,00               word      0                                              # part throttle  spark adder (Deg BTDC)
9435: 00,68               word   6800
9437: 10,e8               word   e810
9439: 03,00               word      3            SPKWOT                            # spark adder WOT  ( Deg BTDC)
943b: 00                  byte    0

943c: 00                  byte    0              Splclp                            # Spark Limit Min - SPLCLP
943d: b4                  byte   b4              Spuclp                            # Spark Limit Max - SPUCLP
943e: 80                  byte   80                                                # PT Spark Multiplier - "
943f: 20                  byte   20                                                # Spark/Fuel Lug Time Limit - LUGTIM
9440: 01                  byte    1                                                # Lugging Timer Reset Switch -  If set then Lugging Timer is cleared before Lugging Timer Up Flag
                                                                                    is cleared and Lugging Timer Down Flag is set.

9441: 00                        

9442: 00,00               word      0                                              # Spark Adder Neutral - NSADD
9444: 10,03               word    310            SPKSWL                            # Spark Max PIP RPM - SPKSWL
9446: 10,03               word    310            PIP_Tlow                          # Spark Min PIP RPM - SPKSWH

9448: ff                  byte   ff                                                # RPM to MPH Ratio for First Gear - TTNOV
9449: 00                  byte    0              Hphidres                          # High Data Rate Electronic Spark H/W present 
944a: 00                  byte    0              Tfi_dwell                         # Computer Controlled Dwell Present if Set. (else dwell is TFI controlled)

944b: ff                        

944c: 7b,14               word   147b
944e: f6,28               word   28f6
9450: 30,00               word     30            Pacslo                            #  # Slope for linear equation describing PIP period and percent of PIP period for acceleration, 
                                                                                   (Units = Beta/second)
9452: ec,11               word   11ec            Paclim                            # Max PIP acceleration in percent of PIP period, Beta
9454: ae,07               word    7ae            SPTADV                            # Spark Advance Limit PIP%
9456: 00,80               word   8000            Lowdwell                          # max low speed dwell (off time in ms )
9458: 33,33               word   3333            Hidwell                           # max high speed dwell  (off time in ms )

945a: 70                  byte   70              DWLWF                             # DWLWF - Weighting factor determining effect of ECT and ACT on Base Dwell, unitless.
945b: 26                  byte   26

945c: 1f,05               word    51f            dwLTSW                            # Switch point for change of max permitted DWELL,sec
945e: 20,02               word    220            KACRAT                            # Spark Tip In TP - KACRAT

9460: 00                  byte    0              Retlim                            # Spark Retard For Knock Sensor - RETLIM
9461: 00                  byte    0              ADVLIM                            # Spark Knock Advance Limit - ADVLIM
9462: 00                  byte    0              Tipinret                          # Tip in retard (max tip in spark retard in Deg BTDC)
9463: 01                  byte    1              TIPINC                            # Spark Tip In Advance Per PIP - TIPINC

9464: cd,1c               word   1ccd            TIPLOD
9466: 66,06               word    666            TIPHS
9468: 00,7d               word   7d00            RPMMIN                            # Spark Knock Min RPM -  The minimum rpm for the knock strategy to be enabled.
946a: 66,06               word    666            LODNOK

946c: 00                  byte    0                                                # Spark Knock Min ECT - ECTNOK
946d: 3c                  byte   3c

946e: 00,00               word      0            NTIP                              # Spark Tip In Max RPM - NTIP
9470: 00,80               word   8000            WOPEN
9472: 00,00               word      0            WINLEN
9474: 80,3e               word   3e80            RPMCNL
9476: ae,07               word    7ae            Spklim

9478: 04                  byte    4              KNKCYL                            # Spark Tip In TP Threshold - KNKCYL
9479: 0c                  byte    c              WINCLD
947a: 00                  byte    0              Kihp                              # Knock Input H/w Present
947b: 01                  byte    1
947c: ef                  byte   ef

947d: ff                        

947e: 00,06               word    600
9480: 33,00               word     33
9482: 71,00               word     71
9484: 0a,02               word    20a

9486: 0a                  byte    a

9487: ff                        

# PT Spark Scaler for ECT 

9488: ff,7f,00,06   func         32767, 1536
948c: 73,00,00,06   func           115, 1536
9490: 69,00,00,05   func           105, 1280
9494: 62,00,00,04   func            98, 1024
9498: 35,00,00,03   func            53,  768
949c: 1e,00,00,00   func            30,    0
94a0: 00,80,00,00   func        -32768,    0
94a4: 00,80,00,00   func        -32768,    0
94a8: 00,80,00,00   func        -32768,    0

# Closed Throttle Spark Adder For RPM - FN111

94ac: ff,7f,7c,00   func         32767,   124
94b0: 40,06,7c,00   func          1600,   124
94b4: bc,02,00,00   func           700,     0
94b8: 00,80,00,00   func        -32768,     0
94bc: 00,80,00,00   func        -32768,     0

# CT Spark Adder For ECT - FN112
# Generates cold temperature spark advance. Input = ECT, deg F and Output = spark adder.

94c0: 7f,00   func               127,   0
94c2: 12,00   func                18,   0
94c4: 00,0c   func                 0,  12
94c6: 80,0c   func              -128,  12
94c8: 80,0c   func              -128,  12
94ca: 80,0c   func              -128,  12
94cc: 80,0c   func              -128,  12

# Closed Throttle Spark Adder For BP - FN115

94ce: ff,00   func              255,   0
94d0: 00,00   func                0,   0
94d2: 00,00   func                0,   0
94d4: 00,00   func                0,   0
94d6: 00,00   func                0,   0
94d8: 00,00   func                0,   0

# LOM spark Strategy - (load managemnt at WOT ?) Input: RPM and Output: load.


  LOM_spark:
94da: ff,ff,8f,02   func        65535,  655
94de: 00,19,8f,02   func         6400,  655
94e2: 70,17,a4,10   func         6000, 4260
94e6: 30,11,a4,10   func         4400, 4260
94ea: 00,00,cd,2c   func            0,11469

# Part Throttle Spark Advance vs ACT - FN1261


  Ptadvact:
94ee: 7f,f8   func               127,  -8
94f0: 5f,f8   func                95,  -8
94f2: 50,00   func                80,   0
94f4: 80,00   func              -128,   0
94f6: 80,00   func              -128,   0

# LOMALT Multiplier vs BP - FN129A

94f8: ff,00   func              255,  0
94fa: de,00   func              222,  0
94fc: d4,80   func              212,128
94fe: bc,80   func              188,128
9500: 60,9a   func               96,154
9502: 00,9a   func                0,154

# WOT Spark Advance vs RPM - FN1311


  Wotadvrpm:
9504: ff,ff,68,00   func        65535,  104
9508: 20,4e,68,00   func        20000,  104
950c: b0,36,58,00   func        14000,   88
9510: a0,28,5a,00   func        10400,   90
9514: 98,21,56,00   func         8600,   86
9518: 20,1c,4a,00   func         7200,   74
951c: a0,0f,20,00   func         4000,   32
9520: 00,00,20,00   func            0,   32
9524: 00,00,20,00   func            0,   32

# WOT Spark Advance vs BP - FN1331 (Hg , Degrees)


  Wotadvbap:
9528: ff,00   func              255,   0
952a: de,00   func              222,   0
952c: d4,10   func              212,  16
952e: bc,10   func              188,  16
9530: 00,30   func                0,  48

# WOT Spark Advance vs ECT - FN134


  Wotadvect:
9532: 7f,f0   func               127, -16
9534: 7b,f0   func               123, -16
9536: 76,f8   func               118,  -8
9538: 64,00   func               100,   0
953a: 3c,00   func                60,   0
953c: 2b,0c   func                43,  12
953e: 80,0c   func              -128,  12

# WOT Spark Advance vs ACT - FN135


  Wotadvact:
9540: 7f,e8   func               127, -24
9542: 78,e8   func               120, -24
9544: 4b,00   func                75,   0
9546: 80,00   func              -128,   0
9548: 80,00   func              -128,   0
954a: 80,00   func              -128,   0
954c: 80,00   func              -128,   0

# Idle Spark Subtractor - FN180

954e: ff,00   func              255,  0
9550: 00,00   func                0,  0
9552: 00,00   func                0,  0
9554: 00,00   func                0,  0
9556: 00,00   func                0,  0
9558: 00,00   func                0,  0

# ISC Neutral RPM Adder - FN880

955a: ff,09   func              255,  9
955c: dc,00   func              220,  0
955e: 05,00   func                5,  0
9560: 00,08   func                0,  8
9562: 00,08   func                0,  8
9564: 00,08   func                0,  8
9566: 00,08   func                0,  8

# Startup Kicker Time Delay - FN400

9568: 7f,00   func               127,  0
956a: 33,00   func                51,  0
956c: 2d,1e   func                45, 30
956e: 23,1e   func                35, 30
9570: 1e,00   func                30,  0
9572: 80,00   func              -128,  0

# Sea Level (Base) Spark Table (Deg BTDC = load vs RPM)
# - The ecu interpolates between the Sea Level and Altitude spark tables during normal part throttle
# operation.  Set to the same as the Sea Level Spark table.
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: Load []   .05,.15,.23,.30,.40,.50,.60,.75


  Basespk:
9574: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
957e: 70,70,70,7c,84,88,88,88,70,70   table 112,112,112,124,132,136,136,136,112,112
9588: 70,70,84,90,90,94,98,98,70,70   table 112,112,132,144,144,148,152,152,112,112
9592: 64,68,70,74,80,80,98,a0,70,70   table 100,104,112,116,128,128,152,160,112,112
959c: 50,54,64,70,7c,80,84,88,70,70   table  80, 84,100,112,124,128,132,136,112,112
95a6: 3c,3c,40,40,48,50,5c,6c,6c,6c   table  60, 60, 64, 64, 72, 80, 92,108,108,108
95b0: 20,28,28,2c,34,3c,54,54,54,54   table  32, 40, 40, 44, 52, 60, 84, 84, 84, 84
95ba: 20,20,24,28,30,38,48,54,54,54   table  32, 32, 36, 40, 48, 56, 72, 84, 84, 84

 # Altitude Spark Table
# - The ecu interpolates between the Sea Level and Altitude spark tables during normal part throttle
# operation.  Set to the same as the Sea Level Spark table.
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: Load []   .05,.15,.23,.30,.40,.50,.60,.75
# 95C4 Sealspk               


  Sealspk:
95c4: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
95ce: 70,70,70,80,88,8c,8c,88,70,70   table 112,112,112,128,136,140,140,136,112,112
95d8: 70,70,84,94,94,98,98,98,70,70   table 112,112,132,148,148,152,152,152,112,112
95e2: 64,68,78,94,98,90,90,98,70,70   table 100,104,120,148,152,144,144,152,112,112
95ec: 50,54,64,80,88,88,84,80,70,70   table  80, 84,100,128,136,136,132,128,112,112
95f6: 3c,40,40,40,48,50,68,6c,6c,6c   table  60, 64, 64, 64, 72, 80,104,108,108,108
9600: 20,20,24,28,2c,38,54,54,54,54   table  32, 32, 36, 40, 44, 56, 84, 84, 84, 84
960a: 20,20,24,28,2c,34,54,54,54,54   table  32, 32, 36, 40, 44, 52, 84, 84, 84, 84

# sea level (Base) lom spark Table
# - A more aggressive spark advance used during acceleration.
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: Load []   .05,.15,.23,.30,.40,.50,.60,.75


  Atlospk:
9614: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
961e: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
9628: 64,68,7a,86,8c,92,98,98,98,98   table 100,104,122,134,140,146,152,152,152,152
9632: 50,54,50,60,7c,80,84,84,84,84   table  80, 84, 80, 96,124,128,132,132,132,132
963c: 38,38,38,38,40,54,6c,6c,6c,6c   table  56, 56, 56, 56, 64, 84,108,108,108,108
9646: 20,24,28,2c,34,44,58,58,58,58   table  32, 36, 40, 44, 52, 68, 88, 88, 88, 88
9650: 1a,20,24,28,30,38,48,48,48,48   table  26, 32, 36, 40, 48, 56, 72, 72, 72, 72
965a: 1a,1a,24,28,30,38,48,48,48,48   table  26, 26, 36, 40, 48, 56, 72, 72, 72, 72

# Part Thottle Spark Adder for EGR

9664: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
966e: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9678: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9682: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
968c: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9696: 00,00,00,16,16,20,30,30,30,30   table   0,  0,  0, 22, 22, 32, 48, 48, 48, 48
96a0: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96aa: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# PT Spark Adder for RPM
# Table of spark adders from engine speed N and LOAD. (4 x 3) 
# X input is RPM  Y -input is LOAD

96b4: 00,10,04,00   table         0, 16,  4,  0
96b8: 20,14,04,08   table        32, 20,  4,  8
96bc: 2c,24,10,10   table        44, 36, 16, 16

# Torque Reduction Table - FN1119

96c0: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96ca: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96d4: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96de: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96e8: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96f2: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96fc: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9706: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# Part Throttle spark modifier (adder). (ECT,LOAD) 

9710: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
9717: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
971e: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
9725: 0c,00,00,00,00,00,00   table  12,  0,  0,  0,  0,  0,  0
972c: 0c,00,00,00,00,00,f0   table  12,  0,  0,  0,  0,  0,240
9733: 14,00,00,00,00,00,f0   table  20,  0,  0,  0,  0,  0,240
973a: 14,00,00,00,00,fc,f0   table  20,  0,  0,  0,  0,252,240
9741: 14,00,00,00,00,f8,f0   table  20,  0,  0,  0,  0,248,240

# Min Low Speed Dwell - FN160A
#   = Dwell/Coil off time vs battery voltage 


  Min_Low_dwell:
9748: ff,ff,bc,05   func        65535, 1468
974c: f0,00,bc,05   func          240, 1468
9750: e0,00,25,06   func          224, 1573
9754: c0,00,31,08   func          192, 2097
9758: a0,00,37,09   func          160, 2359
975c: 00,00,37,09   func            0, 2359

# Min High Speed Dwell - FN160B1 
#   = Dwell/Coil off time vs battery voltage 


  Min_Hi_dwell:
9760: ff,ff,25,06   func        65535, 1573
9764: f0,00,25,06   func          240, 1573
9768: d0,00,dc,06   func          208, 1756
976c: c0,00,94,07   func          192, 1940
9770: a0,00,3d,0a   func          160, 2621
9774: 00,00,3d,0a   func            0, 2621

# Spark Knock Retard Increment vs RPM - FN143A

9778: ff,04   func              255,  4
977a: 9c,04   func              156,  4
977c: 5e,0c   func               94, 12
977e: 1f,10   func               31, 16
9780: 00,14   func                0, 20
9782: 00,14   func                0, 20

# Spark Knock Threshold Time - Output is fraction of PIP period.

9784: ff,19   func              255, 25
9786: 9c,19   func              156, 25
9788: 5e,16   func               94, 22
978a: 4e,13   func               78, 19
978c: 3f,04   func               63,  4
978e: 2f,03   func               47,  3
9790: 00,03   func                0,  3

# Spark Knock Threshold Position.

9792: ff,00   func              255,  0
9794: 00,00   func                0,  0
9796: 00,00   func                0,  0
9798: 00,00   func                0,  0
979a: 00,00   func                0,  0

# Spark Advance Rate vs RPM
#  -  Limits the advance rate to avoid pinging, increase to improve throttle response.


  Advrpm:
979c: ff,10   func              255, 16
979e: 7d,10   func              125, 16
97a0: 5e,18   func               94, 24
97a2: 1f,20   func               31, 32
97a4: 00,20   func                0, 32
97a6: 00,20   func                0, 32

#################### RFA points here (97a8)


97a8: 7e,9a               word   9a7e
97aa: 00,02               word    200            Tp_Delta                          # PT Threshold -  Added to closed throttle value.
97ac: 40,01               word    140            Tp_Hysts2                         # WOT Threshold Hysteresis - HYST2
97ae: 40,01               word    140            TP_Hysts                          # PT Threshold Hysteresis - 
97b0: c0,8a               word   8ac0            Wotbrkv                           # WOT breakpoint. TPS voltage - 1

97b2: 7f                  byte   7f              Ldel                              # 254 degrees?
97b3: 6e                  byte   6e              Ldeh                              # Fuel Lugging Mode O/L Min ECT - LDEH

97b4: 0a                        

97b5: 28                  byte   28              LDLTM                             # Min Time for Lugging O/L -  The minimum time in lugging mode required for the Lugging O/L Flag 
                                                                                   to be set.

97b6: b8,7e               word   7eb8            LDMH                              # Fuel Lugging Mode O/L Min Load - LDMH
97b8: d7,03               word    3d7            LDMHH                             # Fuel Lugging Mode O/L Min Load Hysteresis - LDMHH
97ba: ff,00               word     ff            Olflmult                          # Global Open Loop Fuel Multiplier - OLMCL

97bc: 08                  byte    8                                                # RPM classifications

97bd: ff                        

97be: 20,03               word    320            200rpm
97c0: 90,01               word    190
97c2: 84,03               word    384            225_RPM
97c4: c8,00               word     c8

97c6: 02                  byte    2
97c7: 1e                  byte   1e

97c8: 5a,00,00,f0         ??    

97cc: 00                  byte    0                                                # EGR PT Adder - KPEI
97cd: 80                  byte   80              Egr_mult                          # egr multiplier (byte)

97ce: cd,2c               word   2ccd            EGRDCOFF                          # EGR Dutycycle for Valve to Open - DCOFF
97d0: 00,02               word    200            EGRDB                             # EGR Deadband Value for EVP - EGRDED

97d2: 0a                  byte    a              egrmpt                            # Calibration time delay to ramp in EGR (sec)

97d3: ff                        

97d4: fe,54               word   54fe            XFREPT                            # EPT Transfer - XFREPT
97d6: 00,30               word   3000

97d8: 01                  byte    1
97d9: 00                  byte    0              Egr_type                          # EGR type (0=sonic, 1=PFE, 2=none)

97da: c8,00               word     c8

97dc: 5a                  byte   5a

97dd: ff                        

97de: 3d,00               word     3d
97e0: 0a,00               word      a
97e2: 00,01               word    100                                              # Dashpot decrement Filter factor ?
97e4: 9a,02               word    29a
97e6: 33,0d               word    d33

## Filter factors for the various filter & rollav subroutine calls, mapped by encoded addresses
# number range d040 - d060,  maps to 97e8 - 9808
97e8: 01,00               word      1                                              # EVP output   (d040)
97ea: 8f,00               word     8f                                              # BAP 1
97ec: 00,04               word    400                                              # ECT 
97ee: 71,00               word     71                                              # EGR 1    (d046)
97f0: 8f,00               word     8f                                              # EVP    (d048)
97f2: 00,01               word    100                                              # AM   (airflow)
97f4: cd,04               word    4cd                                              # RPM 1    (d04c)
97f6: 00,08               word    800                                              # TP 1   (Throttle) (d04e)
97f8: ae,00               word     ae                                              # VBAT     (d050)
97fa: 29,00               word     29                                              # MPH 1    (d052)
97fc: 2e,00               word     2e            ldffact                           # LOAD     (d054)
97fe: 71,01               word    171                                              # BAP 2    (d056)
9800: 5c,03               word    35c                                              # Injdly output  (d058)
9802: a4,00               word     a4                                              # MPH 2    (d05a)
9804: 00,6c               word   6c00                                              # RPM 2    (d05c)
9806: 5c,01               word    15c                                              # TP 2   (throttle) (d05e)
9808: 00,08               word    800                                              # EGR Filter   (d060)
980a: 00,46               word   4600
980c: 40                  byte   40

# High Speed Spark Retard -  Deducted from spark calculations.Table 980D High Speed Spark retard, mph.


  HSS_retard:
980d: ff,00   func              255,  0
980f: 00,00   func                0,  0
9811: 00,00   func                0,  0
9813: 00,00   func                0,  0
9815: 00,00   func                0,  0
9817: 00,00   func                0,  0
9819: 00,00   func                0,  0

# Fuel High Speed Multiplier - FN396A

981b: ff,ff   func              255,255
981d: 00,ff   func                0,255
981f: 00,ff   func                0,255
9821: 00,ff   func                0,255
9823: 00,ff   func                0,255
9825: 00,ff   func                0,255
9827: 00,ff   func                0,255

9829: ff                        

# Func - sea level lugging Open Loop multiplier (vs rpm) - FN308


  Sea_llug_ol_mult:
982a: ff,ff,80,00   func        65535,  128
982e: 70,17,80,00   func         6000,  128
9832: c0,12,9a,00   func         4800,  154
9836: b8,0b,9a,00   func         3000,  154
983a: 28,0a,80,00   func         2600,  128
983e: 00,00,80,00   func            0,  128
9842: 00,00,80,00   func            0,  128

# Func - Altitude Lugging Open Loop Fuel Multiplier (RPM) - FN309


  Alt_lug_ol_mult:
9846: ff,ff,80,00   func        65535,  128
984a: 00,00,80,00   func            0,  128
984e: 00,00,80,00   func            0,  128
9852: 00,00,80,00   func            0,  128
9856: 00,00,80,00   func            0,  128
985a: 00,00,80,00   func            0,  128
985e: 00,00,80,00   func            0,  128

# Func - Fuel Crank PulseWidth Multiplier vs Time - FN306


  Crnk_pw_time:
9862: ff,ff,00,40   func        65535,16384
9866: 00,00,00,40   func            0,16384
986a: 00,00,00,40   func            0,16384
986e: 00,00,00,40   func            0,16384
9872: 00,00,00,40   func            0,16384
9876: 00,00,00,40   func            0,16384

# Cranking Fuel PulseWidth vs ECT - FN348


  Crnk_pw_ect:
987a: ff,7f,0c,02   func         32767,  524
987e: 5a,00,0c,02   func            90,  524
9882: 4b,00,5b,02   func            75,  603
9886: 23,00,d6,05   func            35, 1494
988a: 14,00,c1,0a   func            20, 2753
988e: 0a,00,7d,0e   func            10, 3709
9892: 00,00,6a,16   func             0, 5738
9896: f6,ff,b1,27   func           -10,10161
989a: 00,80,b1,27   func        -32768,10161

# Fuel Under RPM Pulsewidth vs ECT - FN387

989e: 7f,40   func               127, 64
98a0: 80,40   func              -128, 64
98a2: 80,40   func              -128, 64
98a4: 80,40   func              -128, 64
98a6: 80,40   func              -128, 64
98a8: 80,40   func              -128, 64
98aa: 80,40   func              -128, 64
98ac: 80,40   func              -128, 64
98ae: 80,40   func              -128, 64

# Exhaust Back Pressure Correction
# -  Barometric pressure correction for exhaust back pressure calculation

98b0: ff,ff   func              255,255
98b2: c4,d5   func              196,213
98b4: a2,b9   func              162,185
98b6: 00,40   func                0, 64
98b8: 00,40   func                0, 64

# EGR Valve Upstream Pressure
#  -  Upstream pressure as a function of input(AM * KAMREF) output = H2O

98ba: ff,ff,00,59   func        65535,22784
98be: 00,80,00,59   func        32768,22784
98c2: 00,58,00,2a   func        22528,10752
98c6: 00,38,00,11   func        14336, 4352
98ca: 00,28,00,0c   func        10240, 3072
98ce: 00,20,00,09   func         8192, 2304
98d2: 00,0c,00,00   func         3072,    0
98d6: 00,00,00,00   func            0,    0
98da: 00,00,00,00   func            0,    0
98de: 00,00,00,00   func            0,    0

# EGR Multipiler for ECT - FN211

98e2: 7f,20   func               127,  32
98e4: 78,20   func               120,  32
98e6: 73,7f   func               115, 127
98e8: 41,7f   func                65, 127
98ea: 32,00   func                50,   0
98ec: 80,00   func              -128,   0

# Spark vs BP Sealevel - FN212A

98ee: ff,80   func              255,128
98f0: de,80   func              222,128
98f2: d4,00   func              212,  0
98f4: 00,00   func                0,  0
98f6: 00,00   func                0,  0

# EGR Multipiler for BAP - FN217A

98f8: ff,00   func              255,  0
98fa: de,00   func              222,  0
98fc: d4,80   func              212,128
98fe: bc,80   func              188,128
9900: b2,0d   func              178, 13
9902: 00,0d   func                0, 13

# EGR Mass Flow vs EGR Valve Position - FN219A

9904: ff,ff,8a,00   func        65535,  138
9908: ff,00,8a,00   func          255,  138
990c: a2,00,5a,00   func          162,   90
9910: 71,00,42,00   func          113,   66
9914: 32,00,20,00   func           50,   32
9918: 00,00,00,00   func            0,    0

# EGR Multipiler for ACT - FN220

991c: 7f,80   func               127,128
991e: 1c,80   func                28,128
9920: 00,66   func                 0,102
9922: 80,66   func              -128,102
9924: 80,66   func              -128,102

# EGR Position vs Desired Flow - FN221A

9926: ff,ff,ff,00   func        65535,  255
992a: 8a,00,ff,00   func          138,  255
992e: 80,00,ec,00   func          128,  236
9932: 5a,00,a2,00   func           90,  162
9936: 42,00,71,00   func           66,  113
993a: 20,00,32,00   func           32,   50
993e: 00,00,00,00   func            0,    0

# EGR Duty Cycle Adder vs EGR Error

9942: ff,7f,ae,07   func         32767,  1966
9946: 80,59,ae,07   func         22912,  1966
994a: 80,a6,52,f8   func        -22912, -1966
994e: 00,80,52,f8   func        -32768, -1966
9952: 00,80,52,f8   func        -32768, -1966
9956: 00,80,52,f8   func        -32768, -1966
995a: 00,80,52,f8   func        -32768, -1966

# EGR mass flow as a function of DELPR -  is this EGR Transfer Function?

995e: ff,ff,00,80   func        65535,32768
9962: 00,7f,00,80   func        32512,32768
9966: 00,3c,a4,70   func        15360,28836
996a: 00,32,66,66   func        12800,26214
996e: 00,28,9a,59   func        10240,22938
9972: 00,14,71,3d   func         5120,15729
9976: 00,0a,f6,28   func         2560,10486
997a: 00,05,29,1c   func         1280, 7209
997e: 00,02,00,00   func          512,    0
9982: 00,00,00,00   func            0,    0

# EGR Desired Drop vs Flow - FN247

9986: ff,ff,00,7f   func        65535,32512
998a: 00,80,00,7f   func        32768,32512
998e: a4,70,00,3c   func        28836,15360
9992: 66,66,00,32   func        26214,12800
9996: 9a,59,00,28   func        22938,10240
999a: 71,3d,00,14   func        15729, 5120
999e: f6,28,00,0a   func        10486, 2560
99a2: 29,1c,00,05   func         7209, 1280
99a6: 00,00,00,02   func            0,  512

99aa: 00,00,00,00               

# Table - Sea level EGR table - FN908A
# X = scaled RPM Y = scaled load. Output = Percent EGR


  Sea_l_EGR:
99ae: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99b8: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99c2: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99cc: 00,00,00,10,14,20,20,18,04,00   table   0,  0,  0, 16, 20, 32, 32, 24,  4,  0
99d6: 00,00,08,20,2c,2c,2c,22,04,00   table   0,  0,  8, 32, 44, 44, 44, 34,  4,  0
99e0: 00,00,08,20,24,26,20,17,00,00   table   0,  0,  8, 32, 36, 38, 32, 23,  0,  0
99ea: 00,00,08,0c,0c,0e,0f,0c,00,00   table   0,  0,  8, 12, 12, 14, 15, 12,  0,  0
99f4: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# Table - Altitude EGR table - FN908B
# X = scaled RPM Y = scaled load. Output = Percent EGR


  alt_EGR:
99fe: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a08: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a12: 00,00,00,08,0a,10,10,00,00,00   table   0,  0,  0,  8, 10, 16, 16,  0,  0,  0
9a1c: 00,00,00,14,26,28,24,20,1a,10   table   0,  0,  0, 20, 38, 40, 36, 32, 26, 16
9a26: 00,00,00,1c,24,22,20,14,13,08   table   0,  0,  0, 28, 36, 34, 32, 20, 19,  8
9a30: 00,00,00,10,10,10,0f,0a,0a,00   table   0,  0,  0, 16, 16, 16, 15, 10, 10,  0
9a3a: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a44: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# MFA EGR Multiplier -  Multiplier used for ramping in managed fuel air tables.

9a4e: 80,80,80,80   table       128,128,128,128
9a52: 2a,31,24,1d   table        42, 49, 36, 29
9a56: 00,0e,16,00   table         0, 14, 22,  0

# Canister Purge Duty Cycle Multiplier - FN600

9a5a: ff,80   func              255,128
9a5c: 00,80   func                0,128
9a5e: 00,80   func                0,128
9a60: 00,80   func                0,128
9a62: 00,80   func                0,128
9a64: 00,80   func                0,128

# Canister Purge Duty Cycle Multiplier - FN602

9a66: ff,80   func              255,128
9a68: 08,80   func                8,128
9a6a: 00,00   func                0,  0
9a6c: 00,00   func                0,  0
9a6e: 00,00   func                0,  0
9a70: 00,00   func                0,  0

# Canister Purge Duty Cycle vs Airmass -  Conversion to be determined.

9a72: ff,80   func              255,128
9a74: 50,80   func               80,128
9a76: 28,33   func               40, 51
9a78: 14,2d   func               20, 45
9a7a: 0c,00   func               12,  0
9a7c: 00,00   func                0,  0

################################################### Reg 0xFC points here (9a7e)


9a7e: 5a,9e               word   9e5a

9a80: 00                  byte    0                                                Percent Load Switch - Set for load% = load, clear for load% = load/peak load

9a81: ff                        

9a82: 00,7d               word   7d00            Halffuelon                        # Half fuel on


  Halffueloff:
9a84: 30,75,ff,ff,ff,ff   ??                                                       # Half fuel off
 # Speed Limiter A On
 # Speed Limiter A Off
 # Speed Limiter B On
 # Speed Limit
                                                                                   er B Off

9a8a: 00,28               word   2800            Spdlim_a_off

9a8c: 3c                  byte   3c                                                # ECT limit LO
9a8d: 64                  byte   64                                                # ECT limit Hi

9a8e: 00,00,03,ff         ??    

9a92: c0,8a               word   8ac0            Openlpv                           # throttle position to force open loop (TPS voltage - 1)


  Max_rpm_f:
9a94: 60,6d,90,01         ??                                                       # no fuel rpm (max rpm)
 # rev limit

9a98: 01                  byte    1                                                # Min no of HEGO switches required for WARM_EGO_FLAG to be set.

9a99: ff                        

9a9a: a4,00               word     a4            Min_cl_ld                         # min load for open loop
9a9c: a4,00               word     a4            Min_ld_cl                         # min load for closed loop
9a9e: ae,07               word    7ae            HLODH                             # Upper LOAD Limit for Closed Loop Fuel Control,unitless

9aa0: 10                  byte   10              Ol_time                           # Time at high load to force Open Loop (secs)

9aa1: ff                        

9aa2: 66,a6               word   a666            Lammax                            # Desired A/F Ratio Max -  is clipped to this limit = 1.30
9aa4: 00,60               word   6000            Lammin                            # Desired A/F Ratio Min -  is clipped to this limit = 0.75

9aa6: 8f,02               ??    

9aa8: 00                  byte    0

9aa9: 01                        

9aaa: 68,01               word    168
9aac: 00,01               word    100

9aae: 01                  byte    1
9aaf: 01                  byte    1              InJPP                             Injectors Per Output Port -  No of injectors fired by each port.
9ab0: 08                  byte    8              Cyl_wrap                          # no of cyls
9ab1: 01                  byte    1              Outinj                            # Injector Fire Method -  1 = sequential, 2 = simultaneous
9ab2: 00                  byte    0
9ab3: 00                  byte    0
9ab4: 00                  byte    0
9ab5: ff                  byte   ff

9ab6: 48,0d               word    d48                                              # Max RPM for Idle -  max rpm to allow Idle Flag to be set when Closed Throttle flag set.
9ab8: 20,03               word    320

9aba: 58                  byte   58
9abb: 58                  byte   58
9abc: 00                  byte    0
9abd: 4b                  byte   4b                                                # NITMR3 - ATMR1 timed delay to enter Closed Loop fuel after Hot start, seconds.

9abe: bd                        

9abf: 00                  byte    0

9ac0: 00,bd               ??    

9ac2: 80                  byte   80
9ac3: 46                  byte   46              Minect_shut                       # min ect for decel fuel shutoff (Deg F - 140)

9ac4: 48,01               word    148                                              # Fuel Shut Off Max Load.
9ac6: ec,01               word    1ec                                              # Fuel Shut Off Max Load Hysterysis.  
9ac8: 58,02               word    258            Minrpm_shut                       # Min RPM for Decel Fuel Shut Off.
9aca: 58,02               word    258                                              # Min RPM for Decel Fuel Shut Off Hysterysis.

9acc: 10                  byte   10                                                # Fuel Shut Off Neutral Max Time - DSTM1
9acd: 00                  byte    0                                                # Fuel Shut Off Shift Max Time - DSTM2
9ace: f8                  byte   f8
9acf: f8                  byte   f8                                                # Decel Fuel Shut Off Time Extended - CTEDSO
9ad0: 06                  byte    6                                                # Fuel Shut Off Min Time at PT - DSFTM
9ad1: 04                  byte    4              Pipnum                            # Fuel Shut Off Min PIP To Remain O/L - PIPNUM

9ad2: c0,00               ??    

9ad4: 28,0a               word    a28            SHFRPM                            # Fuel Shut Off Shift Min RPM - SHFRPM
9ad6: 58,02               word    258            SHMRPMH                           # Fuel Shut Off Shift Min RPM Hysterysis - SHFHYS

9ad8: 73,00               ??    

9ada: 0a                  byte    a              DFSVS                             # Fuel Shut Off Deceleration Min MPH - DFSVS
9adb: 04                  byte    4              DFSVSH                            # Fuel Shut Off Deceleration Min MPH Hysterysis - DFSVSH

9adc: 00,00               word      0
9ade: 00,00               word      0

9ae0: 00                  byte    0
9ae1: 00                  byte    0                                                # Fuel Shut Off PT Enable -  1 = PT decel fuel shut off, 0 = CT decel fuel shut off.
9ae2: 55                  byte   55              MinECT_adp                        # Adaptive ECT Min - AFECT1
9ae3: 71                  byte   71              MaxECT_adp
9ae4: 32                  byte   32              Minact_adp                        # Min ACT for Adaptive Control - AFACT1
9ae5: 64                  byte   64              Maxact_adp                        # Max ACT for Adaptive Control - AFACT2

9ae6: 3c,00               word     3c            ADAPTIM                           # Adaptive Delay Time - ADAPTM
9ae8: 7b,04               word    47b
9aea: 40,00               word     40
9aec: 40,00               word     40

9aee: 61                  byte   61              Adp_ctl_min                       # Adaptive Control Min - MINADP
9aef: 9f                  byte   9f              Adp_ctl_max                       # Adaptive Control Max - MAXADP

9af0: 00,00               word      0
9af2: 00,00               word      0            LMBJMP                            # HEGO Rich Correction - LMBJMP
9af4: c5,00               word     c5

9af6: 00                  byte    0
9af7: 00                  byte    0
9af8: 06                  byte    6                                                # Adaptive Max Fast Cycles - KWUCNT

9af9: 2e                        

9afa: 00                  byte    0                                                # Adaptive Idle Low RPM - HCAMSW

9afb: ff                        

#  ISC Time Scaler for Time 


  HCAMSW:
9afc: ff,ff,00,05   func        65535, 1280
9b00: 1e,00,00,05   func           30, 1280
9b04: 0a,00,00,03   func           10,  768
9b08: 05,00,00,02   func            5,  512
9b0c: 00,00,00,00   func            0,    0

# Table - Emission Table RPM scaling


  Emm_rscale:
9b10: ff,ff,00,03   func        65535,  768
9b14: e0,2e,00,03   func        12000,  768
9b18: 10,0e,00,01   func         3600,  256
9b1c: f0,0a,00,00   func         2800,    0
9b20: 00,00,00,00   func            0,    0
9b24: 00,00,00,00   func            0,    0
9b28: 00,00,00,00   func            0,    0
9b2c: 00,00,00,00   func            0,    0

# Func - Injector Offset vs Battery Voltage  (Reduce for larger injectors).


  Inj_vss:
9b30: ff,1d   func              255, 29
9b32: e0,1d   func              224, 29
9b34: d0,20   func              208, 32
9b36: c0,25   func              192, 37
9b38: b0,2d   func              176, 45
9b3a: a0,36   func              160, 54
9b3c: 90,41   func              144, 65
9b3e: 80,53   func              128, 83
9b40: 70,71   func              112,113
9b42: 60,b1   func               96,177
9b44: 58,f0   func               88,240

# Func - Open Loop Fuel Multiplier vs ACT - FN300
9b46: 00,f0   func                0,240


  Olactmult:
9b48: 7f,40   func               127, 64
9b4a: 26,40   func                38, 64
9b4c: 00,34   func                 0, 52
9b4e: ec,29   func               -20, 41
9b50: 80,29   func              -128, 41
9b52: 80,29   func              -128, 41

# Func - Closed Throttle, Open Loop Fuel Multiplier vs ACT - FN301


  Cl_ol_fuel:
9b54: ff,ff,80,00   func        65535,  128
9b58: 00,00,80,00   func            0,  128
9b5c: 00,00,80,00   func            0,  128
9b60: 00,00,80,00   func            0,  128
9b64: 00,00,80,00   func            0,  128
9b68: 00,00,80,00   func            0,  128

# Func - Fuel Idle Neutral Multiplier - FN301N

9b6c: ff,ff,80,00   func        65535,  128
9b70: 00,00,80,00   func            0,  128
9b74: 00,00,80,00   func            0,  128
9b78: 00,00,80,00   func            0,  128
9b7c: 00,00,80,00   func            0,  128

# Func - WOT Fuel Multiplier vs RPM - FN303


  Wot_fuel_mlt:
9b80: ff,ff,79,00   func        65535,  121
9b84: c0,5d,79,00   func        24000,  121
9b88: c0,44,7a,00   func        17600,  122
9b8c: 60,3b,7d,00   func        15200,  125
9b90: 00,32,79,00   func        12800,  121
9b94: 80,25,7c,00   func         9600,  124
9b98: 00,19,74,00   func         6400,  116
9b9c: 00,00,80,00   func            0,  128

# Table - MAF Backflow Correction
# Multiplier of raw air mass to compensate for backflow in the MAF sensor.

9ba0: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9baa: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9bb4: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9bbe: 80,83,80,80,80,80,80,80,80,80   table 128,131,128,128,128,128,128,128,128,128
9bc8: 80,83,83,80,80,80,80,80,80,80   table 128,131,131,128,128,128,128,128,128,128
9bd2: 84,84,84,80,80,80,80,80,80,80   table 132,132,132,128,128,128,128,128,128,128
9bdc: 86,86,85,80,80,80,80,80,80,80   table 134,134,133,128,128,128,128,128,128,128
9be6: 86,86,86,80,80,80,80,80,80,80   table 134,134,134,128,128,128,128,128,128,128

# Table - Base Fuel  (A/F ratio load vs ECT)
#  A/F ratio - load vs ECT,  Used when ECT is low and WARM_HEGO_FLAG = 0
# 10 Cols: ECT [DegF]  -30,0,30,60,90,120,150,180,210,240
#  8 Rows: Load []   .05, .15, .30, .40, .55, .70, .80, .90

9bf0: 8f,8f,8d,8a,85,83,80,7a,7a,7a   table 143,143,141,138,133,131,128,122,122,122
9bfa: 8d,8d,88,85,84,83,80,7a,7a,7a   table 141,141,136,133,132,131,128,122,122,122
9c04: 71,72,72,73,74,76,76,7a,7a,73   table 113,114,114,115,116,118,118,122,122,115
9c0e: 6d,73,73,73,77,7a,7a,80,80,76   table 109,115,115,115,119,122,122,128,128,118
9c18: 66,6f,72,73,77,77,7a,80,80,78   table 102,111,114,115,119,119,122,128,128,120
9c22: 61,61,6c,6c,6f,73,71,72,6d,6d   table  97, 97,108,108,111,115,113,114,109,109
9c2c: 5a,5a,66,66,69,6c,6e,6e,6d,6c   table  90, 90,102,102,105,108,110,110,109,108
9c36: 54,54,64,64,66,69,6c,6c,6c,6c   table  84, 84,100,100,102,105,108,108,108,108

# Table - Startup Fuel -  Subtracted from Base Fuel table for warm up enrichment.  [A/F Ratio]

# fuel base (correct address? )
# 10 Cols: ECT [DegF]  -30,0,30,60,90,120,150,180,210,240
#  8 Rows: Time [Sec]  0,3,5,10,15,25,35,45

9c40: 1b,21,18,0f,0f,0f,0f,0b,0f,1b   table  27, 33, 24, 15, 15, 15, 15, 11, 15, 27
9c4a: 17,1d,15,0f,0f,0f,0f,0d,0f,17   table  23, 29, 21, 15, 15, 15, 15, 13, 15, 23
9c54: 16,16,13,0f,0f,0f,0f,0c,0f,16   table  22, 22, 19, 15, 15, 15, 15, 12, 15, 22
9c5e: 12,11,11,0f,0f,0f,0f,0a,0f,12   table  18, 17, 17, 15, 15, 15, 15, 10, 15, 18
9c68: 0d,0d,0c,0b,0a,0b,0b,09,0b,0d   table  13, 13, 12, 11, 10, 11, 11,  9, 11, 13
9c72: 0a,0c,09,08,08,0a,0a,07,08,0a   table  10, 12,  9,  8,  8, 10, 10,  7,  8, 10
9c7c: 08,0a,07,04,03,07,07,02,04,08   table   8, 10,  7,  4,  3,  7,  7,  2,  4,  8
9c86: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# Peak Load at Sea Level vs RPM
# Adjust if engine is substantially more efficient than stock and Percent Load Switch is not set.

9c90: ff,ff,1f,65   func        65535,25887
9c94: 20,4e,1f,65   func        20000,25887
9c98: b0,36,71,6d   func        14000,28017
9c9c: 40,1f,cd,5c   func         8000,23757
9ca0: 18,15,85,5b   func         5400,23429
9ca4: a0,0f,66,56   func         4000,22118
9ca8: 00,00,33,53   func            0,21299

 # Load Limit Open Loop vs ECT - FN320A

9cac: ff,7f,9a,59   func         32767,22938
9cb0: 69,00,9a,59   func           105,22938
9cb4: 64,00,d7,63   func           100,25559
9cb8: 00,80,d7,63   func        -32768,25559
9cbc: 00,80,d7,63   func        -32768,25559
9cc0: 00,80,d7,63   func        -32768,25559
9cc4: 00,80,d7,63   func        -32768,25559

 # Fuel Drive Engagement vs ECT - FN371

9cc8: ff,7f,00,01   func         32767,  256
9ccc: 00,80,00,01   func        -32768,  256
9cd0: 00,80,00,01   func        -32768,  256
9cd4: 00,80,00,01   func        -32768,  256
9cd8: 00,80,00,01   func        -32768,  256
9cdc: 00,80,00,01   func        -32768,  256
9ce0: 00,80,00,01   func        -32768,  256
9ce4: 00,80,00,01   func        -32768,  256

 # Fuel Equilibrium Intake Surface - FN1321

9ce8: 87,87,80,79,70,5a,2e,02,02,02   table 135,135,128,121,112, 90, 46,  2,  2,  2
9cf2: 93,93,8c,84,7a,63,34,04,04,04   table 147,147,140,132,122, 99, 52,  4,  4,  4
9cfc: a3,a3,9a,91,86,6d,3a,05,04,04   table 163,163,154,145,134,109, 58,  5,  4,  4
9d06: b3,b3,a9,9e,92,78,43,08,07,06   table 179,179,169,158,146,120, 67,  8,  7,  6
9d10: c3,c3,b9,ad,a0,85,4e,0c,09,08   table 195,195,185,173,160,133, 78, 12,  9,  8
9d1a: d5,d5,c9,bd,af,94,5d,12,0d,09   table 213,213,201,189,175,148, 93, 18, 13,  9
9d24: e7,e7,dc,cf,c0,a7,75,1b,13,0b   table 231,231,220,207,192,167,117, 27, 19, 11
9d2e: ff,ff,f2,e3,d2,bf,98,29,1d,10   table 255,255,242,227,210,191,152, 41, 29, 16
# Fuel Equilibrium Time Constant - FN1322
# 10 Cols  8 Rows


  ECT_fuel:
9d38: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d42: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d4c: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d56: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d60: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d6a: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d74: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d7e: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48

# Table - Exhaust Pulse Delay
# The time, in revs per second, from when a fuel change is made until the HEGO sensor indicates this change. 
# Result is used to calculate the transport delay in PIPs and seconds.


  Ex_pulse:
9d88: 28,28,28,28   table        40, 40, 40, 40
9d8c: 28,28,28,28   table        40, 40, 40, 40
9d90: 28,28,28,28   table        40, 40, 40, 40
9d94: 28,28,28,28   table        40, 40, 40, 40
9d98: 28,28,28,28   table        40, 40, 40, 40
9d9c: 28,28,28,28   table        40, 40, 40, 40
9da0: 28,28,28,28   table        40, 40, 40, 40
9da4: 28,28,28,28   table        40, 40, 40, 40

# Table - HEGO amplitude


  Hego_ampl:
9da8: 11,11,11,11   table        17, 17, 17, 17
9dac: 11,11,11,11   table        17, 17, 17, 17
9db0: 11,11,11,11   table        17, 17, 17, 17
9db4: 11,11,11,11   table        17, 17, 17, 17
9db8: 11,11,11,11   table        17, 17, 17, 17
9dbc: 11,11,11,11   table        17, 17, 17, 17
9dc0: 11,11,11,11   table        17, 17, 17, 17
9dc4: 11,11,11,11   table        17, 17, 17, 17

# Table - HEGO bias
# Allows the averaged A/F ratio to be shifted slightly rich or lean to adjust emissions.
# A rich mixture will lower NOx but raise CO, a lean mixture will do the opposite.


  Hego_bias:
9dc8: 00,0e,0e,0e   table         0, 14, 14, 14
9dcc: 00,04,04,04   table         0,  4,  4,  4
9dd0: 00,00,00,00   table         0,  0,  0,  0
9dd4: 00,fc,fc,fc   table         0,252,252,252
9dd8: 00,fc,fc,fc   table         0,252,252,252
9ddc: fc,f8,f8,f8   table       252,248,248,248
9de0: fc,f4,f4,f4   table       252,244,244,244
9de4: f0,f0,f0,f0   table       240,240,240,240

# Func: Open Loop Fuel Multiplier vs RPM (FN374)


  Ol_fuel_mult:
9de8: ff,ff,00,00   func        65535,    0
9dec: 30,11,00,00   func         4400,    0
9df0: cc,10,80,00   func         4300,  128
9df4: 00,00,80,00   func            0,  128
9df8: 00,00,80,00   func            0,  128
9dfc: 00,00,80,00   func            0,  128

Table - Adaptive Control Update Rate - FN1325    (for learning cells ?)

9e00: ae                  byte   ae              Lcellindx

9e01: ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae,ae  
9e11: ae,ae,ae,64,64,0a,0a,0a ?? 
9e19: 0a,0a,0a,0a,0a,64,64,0a ?? 
9e21: 0a,0a,0a,0a,0a,0a,0a,d5 ?? 
9e29: d5,d5,0a,0a,0a,0a,0a,0a ?? 
9e31: 0a,cb,cb,cb,0a,0a,0a,0a ?? 
9e39: 0a,0a,0a,c1,c1,c1,0a,0a ?? 
9e41: 0a,0a,0a,c7,c7,c7,c7,c7 ?? 
9e49: c7,c7,c7,c7,c7,c7,c7      

9e50: c7                  byte   c7

9e51: c7,0a,0a,a7,a7,a7,a7,a7 ?? 

################## Reg 0xFE points here (9e5a) ############################

9e59: 64                        

9e5a: a2,9e               word   9ea2

## TRLoad - Transmission Type -  0 = manual, no clutch or gear switches, forced neutral state
# 1 = manual, no clutch or gear switches  2 = manual, one clutch or gear switch 3 = manual, both clutch and gear switches
# 4 = non electronic auto, neutral drive switch  5 = non electronic auto, neutral pressure switch, 6 = electronic auto , PRNDL sensor

9e5c: 03                  byte    3              TRLOAD

## Tstrat - Transmission Strategy -  Selects which transmission strategy to use;
# 0 = no transmission control  1 = SIL (shift indicator light) 2 = A4LD with 3/4 shift control and convertor clutch control 
# 3 = AXOD  4 = C6E4 (E4OD)  5 = A4LD-E  6 = FAX-4  7 = AOD-4 (AOD-I)  8 = 4EAT  9 = CD4E
9e5d: 00                  byte    0              Tstrat
9e5e: 55                  byte   55              CThigh                            # Hot Start Min ECT -  The minimum ECT for a hot start condition to be recognised.
9e5f: 1c                  byte   1c              CtLow                             # Cold Start Max ECT -  The maximum ECT for a cold start condition to be recognised.
9e60: 44                  byte   44
9e61: 08                  byte    8              PIPsC                             # PIPs per Cycle -  Number of PIPs per dizzy rev. (2 engine revs)

9e62: 20,03               ??    

9e64: 01                  byte    1                                                # Lambda Reset Switch -  Set if desired A/F ratio is to be clipped to be no leaner than 14.64 whe
                                                                                   n transiting from O/L to C/L.
9e65: 01                  byte    1              Thrmhp                            # Thermactor H/W Present (values 1,2,3 checked...)
9e66: 00                  byte    0              Hpcid                             # CID Sensor Present
9e67: 00                  byte    0              Hp_cidsel                         # CID Sensor Type - 1 = Variable Reluctance 0 = Hall Effect sensor.

# Signature PIP duty cycle, 8 cyls/<35% = .20, 6 cyls/< 30% = .24, 4 cyls/30% =  .29, Not present = 0.99

9e68: 33,33               word   3333            MHPFD
9e6a: 00,7d               word   7d00            Trsrpm
9e6c: 90,01               word    190            Trsrph

9e6e: 02                  byte    2
9e6f: 02                  byte    2
9e70: 02                  byte    2              No_hegos                          # no of HEGOs

9e71: ff                        

9e72: 2c,b3               word   b32c
9e74: 00,02               word    200            MINAM                             # MAF Min Airmass Clip
9e76: 00,00               word      0

9e78: 3f                  byte   3f
9e79: 06                  byte    6
9e7a: 13                  byte   13
9e7b: 9a                  byte   9a
9e7c: 66                  byte   66

9e7d: ff                        

9e7e: 40,00               word     40
9e80: cd,08               word    8cd            IFAM
9e82: 00,60               word   6000
9e84: 66,a6               word   a666
9e86: 33,73               word   7333
9e88: a0,40               word   40a0
9e8a: 80,ff               word   ff80
9e8c: c8,00               word     c8
9e8e: e8,03               word    3e8
9e90: 50,ff               word   ff50
9e92: e8,03               word    3e8
9e94: 7d,00               word     7d
9e96: 9a,09               word    99a
9e98: 66,f6               word   f666
9e9a: 93,00               word     93
9e9c: bd,00               word     bd
9e9e: 05,00               word      5

9ea0: 80                  byte   80



## 9ea1 to 9fff = 0xff  (filler ?) ## 





